define('@glimmer/runtime', ['exports', '@glimmer/reference', '@glimmer/util', '@glimmer/vm', '@glimmer/destroyable', '@glimmer/global-context', '@glimmer/env', '@glimmer/validator', '@glimmer/manager', '@glimmer/program', '@glimmer/owner', '@glimmer/runtime'], function (exports, reference, util, vm, destroyable, globalContext, env, validator, manager, program, owner, runtime) { 'use strict';

  var DynamicScopeImpl = /*#__PURE__*/function () {
    function DynamicScopeImpl(bucket) {
      if (bucket) {
        this.bucket = util.assign({}, bucket);
      } else {
        this.bucket = {};
      }
    }

    var _proto = DynamicScopeImpl.prototype;

    _proto.get = function get(key) {
      return this.bucket[key];
    };

    _proto.set = function set(key, reference) {
      return this.bucket[key] = reference;
    };

    _proto.child = function child() {
      return new DynamicScopeImpl(this.bucket);
    };

    return DynamicScopeImpl;
  }();
  var PartialScopeImpl = /*#__PURE__*/function () {
    function PartialScopeImpl( // the 0th slot is `self`
    slots, owner, callerScope, // named arguments and blocks passed to a layout that uses eval
    evalScope, // locals in scope when the partial was invoked
    partialMap) {
      this.slots = slots;
      this.owner = owner;
      this.callerScope = callerScope;
      this.evalScope = evalScope;
      this.partialMap = partialMap;
    }

    PartialScopeImpl.root = function root(self, size, owner) {
      if (size === void 0) {
        size = 0;
      }

      var refs = new Array(size + 1);

      for (var i = 0; i <= size; i++) {
        refs[i] = reference.UNDEFINED_REFERENCE;
      }

      return new PartialScopeImpl(refs, owner, null, null, null).init({
        self: self
      });
    };

    PartialScopeImpl.sized = function sized(size, owner) {
      if (size === void 0) {
        size = 0;
      }

      var refs = new Array(size + 1);

      for (var i = 0; i <= size; i++) {
        refs[i] = reference.UNDEFINED_REFERENCE;
      }

      return new PartialScopeImpl(refs, owner, null, null, null);
    };

    var _proto2 = PartialScopeImpl.prototype;

    _proto2.init = function init(_ref) {
      var self = _ref.self;
      this.slots[0] = self;
      return this;
    };

    _proto2.getSelf = function getSelf() {
      return this.get(0);
    };

    _proto2.getSymbol = function getSymbol(symbol) {
      return this.get(symbol);
    };

    _proto2.getBlock = function getBlock(symbol) {
      var block = this.get(symbol);
      return block === reference.UNDEFINED_REFERENCE ? null : block;
    };

    _proto2.getEvalScope = function getEvalScope() {
      return this.evalScope;
    };

    _proto2.getPartialMap = function getPartialMap() {
      return this.partialMap;
    };

    _proto2.bind = function bind(symbol, value) {
      this.set(symbol, value);
    };

    _proto2.bindSelf = function bindSelf(self) {
      this.set(0, self);
    };

    _proto2.bindSymbol = function bindSymbol(symbol, value) {
      this.set(symbol, value);
    };

    _proto2.bindBlock = function bindBlock(symbol, value) {
      this.set(symbol, value);
    };

    _proto2.bindEvalScope = function bindEvalScope(map) {
      this.evalScope = map;
    };

    _proto2.bindPartialMap = function bindPartialMap(map) {
      this.partialMap = map;
    };

    _proto2.bindCallerScope = function bindCallerScope(scope) {
      this.callerScope = scope;
    };

    _proto2.getCallerScope = function getCallerScope() {
      return this.callerScope;
    };

    _proto2.child = function child() {
      return new PartialScopeImpl(this.slots.slice(), this.owner, this.callerScope, this.evalScope, this.partialMap);
    };

    _proto2.get = function get(index) {
      if (index >= this.slots.length) {
        throw new RangeError("BUG: cannot get $" + index + " from scope; length=" + this.slots.length);
      }

      return this.slots[index];
    };

    _proto2.set = function set(index, value) {
      if (index >= this.slots.length) {
        throw new RangeError("BUG: cannot get $" + index + " from scope; length=" + this.slots.length);
      }

      this.slots[index] = value;
    };

    return PartialScopeImpl;
  }();

  // the VM in other classes, but are not intended to be a part of
  // Glimmer's API.

  var INNER_VM = util.symbol('INNER_VM');
  var DESTROYABLE_STACK = util.symbol('DESTROYABLE_STACK');
  var STACKS = util.symbol('STACKS');
  var REGISTERS = util.symbol('REGISTERS');
  var HEAP = util.symbol('HEAP');
  var CONSTANTS = util.symbol('CONSTANTS');
  var ARGS = util.symbol('ARGS');
  var PC = util.symbol('PC');

  var CursorImpl = function CursorImpl(element, nextSibling) {
    this.element = element;
    this.nextSibling = nextSibling;
  };
  var ConcreteBounds = /*#__PURE__*/function () {
    function ConcreteBounds(parentNode, first, last) {
      this.parentNode = parentNode;
      this.first = first;
      this.last = last;
    }

    var _proto = ConcreteBounds.prototype;

    _proto.parentElement = function parentElement() {
      return this.parentNode;
    };

    _proto.firstNode = function firstNode() {
      return this.first;
    };

    _proto.lastNode = function lastNode() {
      return this.last;
    };

    return ConcreteBounds;
  }();
  var SingleNodeBounds = /*#__PURE__*/function () {
    function SingleNodeBounds(parentNode, node) {
      this.parentNode = parentNode;
      this.node = node;
    }

    var _proto2 = SingleNodeBounds.prototype;

    _proto2.parentElement = function parentElement() {
      return this.parentNode;
    };

    _proto2.firstNode = function firstNode() {
      return this.node;
    };

    _proto2.lastNode = function lastNode() {
      return this.node;
    };

    return SingleNodeBounds;
  }();
  function move(bounds, reference) {
    var parent = bounds.parentElement();
    var first = bounds.firstNode();
    var last = bounds.lastNode();
    var current = first;

    while (true) {
      var next = current.nextSibling;
      parent.insertBefore(current, reference);

      if (current === last) {
        return next;
      }

      current = next;
    }
  }
  function clear(bounds) {
    var parent = bounds.parentElement();
    var first = bounds.firstNode();
    var last = bounds.lastNode();
    var current = first;

    while (true) {
      var next = current.nextSibling;
      parent.removeChild(current);

      if (current === last) {
        return next;
      }

      current = next;
    }
  }

  function normalizeStringValue(value) {
    if (isEmpty(value)) {
      return '';
    }

    return String(value);
  }
  function shouldCoerce(value) {
    return isString(value) || isEmpty(value) || typeof value === 'boolean' || typeof value === 'number';
  }
  function isEmpty(value) {
    return value === null || value === undefined || typeof value.toString !== 'function';
  }
  function isSafeString(value) {
    return typeof value === 'object' && value !== null && typeof value.toHTML === 'function';
  }
  function isNode(value) {
    return typeof value === 'object' && value !== null && typeof value.nodeType === 'number';
  }
  function isFragment(value) {
    return isNode(value) && value.nodeType === 11;
  }
  function isString(value) {
    return typeof value === 'string';
  }

  /*
   * @method normalizeProperty
   * @param element {HTMLElement}
   * @param slotName {String}
   * @returns {Object} { name, type }
   */
  function normalizeProperty(element, slotName) {
    var type, normalized;

    if (slotName in element) {
      normalized = slotName;
      type = 'prop';
    } else {
      var lower = slotName.toLowerCase();

      if (lower in element) {
        type = 'prop';
        normalized = lower;
      } else {
        type = 'attr';
        normalized = slotName;
      }
    }

    if (type === 'prop' && (normalized.toLowerCase() === 'style' || preferAttr(element.tagName, normalized))) {
      type = 'attr';
    }

    return {
      normalized: normalized,
      type: type
    };
  }
  // * browser bug
  // * strange spec outlier

  var ATTR_OVERRIDES = {
    INPUT: {
      form: true,
      // Chrome 46.0.2464.0: 'autocorrect' in document.createElement('input') === false
      // Safari 8.0.7: 'autocorrect' in document.createElement('input') === false
      // Mobile Safari (iOS 8.4 simulator): 'autocorrect' in document.createElement('input') === true
      autocorrect: true,
      // Chrome 54.0.2840.98: 'list' in document.createElement('input') === true
      // Safari 9.1.3: 'list' in document.createElement('input') === false
      list: true
    },
    // element.form is actually a legitimate readOnly property, that is to be
    // mutated, but must be mutated by setAttribute...
    SELECT: {
      form: true
    },
    OPTION: {
      form: true
    },
    TEXTAREA: {
      form: true
    },
    LABEL: {
      form: true
    },
    FIELDSET: {
      form: true
    },
    LEGEND: {
      form: true
    },
    OBJECT: {
      form: true
    },
    OUTPUT: {
      form: true
    },
    BUTTON: {
      form: true
    }
  };

  function preferAttr(tagName, propName) {
    var tag = ATTR_OVERRIDES[tagName.toUpperCase()];
    return tag && tag[propName.toLowerCase()] || false;
  }

  var badProtocols = ['javascript:', 'vbscript:'];
  var badTags = ['A', 'BODY', 'LINK', 'IMG', 'IFRAME', 'BASE', 'FORM'];
  var badTagsForDataURI = ['EMBED'];
  var badAttributes = ['href', 'src', 'background', 'action'];
  var badAttributesForDataURI = ['src'];

  function has(array, item) {
    return array.indexOf(item) !== -1;
  }

  function checkURI(tagName, attribute) {
    return (tagName === null || has(badTags, tagName)) && has(badAttributes, attribute);
  }

  function checkDataURI(tagName, attribute) {
    if (tagName === null) return false;
    return has(badTagsForDataURI, tagName) && has(badAttributesForDataURI, attribute);
  }

  function requiresSanitization(tagName, attribute) {
    return checkURI(tagName, attribute) || checkDataURI(tagName, attribute);
  }
  var protocolForUrl;

  if (typeof URL === 'object' && URL !== null && // this is super annoying, TS thinks that URL **must** be a function so `URL.parse` check
  // thinks it is `never` without this `as unknown as any`
  typeof URL.parse === 'function') {
    // In Ember-land the `fastboot` package sets the `URL` global to `require('url')`
    // ultimately, this should be changed (so that we can either rely on the natural `URL` global
    // that exists) but for now we have to detect the specific `FastBoot` case first
    //
    // a future version of `fastboot` will detect if this legacy URL setup is required (by
    // inspecting Ember version) and if new enough, it will avoid shadowing the `URL` global
    // constructor with `require('url')`.
    var nodeURL = URL;

    protocolForUrl = function protocolForUrl(url) {
      var protocol = null;

      if (typeof url === 'string') {
        protocol = nodeURL.parse(url).protocol;
      }

      return protocol === null ? ':' : protocol;
    };
  } else if (typeof URL === 'function') {
    protocolForUrl = function protocolForUrl(_url) {
      try {
        var url = new URL(_url);
        return url.protocol;
      } catch (error) {
        // any non-fully qualified url string will trigger an error (because there is no
        // baseURI that we can provide; in that case we **know** that the protocol is
        // "safe" because it isn't specifically one of the `badProtocols` listed above
        // (and those protocols can never be the default baseURI)
        return ':';
      }
    };
  } else {
    // fallback for IE11 support
    var parsingNode = document.createElement('a');

    protocolForUrl = function protocolForUrl(url) {
      parsingNode.href = url;
      return parsingNode.protocol;
    };
  }

  function sanitizeAttributeValue(element, attribute, value) {
    var tagName = null;

    if (value === null || value === undefined) {
      return value;
    }

    if (isSafeString(value)) {
      return value.toHTML();
    }

    if (!element) {
      tagName = null;
    } else {
      tagName = element.tagName.toUpperCase();
    }

    var str = normalizeStringValue(value);

    if (checkURI(tagName, attribute)) {
      var protocol = protocolForUrl(str);

      if (has(badProtocols, protocol)) {
        return "unsafe:" + str;
      }
    }

    if (checkDataURI(tagName, attribute)) {
      return "unsafe:" + str;
    }

    return str;
  }

  function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  function dynamicAttribute(element, attr, namespace, isTrusting) {
    if (isTrusting === void 0) {
      isTrusting = false;
    }

    var tagName = element.tagName,
        namespaceURI = element.namespaceURI;
    var attribute = {
      element: element,
      name: attr,
      namespace: namespace
    };

    if (env.DEBUG && attr === 'style' && !isTrusting) {
      return new DebugStyleAttributeManager(attribute);
    }

    if (namespaceURI === "http://www.w3.org/2000/svg"
    /* SVG */
    ) {
        return buildDynamicAttribute(tagName, attr, attribute);
      }

    var _normalizeProperty = normalizeProperty(element, attr),
        type = _normalizeProperty.type,
        normalized = _normalizeProperty.normalized;

    if (type === 'attr') {
      return buildDynamicAttribute(tagName, normalized, attribute);
    } else {
      return buildDynamicProperty(tagName, normalized, attribute);
    }
  }

  function buildDynamicAttribute(tagName, name, attribute) {
    if (requiresSanitization(tagName, name)) {
      return new SafeDynamicAttribute(attribute);
    } else {
      return new SimpleDynamicAttribute(attribute);
    }
  }

  function buildDynamicProperty(tagName, name, attribute) {
    if (requiresSanitization(tagName, name)) {
      return new SafeDynamicProperty(name, attribute);
    }

    if (isUserInputValue(tagName, name)) {
      return new InputValueDynamicAttribute(name, attribute);
    }

    if (isOptionSelected(tagName, name)) {
      return new OptionSelectedDynamicAttribute(name, attribute);
    }

    return new DefaultDynamicProperty(name, attribute);
  }

  var DynamicAttribute = function DynamicAttribute(attribute) {
    this.attribute = attribute;
  };
  var SimpleDynamicAttribute = /*#__PURE__*/function (_DynamicAttribute) {
    _inheritsLoose(SimpleDynamicAttribute, _DynamicAttribute);

    function SimpleDynamicAttribute() {
      return _DynamicAttribute.apply(this, arguments) || this;
    }

    var _proto = SimpleDynamicAttribute.prototype;

    _proto.set = function set(dom, value, _env) {
      var normalizedValue = normalizeValue(value);

      if (normalizedValue !== null) {
        var _this$attribute = this.attribute,
            name = _this$attribute.name,
            namespace = _this$attribute.namespace;

        dom.__setAttribute(name, normalizedValue, namespace);
      }
    };

    _proto.update = function update(value, _env) {
      var normalizedValue = normalizeValue(value);
      var _this$attribute2 = this.attribute,
          element = _this$attribute2.element,
          name = _this$attribute2.name;

      if (normalizedValue === null) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, normalizedValue);
      }
    };

    return SimpleDynamicAttribute;
  }(DynamicAttribute);
  var DefaultDynamicProperty = /*#__PURE__*/function (_DynamicAttribute2) {
    _inheritsLoose(DefaultDynamicProperty, _DynamicAttribute2);

    function DefaultDynamicProperty(normalizedName, attribute) {
      var _this;

      _this = _DynamicAttribute2.call(this, attribute) || this;
      _this.normalizedName = normalizedName;
      return _this;
    }

    var _proto2 = DefaultDynamicProperty.prototype;

    _proto2.set = function set(dom, value, _env) {
      if (value !== null && value !== undefined) {
        this.value = value;

        dom.__setProperty(this.normalizedName, value);
      }
    };

    _proto2.update = function update(value, _env) {
      var element = this.attribute.element;

      if (this.value !== value) {
        element[this.normalizedName] = this.value = value;

        if (value === null || value === undefined) {
          this.removeAttribute();
        }
      }
    };

    _proto2.removeAttribute = function removeAttribute() {
      // TODO this sucks but to preserve properties first and to meet current
      // semantics we must do this.
      var _this$attribute3 = this.attribute,
          element = _this$attribute3.element,
          namespace = _this$attribute3.namespace;

      if (namespace) {
        element.removeAttributeNS(namespace, this.normalizedName);
      } else {
        element.removeAttribute(this.normalizedName);
      }
    };

    return DefaultDynamicProperty;
  }(DynamicAttribute);
  var SafeDynamicProperty = /*#__PURE__*/function (_DefaultDynamicProper) {
    _inheritsLoose(SafeDynamicProperty, _DefaultDynamicProper);

    function SafeDynamicProperty() {
      return _DefaultDynamicProper.apply(this, arguments) || this;
    }

    var _proto3 = SafeDynamicProperty.prototype;

    _proto3.set = function set(dom, value, env) {
      var _this$attribute4 = this.attribute,
          element = _this$attribute4.element,
          name = _this$attribute4.name;
      var sanitized = sanitizeAttributeValue(element, name, value);

      _DefaultDynamicProper.prototype.set.call(this, dom, sanitized, env);
    };

    _proto3.update = function update(value, env) {
      var _this$attribute5 = this.attribute,
          element = _this$attribute5.element,
          name = _this$attribute5.name;
      var sanitized = sanitizeAttributeValue(element, name, value);

      _DefaultDynamicProper.prototype.update.call(this, sanitized, env);
    };

    return SafeDynamicProperty;
  }(DefaultDynamicProperty);
  var SafeDynamicAttribute = /*#__PURE__*/function (_SimpleDynamicAttribu) {
    _inheritsLoose(SafeDynamicAttribute, _SimpleDynamicAttribu);

    function SafeDynamicAttribute() {
      return _SimpleDynamicAttribu.apply(this, arguments) || this;
    }

    var _proto4 = SafeDynamicAttribute.prototype;

    _proto4.set = function set(dom, value, env) {
      var _this$attribute6 = this.attribute,
          element = _this$attribute6.element,
          name = _this$attribute6.name;
      var sanitized = sanitizeAttributeValue(element, name, value);

      _SimpleDynamicAttribu.prototype.set.call(this, dom, sanitized, env);
    };

    _proto4.update = function update(value, env) {
      var _this$attribute7 = this.attribute,
          element = _this$attribute7.element,
          name = _this$attribute7.name;
      var sanitized = sanitizeAttributeValue(element, name, value);

      _SimpleDynamicAttribu.prototype.update.call(this, sanitized, env);
    };

    return SafeDynamicAttribute;
  }(SimpleDynamicAttribute);
  var InputValueDynamicAttribute = /*#__PURE__*/function (_DefaultDynamicProper2) {
    _inheritsLoose(InputValueDynamicAttribute, _DefaultDynamicProper2);

    function InputValueDynamicAttribute() {
      return _DefaultDynamicProper2.apply(this, arguments) || this;
    }

    var _proto5 = InputValueDynamicAttribute.prototype;

    _proto5.set = function set(dom, value) {
      dom.__setProperty('value', normalizeStringValue(value));
    };

    _proto5.update = function update(value) {
      var input = this.attribute.element;
      var currentValue = input.value;
      var normalizedValue = normalizeStringValue(value);

      if (currentValue !== normalizedValue) {
        input.value = normalizedValue;
      }
    };

    return InputValueDynamicAttribute;
  }(DefaultDynamicProperty);
  var OptionSelectedDynamicAttribute = /*#__PURE__*/function (_DefaultDynamicProper3) {
    _inheritsLoose(OptionSelectedDynamicAttribute, _DefaultDynamicProper3);

    function OptionSelectedDynamicAttribute() {
      return _DefaultDynamicProper3.apply(this, arguments) || this;
    }

    var _proto6 = OptionSelectedDynamicAttribute.prototype;

    _proto6.set = function set(dom, value) {
      if (value !== null && value !== undefined && value !== false) {
        dom.__setProperty('selected', true);
      }
    };

    _proto6.update = function update(value) {
      var option = this.attribute.element;

      if (value) {
        option.selected = true;
      } else {
        option.selected = false;
      }
    };

    return OptionSelectedDynamicAttribute;
  }(DefaultDynamicProperty);

  function isOptionSelected(tagName, attribute) {
    return tagName === 'OPTION' && attribute === 'selected';
  }

  function isUserInputValue(tagName, attribute) {
    return (tagName === 'INPUT' || tagName === 'TEXTAREA') && attribute === 'value';
  }

  function normalizeValue(value) {
    if (value === false || value === undefined || value === null || typeof value.toString === 'undefined') {
      return null;
    }

    if (value === true) {
      return '';
    } // onclick function etc in SSR


    if (typeof value === 'function') {
      return null;
    }

    return String(value);
  }

  var DebugStyleAttributeManager;

  if (env.DEBUG) {
    DebugStyleAttributeManager = /*#__PURE__*/function (_SimpleDynamicAttribu2) {
      _inheritsLoose(DebugStyleAttributeManager, _SimpleDynamicAttribu2);

      function DebugStyleAttributeManager() {
        return _SimpleDynamicAttribu2.apply(this, arguments) || this;
      }

      var _proto7 = DebugStyleAttributeManager.prototype;

      _proto7.set = function set(dom, value, env) {
        globalContext.warnIfStyleNotTrusted(value);

        _SimpleDynamicAttribu2.prototype.set.call(this, dom, value, env);
      };

      _proto7.update = function update(value, env) {
        globalContext.warnIfStyleNotTrusted(value);

        _SimpleDynamicAttribu2.prototype.update.call(this, value, env);
      };

      return DebugStyleAttributeManager;
    }(SimpleDynamicAttribute);
  }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _inheritsLoose$1(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var _a;

  var First = /*#__PURE__*/function () {
    function First(node) {
      this.node = node;
    }

    var _proto = First.prototype;

    _proto.firstNode = function firstNode() {
      return this.node;
    };

    return First;
  }();

  var Last = /*#__PURE__*/function () {
    function Last(node) {
      this.node = node;
    }

    var _proto2 = Last.prototype;

    _proto2.lastNode = function lastNode() {
      return this.node;
    };

    return Last;
  }();
  var CURSOR_STACK = util.symbol('CURSOR_STACK');
  var NewElementBuilder = /*#__PURE__*/function () {
    function NewElementBuilder(env, parentNode, nextSibling) {
      this.constructing = null;
      this.operations = null;
      this[_a] = new util.Stack();
      this.modifierStack = new util.Stack();
      this.blockStack = new util.Stack();
      this.pushElement(parentNode, nextSibling);
      this.env = env;
      this.dom = env.getAppendOperations();
      this.updateOperations = env.getDOM();
    }

    NewElementBuilder.forInitialRender = function forInitialRender(env, cursor) {
      return new this(env, cursor.element, cursor.nextSibling).initialize();
    };

    NewElementBuilder.resume = function resume(env, block) {
      var parentNode = block.parentElement();
      var nextSibling = block.reset(env);
      var stack = new this(env, parentNode, nextSibling).initialize();
      stack.pushLiveBlock(block);
      return stack;
    };

    var _proto4 = NewElementBuilder.prototype;

    _proto4.initialize = function initialize() {
      this.pushSimpleBlock();
      return this;
    };

    _proto4.debugBlocks = function debugBlocks() {
      return this.blockStack.toArray();
    };

    _proto4.block = function block() {
      return this.blockStack.current;
    };

    _proto4.popElement = function popElement() {
      this[CURSOR_STACK].pop();
      this[CURSOR_STACK].current;
    };

    _proto4.pushSimpleBlock = function pushSimpleBlock() {
      return this.pushLiveBlock(new SimpleLiveBlock(this.element));
    };

    _proto4.pushUpdatableBlock = function pushUpdatableBlock() {
      return this.pushLiveBlock(new UpdatableBlockImpl(this.element));
    };

    _proto4.pushBlockList = function pushBlockList(list) {
      return this.pushLiveBlock(new LiveBlockList(this.element, list));
    };

    _proto4.pushLiveBlock = function pushLiveBlock(block, isRemote) {
      if (isRemote === void 0) {
        isRemote = false;
      }

      var current = this.blockStack.current;

      if (current !== null) {
        if (!isRemote) {
          current.didAppendBounds(block);
        }
      }

      this.__openBlock();

      this.blockStack.push(block);
      return block;
    };

    _proto4.popBlock = function popBlock() {
      this.block().finalize(this);

      this.__closeBlock();

      return this.blockStack.pop();
    };

    _proto4.__openBlock = function __openBlock() {};

    _proto4.__closeBlock = function __closeBlock() {} // todo return seems unused
    ;

    _proto4.openElement = function openElement(tag) {
      var element = this.__openElement(tag);

      this.constructing = element;
      return element;
    };

    _proto4.__openElement = function __openElement(tag) {
      return this.dom.createElement(tag, this.element);
    };

    _proto4.flushElement = function flushElement(modifiers) {
      var parent = this.element;
      var element = this.constructing;

      this.__flushElement(parent, element);

      this.constructing = null;
      this.operations = null;
      this.pushModifiers(modifiers);
      this.pushElement(element, null);
      this.didOpenElement(element);
    };

    _proto4.__flushElement = function __flushElement(parent, constructing) {
      this.dom.insertBefore(parent, constructing, this.nextSibling);
    };

    _proto4.closeElement = function closeElement() {
      this.willCloseElement();
      this.popElement();
      return this.popModifiers();
    };

    _proto4.pushRemoteElement = function pushRemoteElement(element, guid, insertBefore) {
      return this.__pushRemoteElement(element, guid, insertBefore);
    };

    _proto4.__pushRemoteElement = function __pushRemoteElement(element, _guid, insertBefore) {
      this.pushElement(element, insertBefore);

      if (insertBefore === undefined) {
        while (element.lastChild) {
          element.removeChild(element.lastChild);
        }
      }

      var block = new RemoteLiveBlock(element);
      return this.pushLiveBlock(block, true);
    };

    _proto4.popRemoteElement = function popRemoteElement() {
      this.popBlock();
      this.popElement();
    };

    _proto4.pushElement = function pushElement(element, nextSibling) {
      if (nextSibling === void 0) {
        nextSibling = null;
      }

      this[CURSOR_STACK].push(new CursorImpl(element, nextSibling));
    };

    _proto4.pushModifiers = function pushModifiers(modifiers) {
      this.modifierStack.push(modifiers);
    };

    _proto4.popModifiers = function popModifiers() {
      return this.modifierStack.pop();
    };

    _proto4.didAppendBounds = function didAppendBounds(bounds) {
      this.block().didAppendBounds(bounds);
      return bounds;
    };

    _proto4.didAppendNode = function didAppendNode(node) {
      this.block().didAppendNode(node);
      return node;
    };

    _proto4.didOpenElement = function didOpenElement(element) {
      this.block().openElement(element);
      return element;
    };

    _proto4.willCloseElement = function willCloseElement() {
      this.block().closeElement();
    };

    _proto4.appendText = function appendText(string) {
      return this.didAppendNode(this.__appendText(string));
    };

    _proto4.__appendText = function __appendText(text) {
      var dom = this.dom,
          element = this.element,
          nextSibling = this.nextSibling;
      var node = dom.createTextNode(text);
      dom.insertBefore(element, node, nextSibling);
      return node;
    };

    _proto4.__appendNode = function __appendNode(node) {
      this.dom.insertBefore(this.element, node, this.nextSibling);
      return node;
    };

    _proto4.__appendFragment = function __appendFragment(fragment) {
      var first = fragment.firstChild;

      if (first) {
        var ret = new ConcreteBounds(this.element, first, fragment.lastChild);
        this.dom.insertBefore(this.element, fragment, this.nextSibling);
        return ret;
      } else {
        return new SingleNodeBounds(this.element, this.__appendComment(''));
      }
    };

    _proto4.__appendHTML = function __appendHTML(html) {
      return this.dom.insertHTMLBefore(this.element, this.nextSibling, html);
    };

    _proto4.appendDynamicHTML = function appendDynamicHTML(value) {
      var bounds = this.trustedContent(value);
      this.didAppendBounds(bounds);
    };

    _proto4.appendDynamicText = function appendDynamicText(value) {
      var node = this.untrustedContent(value);
      this.didAppendNode(node);
      return node;
    };

    _proto4.appendDynamicFragment = function appendDynamicFragment(value) {
      var bounds = this.__appendFragment(value);

      this.didAppendBounds(bounds);
    };

    _proto4.appendDynamicNode = function appendDynamicNode(value) {
      var node = this.__appendNode(value);

      var bounds = new SingleNodeBounds(this.element, node);
      this.didAppendBounds(bounds);
    };

    _proto4.trustedContent = function trustedContent(value) {
      return this.__appendHTML(value);
    };

    _proto4.untrustedContent = function untrustedContent(value) {
      return this.__appendText(value);
    };

    _proto4.appendComment = function appendComment(string) {
      return this.didAppendNode(this.__appendComment(string));
    };

    _proto4.__appendComment = function __appendComment(string) {
      var dom = this.dom,
          element = this.element,
          nextSibling = this.nextSibling;
      var node = dom.createComment(string);
      dom.insertBefore(element, node, nextSibling);
      return node;
    };

    _proto4.__setAttribute = function __setAttribute(name, value, namespace) {
      this.dom.setAttribute(this.constructing, name, value, namespace);
    };

    _proto4.__setProperty = function __setProperty(name, value) {
      this.constructing[name] = value;
    };

    _proto4.setStaticAttribute = function setStaticAttribute(name, value, namespace) {
      this.__setAttribute(name, value, namespace);
    };

    _proto4.setDynamicAttribute = function setDynamicAttribute(name, value, trusting, namespace) {
      var element = this.constructing;
      var attribute = dynamicAttribute(element, name, namespace, trusting);
      attribute.set(this, value, this.env);
      return attribute;
    };

    _createClass(NewElementBuilder, [{
      key: "element",
      get: function get() {
        return this[CURSOR_STACK].current.element;
      }
    }, {
      key: "nextSibling",
      get: function get() {
        return this[CURSOR_STACK].current.nextSibling;
      }
    }, {
      key: "hasBlocks",
      get: function get() {
        return this.blockStack.size > 0;
      }
    }]);

    return NewElementBuilder;
  }();
  _a = CURSOR_STACK;
  var SimpleLiveBlock = /*#__PURE__*/function () {
    function SimpleLiveBlock(parent) {
      this.parent = parent;
      this.first = null;
      this.last = null;
      this.nesting = 0;
    }

    var _proto5 = SimpleLiveBlock.prototype;

    _proto5.parentElement = function parentElement() {
      return this.parent;
    };

    _proto5.firstNode = function firstNode() {
      var first = this.first;
      return first.firstNode();
    };

    _proto5.lastNode = function lastNode() {
      var last = this.last;
      return last.lastNode();
    };

    _proto5.openElement = function openElement(element) {
      this.didAppendNode(element);
      this.nesting++;
    };

    _proto5.closeElement = function closeElement() {
      this.nesting--;
    };

    _proto5.didAppendNode = function didAppendNode(node) {
      if (this.nesting !== 0) return;

      if (!this.first) {
        this.first = new First(node);
      }

      this.last = new Last(node);
    };

    _proto5.didAppendBounds = function didAppendBounds(bounds) {
      if (this.nesting !== 0) return;

      if (!this.first) {
        this.first = bounds;
      }

      this.last = bounds;
    };

    _proto5.finalize = function finalize(stack) {
      if (this.first === null) {
        stack.appendComment('');
      }
    };

    return SimpleLiveBlock;
  }();
  var RemoteLiveBlock = /*#__PURE__*/function (_SimpleLiveBlock) {
    _inheritsLoose$1(RemoteLiveBlock, _SimpleLiveBlock);

    function RemoteLiveBlock(parent) {
      var _this;

      _this = _SimpleLiveBlock.call(this, parent) || this;
      destroyable.registerDestructor(_assertThisInitialized(_this), function () {
        // In general, you only need to clear the root of a hierarchy, and should never
        // need to clear any child nodes. This is an important constraint that gives us
        // a strong guarantee that clearing a subtree is a single DOM operation.
        //
        // Because remote blocks are not normally physically nested inside of the tree
        // that they are logically nested inside, we manually clear remote blocks when
        // a logical parent is cleared.
        //
        // HOWEVER, it is currently possible for a remote block to be physically nested
        // inside of the block it is logically contained inside of. This happens when
        // the remote block is appended to the end of the application's entire element.
        //
        // The problem with that scenario is that Glimmer believes that it owns more of
        // the DOM than it actually does. The code is attempting to write past the end
        // of the Glimmer-managed root, but Glimmer isn't aware of that.
        //
        // The correct solution to that problem is for Glimmer to be aware of the end
        // of the bounds that it owns, and once we make that change, this check could
        // be removed.
        //
        // For now, a more targeted fix is to check whether the node was already removed
        // and avoid clearing the node if it was. In most cases this shouldn't happen,
        // so this might hide bugs where the code clears nested nodes unnecessarily,
        // so we should eventually try to do the correct fix.
        if (_this.parentElement() === _this.firstNode().parentNode) {
          clear(_assertThisInitialized(_this));
        }
      });
      return _this;
    }

    return RemoteLiveBlock;
  }(SimpleLiveBlock);
  var UpdatableBlockImpl = /*#__PURE__*/function (_SimpleLiveBlock2) {
    _inheritsLoose$1(UpdatableBlockImpl, _SimpleLiveBlock2);

    function UpdatableBlockImpl() {
      return _SimpleLiveBlock2.apply(this, arguments) || this;
    }

    var _proto6 = UpdatableBlockImpl.prototype;

    _proto6.reset = function reset() {
      destroyable.destroy(this);
      var nextSibling = clear(this);
      this.first = null;
      this.last = null;
      this.nesting = 0;
      return nextSibling;
    };

    return UpdatableBlockImpl;
  }(SimpleLiveBlock); // FIXME: All the noops in here indicate a modelling problem

  var LiveBlockList = /*#__PURE__*/function () {
    function LiveBlockList(parent, boundList) {
      this.parent = parent;
      this.boundList = boundList;
      this.parent = parent;
      this.boundList = boundList;
    }

    var _proto7 = LiveBlockList.prototype;

    _proto7.parentElement = function parentElement() {
      return this.parent;
    };

    _proto7.firstNode = function firstNode() {
      var head = this.boundList[0];
      return head.firstNode();
    };

    _proto7.lastNode = function lastNode() {
      var boundList = this.boundList;
      var tail = boundList[boundList.length - 1];
      return tail.lastNode();
    };

    _proto7.openElement = function openElement(_element) {
    };

    _proto7.closeElement = function closeElement() {
    };

    _proto7.didAppendNode = function didAppendNode(_node) {
    };

    _proto7.didAppendBounds = function didAppendBounds(_bounds) {};

    _proto7.finalize = function finalize(_stack) {
    };

    return LiveBlockList;
  }();
  function clientBuilder(env, cursor) {
    return NewElementBuilder.forInitialRender(env, cursor);
  }

  var AppendOpcodes = /*#__PURE__*/function () {
    function AppendOpcodes() {
      this.evaluateOpcode = util.fillNulls(104
      /* Size */
      ).slice();
    }

    var _proto = AppendOpcodes.prototype;

    _proto.add = function add(name, evaluate, kind) {
      if (kind === void 0) {
        kind = 'syscall';
      }

      this.evaluateOpcode[name] = {
        syscall: kind !== 'machine',
        evaluate: evaluate
      };
    };

    _proto.debugBefore = function debugBefore(vm$1, opcode) {
      var params = undefined;
      var opName = undefined;

      var sp;

      return {
        sp: sp,
        pc: vm$1.fetchValue(vm.$pc),
        name: opName,
        params: params,
        type: opcode.type,
        isMachine: opcode.isMachine,
        size: opcode.size,
        state: undefined
      };
    };

    _proto.debugAfter = function debugAfter(vm$1, pre) {
      var sp = pre.sp,
          type = pre.type,
          isMachine = pre.isMachine,
          pc = pre.pc;
    };

    _proto.evaluate = function evaluate(vm, opcode, type) {
      var operation = this.evaluateOpcode[type];

      if (operation.syscall) {
        operation.evaluate(vm, opcode);
      } else {
        operation.evaluate(vm[INNER_VM], opcode);
      }
    };

    return AppendOpcodes;
  }();
  var APPEND_OPCODES = new AppendOpcodes();

  function createConcatRef(partsRefs) {
    return reference.createComputeRef(function () {
      var parts = new Array();

      for (var i = 0; i < partsRefs.length; i++) {
        var value = reference.valueForRef(partsRefs[i]);

        if (value !== null && value !== undefined) {
          parts[i] = castToString(value);
        }
      }

      if (parts.length > 0) {
        return parts.join('');
      }

      return null;
    });
  }

  function castToString(value) {
    if (typeof value.toString !== 'function') {
      return '';
    }

    return String(value);
  }

  var TYPE = util.symbol('TYPE');
  var INNER = util.symbol('INNER');
  var OWNER = util.symbol('OWNER');
  var ARGS$1 = util.symbol('ARGS');
  var RESOLVED = util.symbol('RESOLVED');
  var CURRIED_VALUES = new util._WeakSet();
  function isCurriedValue(value) {
    return CURRIED_VALUES.has(value);
  }
  function isCurriedType(value, type) {
    return isCurriedValue(value) && value[TYPE] === type;
  }
  var CurriedValue =
  /** @internal */
  function CurriedValue(type, inner, owner, args, resolved) {
    if (resolved === void 0) {
      resolved = false;
    }

    CURRIED_VALUES.add(this);
    this[TYPE] = type;
    this[INNER] = inner;
    this[OWNER] = owner;
    this[ARGS$1] = args;
    this[RESOLVED] = resolved;
  };
  function resolveCurriedValue(curriedValue) {
    var currentWrapper = curriedValue;
    var positional;
    var named;
    var definition, owner, resolved;

    while (true) {
      var _currentWrapper = currentWrapper,
          curriedArgs = _currentWrapper[ARGS$1],
          inner = _currentWrapper[INNER];

      if (curriedArgs !== null) {
        var curriedNamed = curriedArgs.named,
            curriedPositional = curriedArgs.positional;

        if (curriedPositional.length > 0) {
          positional = positional === undefined ? curriedPositional : curriedPositional.concat(positional);
        }

        if (named === undefined) {
          named = [];
        }

        named.unshift(curriedNamed);
      }

      if (!isCurriedValue(inner)) {
        // Save off the owner that this helper was curried with. Later on,
        // we'll fetch the value of this register and set it as the owner on the
        // new root scope.
        definition = inner;
        owner = currentWrapper[OWNER];
        resolved = currentWrapper[RESOLVED];
        break;
      }

      currentWrapper = inner;
    }

    return {
      definition: definition,
      owner: owner,
      resolved: resolved,
      positional: positional,
      named: named
    };
  }
  function curry(type, spec, owner, args, resolved) {
    if (resolved === void 0) {
      resolved = false;
    }

    return new CurriedValue(type, spec, owner, args, resolved);
  }

  function createCurryRef(type, inner, owner, args, resolver, isStrict) {
    var lastValue, curriedDefinition;
    return reference.createComputeRef(function () {
      var value = reference.valueForRef(inner);

      if (value === lastValue) {
        return curriedDefinition;
      }

      if (isCurriedType(value, type)) {
        curriedDefinition = args ? curry(type, value, owner, args) : args;
      } else if (type === 0
      /* Component */
      && typeof value === 'string' && value) {
        // Only components should enter this path, as helpers and modifiers do not
        // support string based resolution
        if (env.DEBUG) {
          if (isStrict) {
            throw new Error("Attempted to resolve a dynamic component with a string definition, `" + value + "` in a strict mode template. In strict mode, using strings to resolve component definitions is prohibited. You can instead import the component definition and use it directly.");
          }

          var resolvedDefinition = resolver.lookupComponent(value, owner);

          if (!resolvedDefinition) {
            throw new Error("Attempted to resolve `" + value + "`, which was expected to be a component, but nothing was found.");
          }
        }

        curriedDefinition = curry(type, value, owner, args);
      } else if (util.isObject(value)) {
        curriedDefinition = curry(type, value, owner, args);
      } else {
        curriedDefinition = null;
      }

      lastValue = value;
      return curriedDefinition;
    });
  }

  function _defineProperties$1(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$1(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$1(Constructor.prototype, protoProps); if (staticProps) _defineProperties$1(Constructor, staticProps); return Constructor; }
  /*
    The calling convention is:

    * 0-N block arguments at the bottom
    * 0-N positional arguments next (left-to-right)
    * 0-N named arguments next
  */

  var VMArgumentsImpl = /*#__PURE__*/function () {
    function VMArgumentsImpl() {
      this.stack = null;
      this.positional = new PositionalArgumentsImpl();
      this.named = new NamedArgumentsImpl();
      this.blocks = new BlockArgumentsImpl();
    }

    var _proto = VMArgumentsImpl.prototype;

    _proto.empty = function empty(stack) {
      var base = stack[REGISTERS][vm.$sp] + 1;
      this.named.empty(stack, base);
      this.positional.empty(stack, base);
      this.blocks.empty(stack, base);
      return this;
    };

    _proto.setup = function setup(stack, names, blockNames, positionalCount, atNames) {
      this.stack = stack;
      /*
             | ... | blocks      | positional  | named |
             | ... | b0    b1    | p0 p1 p2 p3 | n0 n1 |
       index | ... | 4/5/6 7/8/9 | 10 11 12 13 | 14 15 |
                     ^             ^             ^  ^
                   bbase         pbase       nbase  sp
      */

      var named = this.named;
      var namedCount = names.length;
      var namedBase = stack[REGISTERS][vm.$sp] - namedCount + 1;
      named.setup(stack, namedBase, namedCount, names, atNames);
      var positional = this.positional;
      var positionalBase = namedBase - positionalCount;
      positional.setup(stack, positionalBase, positionalCount);
      var blocks = this.blocks;
      var blocksCount = blockNames.length;
      var blocksBase = positionalBase - blocksCount * 3;
      blocks.setup(stack, blocksBase, blocksCount, blockNames);
    };

    _proto.at = function at(pos) {
      return this.positional.at(pos);
    };

    _proto.realloc = function realloc(offset) {
      var stack = this.stack;

      if (offset > 0 && stack !== null) {
        var positional = this.positional,
            named = this.named;
        var newBase = positional.base + offset;
        var length = positional.length + named.length;

        for (var i = length - 1; i >= 0; i--) {
          stack.copy(i + positional.base, i + newBase);
        }

        positional.base += offset;
        named.base += offset;
        stack[REGISTERS][vm.$sp] += offset;
      }
    };

    _proto.capture = function capture() {
      var positional = this.positional.length === 0 ? EMPTY_POSITIONAL : this.positional.capture();
      var named = this.named.length === 0 ? EMPTY_NAMED : this.named.capture();
      return {
        named: named,
        positional: positional
      };
    };

    _proto.clear = function clear() {
      var stack = this.stack,
          length = this.length;
      if (length > 0 && stack !== null) stack.pop(length);
    };

    _createClass$1(VMArgumentsImpl, [{
      key: "base",
      get: function get() {
        return this.blocks.base;
      }
    }, {
      key: "length",
      get: function get() {
        return this.positional.length + this.named.length + this.blocks.length * 3;
      }
    }]);

    return VMArgumentsImpl;
  }();
  var EMPTY_REFERENCES = util.emptyArray();
  var PositionalArgumentsImpl = /*#__PURE__*/function () {
    function PositionalArgumentsImpl() {
      this.base = 0;
      this.length = 0;
      this.stack = null;
      this._references = null;
    }

    var _proto2 = PositionalArgumentsImpl.prototype;

    _proto2.empty = function empty(stack, base) {
      this.stack = stack;
      this.base = base;
      this.length = 0;
      this._references = EMPTY_REFERENCES;
    };

    _proto2.setup = function setup(stack, base, length) {
      this.stack = stack;
      this.base = base;
      this.length = length;

      if (length === 0) {
        this._references = EMPTY_REFERENCES;
      } else {
        this._references = null;
      }
    };

    _proto2.at = function at(position) {
      var base = this.base,
          length = this.length,
          stack = this.stack;

      if (position < 0 || position >= length) {
        return reference.UNDEFINED_REFERENCE;
      }

      return stack.get(position, base);
    };

    _proto2.capture = function capture() {
      return this.references;
    };

    _proto2.prepend = function prepend(other) {
      var additions = other.length;

      if (additions > 0) {
        var base = this.base,
            length = this.length,
            stack = this.stack;
        this.base = base = base - additions;
        this.length = length + additions;

        for (var i = 0; i < additions; i++) {
          stack.set(other[i], i, base);
        }

        this._references = null;
      }
    };

    _createClass$1(PositionalArgumentsImpl, [{
      key: "references",
      get: function get() {
        var references = this._references;

        if (!references) {
          var stack = this.stack,
              base = this.base,
              length = this.length;
          references = this._references = stack.slice(base, base + length);
        }

        return references;
      }
    }]);

    return PositionalArgumentsImpl;
  }();
  var NamedArgumentsImpl = /*#__PURE__*/function () {
    function NamedArgumentsImpl() {
      this.base = 0;
      this.length = 0;
      this._references = null;
      this._names = util.EMPTY_STRING_ARRAY;
      this._atNames = util.EMPTY_STRING_ARRAY;
    }

    var _proto3 = NamedArgumentsImpl.prototype;

    _proto3.empty = function empty(stack, base) {
      this.stack = stack;
      this.base = base;
      this.length = 0;
      this._references = EMPTY_REFERENCES;
      this._names = util.EMPTY_STRING_ARRAY;
      this._atNames = util.EMPTY_STRING_ARRAY;
    };

    _proto3.setup = function setup(stack, base, length, names, atNames) {
      this.stack = stack;
      this.base = base;
      this.length = length;

      if (length === 0) {
        this._references = EMPTY_REFERENCES;
        this._names = util.EMPTY_STRING_ARRAY;
        this._atNames = util.EMPTY_STRING_ARRAY;
      } else {
        this._references = null;

        if (atNames) {
          this._names = null;
          this._atNames = names;
        } else {
          this._names = names;
          this._atNames = null;
        }
      }
    };

    _proto3.has = function has(name) {
      return this.names.indexOf(name) !== -1;
    };

    _proto3.get = function get(name, atNames) {
      if (atNames === void 0) {
        atNames = false;
      }

      var base = this.base,
          stack = this.stack;
      var names = atNames ? this.atNames : this.names;
      var idx = names.indexOf(name);

      if (idx === -1) {
        return reference.UNDEFINED_REFERENCE;
      }

      var ref = stack.get(idx, base);

      if (env.DEBUG) {
        return reference.createDebugAliasRef(atNames ? name : "@" + name, ref);
      } else {
        return ref;
      }
    };

    _proto3.capture = function capture() {
      var names = this.names,
          references = this.references;
      var map = util.dict();

      for (var i = 0; i < names.length; i++) {
        var name = names[i];

        if (env.DEBUG) {
          map[name] = reference.createDebugAliasRef("@" + name, references[i]);
        } else {
          map[name] = references[i];
        }
      }

      return map;
    };

    _proto3.merge = function merge(other) {
      var keys = Object.keys(other);

      if (keys.length > 0) {
        var names = this.names,
            length = this.length,
            stack = this.stack;
        var newNames = names.slice();

        for (var i = 0; i < keys.length; i++) {
          var name = keys[i];
          var idx = newNames.indexOf(name);

          if (idx === -1) {
            length = newNames.push(name);
            stack.push(other[name]);
          }
        }

        this.length = length;
        this._references = null;
        this._names = newNames;
        this._atNames = null;
      }
    };

    _proto3.toSyntheticName = function toSyntheticName(name) {
      return name.slice(1);
    };

    _proto3.toAtName = function toAtName(name) {
      return "@" + name;
    };

    _createClass$1(NamedArgumentsImpl, [{
      key: "names",
      get: function get() {
        var names = this._names;

        if (!names) {
          names = this._names = this._atNames.map(this.toSyntheticName);
        }

        return names;
      }
    }, {
      key: "atNames",
      get: function get() {
        var atNames = this._atNames;

        if (!atNames) {
          atNames = this._atNames = this._names.map(this.toAtName);
        }

        return atNames;
      }
    }, {
      key: "references",
      get: function get() {
        var references = this._references;

        if (!references) {
          var base = this.base,
              length = this.length,
              stack = this.stack;
          references = this._references = stack.slice(base, base + length);
        }

        return references;
      }
    }]);

    return NamedArgumentsImpl;
  }();

  function toSymbolName(name) {
    return "&" + name;
  }

  var EMPTY_BLOCK_VALUES = util.emptyArray();
  var BlockArgumentsImpl = /*#__PURE__*/function () {
    function BlockArgumentsImpl() {
      this.internalValues = null;
      this._symbolNames = null;
      this.internalTag = null;
      this.names = util.EMPTY_STRING_ARRAY;
      this.length = 0;
      this.base = 0;
    }

    var _proto4 = BlockArgumentsImpl.prototype;

    _proto4.empty = function empty(stack, base) {
      this.stack = stack;
      this.names = util.EMPTY_STRING_ARRAY;
      this.base = base;
      this.length = 0;
      this._symbolNames = null;
      this.internalTag = validator.CONSTANT_TAG;
      this.internalValues = EMPTY_BLOCK_VALUES;
    };

    _proto4.setup = function setup(stack, base, length, names) {
      this.stack = stack;
      this.names = names;
      this.base = base;
      this.length = length;
      this._symbolNames = null;

      if (length === 0) {
        this.internalTag = validator.CONSTANT_TAG;
        this.internalValues = EMPTY_BLOCK_VALUES;
      } else {
        this.internalTag = null;
        this.internalValues = null;
      }
    };

    _proto4.has = function has(name) {
      return this.names.indexOf(name) !== -1;
    };

    _proto4.get = function get(name) {
      var idx = this.names.indexOf(name);

      if (idx === -1) {
        return null;
      }

      var base = this.base,
          stack = this.stack;
      var table = stack.get(idx * 3, base);
      var scope = stack.get(idx * 3 + 1, base);
      var handle = stack.get(idx * 3 + 2, base);
      return handle === null ? null : [handle, scope, table];
    };

    _proto4.capture = function capture() {
      return new CapturedBlockArgumentsImpl(this.names, this.values);
    };

    _createClass$1(BlockArgumentsImpl, [{
      key: "values",
      get: function get() {
        var values = this.internalValues;

        if (!values) {
          var base = this.base,
              length = this.length,
              stack = this.stack;
          values = this.internalValues = stack.slice(base, base + length * 3);
        }

        return values;
      }
    }, {
      key: "symbolNames",
      get: function get() {
        var symbolNames = this._symbolNames;

        if (symbolNames === null) {
          symbolNames = this._symbolNames = this.names.map(toSymbolName);
        }

        return symbolNames;
      }
    }]);

    return BlockArgumentsImpl;
  }();

  var CapturedBlockArgumentsImpl = /*#__PURE__*/function () {
    function CapturedBlockArgumentsImpl(names, values) {
      this.names = names;
      this.values = values;
      this.length = names.length;
    }

    var _proto5 = CapturedBlockArgumentsImpl.prototype;

    _proto5.has = function has(name) {
      return this.names.indexOf(name) !== -1;
    };

    _proto5.get = function get(name) {
      var idx = this.names.indexOf(name);
      if (idx === -1) return null;
      return [this.values[idx * 3 + 2], this.values[idx * 3 + 1], this.values[idx * 3]];
    };

    return CapturedBlockArgumentsImpl;
  }();

  function createCapturedArgs(named, positional) {
    return {
      named: named,
      positional: positional
    };
  }
  function reifyNamed(named) {
    var reified = util.dict();

    for (var key in named) {
      reified[key] = reference.valueForRef(named[key]);
    }

    return reified;
  }
  function reifyPositional(positional) {
    return positional.map(reference.valueForRef);
  }
  function reifyArgs(args) {
    return {
      named: reifyNamed(args.named),
      positional: reifyPositional(args.positional)
    };
  }
  var EMPTY_NAMED = Object.freeze(Object.create(null));
  var EMPTY_POSITIONAL = EMPTY_REFERENCES;
  var EMPTY_ARGS = createCapturedArgs(EMPTY_NAMED, EMPTY_POSITIONAL);

  APPEND_OPCODES.add(77
  /* Curry */
  , function (vm$1, _ref) {
    var type = _ref.op1,
        _isStrict = _ref.op2;
    var stack = vm$1.stack;
    var definition = stack.pop();
    var capturedArgs = stack.pop();
    var owner = vm$1.getOwner();
    var resolver = vm$1.runtime.resolver;
    var isStrict = false;

    if (env.DEBUG) {
      // strict check only happens in DEBUG builds, no reason to load it otherwise
      isStrict = vm$1[CONSTANTS].getValue(util.decodeHandle(_isStrict));
    }

    vm$1.loadValue(vm.$v0, createCurryRef(type, definition, owner, capturedArgs, resolver, isStrict));
  });
  APPEND_OPCODES.add(107
  /* DynamicHelper */
  , function (vm$1) {
    var stack = vm$1.stack;
    var ref = stack.pop();
    var args = stack.pop().capture();
    var helperRef;
    var initialOwner = vm$1.getOwner();
    var helperInstanceRef = reference.createComputeRef(function () {
      if (helperRef !== undefined) {
        destroyable.destroy(helperRef);
      }

      var definition = reference.valueForRef(ref);

      if (isCurriedType(definition, 1
      /* Helper */
      )) {
        var _resolveCurriedValue = resolveCurriedValue(definition),
            resolvedDef = _resolveCurriedValue.definition,
            owner = _resolveCurriedValue.owner,
            positional = _resolveCurriedValue.positional,
            named = _resolveCurriedValue.named;

        var helper = resolveHelper(vm$1[CONSTANTS], resolvedDef, ref);

        if (named !== undefined) {
          args.named = util.assign.apply(void 0, [{}].concat(named, [args.named]));
        }

        if (positional !== undefined) {
          args.positional = positional.concat(args.positional);
        }

        helperRef = helper(args, owner);
        destroyable.associateDestroyableChild(helperInstanceRef, helperRef);
      } else if (util.isObject(definition)) {
        var _helper = resolveHelper(vm$1[CONSTANTS], definition, ref);

        helperRef = _helper(args, initialOwner);

        if (destroyable._hasDestroyableChildren(helperRef)) {
          destroyable.associateDestroyableChild(helperInstanceRef, helperRef);
        }
      } else {
        helperRef = reference.UNDEFINED_REFERENCE;
      }
    });
    var helperValueRef = reference.createComputeRef(function () {
      reference.valueForRef(helperInstanceRef);
      return reference.valueForRef(helperRef);
    });
    vm$1.associateDestroyable(helperInstanceRef);
    vm$1.loadValue(vm.$v0, helperValueRef);
  });

  function resolveHelper(constants, definition, ref) {
    var handle = constants.helper(definition, null, true);

    if (env.DEBUG && handle === null) {
      throw new Error("Expected a dynamic helper definition, but received an object or function that did not have a helper manager associated with it. The dynamic invocation was `{{" + ref.debugLabel + "}}` or `(" + ref.debugLabel + ")`, and the incorrect definition is the value at the path `" + ref.debugLabel + "`, which was: " + util.debugToString(definition));
    }

    return constants.getValue(handle);
  }

  APPEND_OPCODES.add(16
  /* Helper */
  , function (vm$1, _ref2) {
    var handle = _ref2.op1;
    var stack = vm$1.stack;
    var helper = vm$1[CONSTANTS].getValue(handle);
    var args = stack.pop();
    var value = helper(args.capture(), vm$1.getOwner(), vm$1.dynamicScope());

    if (destroyable._hasDestroyableChildren(value)) {
      vm$1.associateDestroyable(value);
    }

    vm$1.loadValue(vm.$v0, value);
  });
  APPEND_OPCODES.add(21
  /* GetVariable */
  , function (vm, _ref3) {
    var symbol = _ref3.op1;
    var expr = vm.referenceForSymbol(symbol);
    vm.stack.push(expr);
  });
  APPEND_OPCODES.add(19
  /* SetVariable */
  , function (vm, _ref4) {
    var symbol = _ref4.op1;
    var expr = vm.stack.pop();
    vm.scope().bindSymbol(symbol, expr);
  });
  APPEND_OPCODES.add(20
  /* SetBlock */
  , function (vm, _ref5) {
    var symbol = _ref5.op1;
    var handle = vm.stack.pop();
    var scope = vm.stack.pop();
    var table = vm.stack.pop();
    vm.scope().bindBlock(symbol, [handle, scope, table]);
  });
  APPEND_OPCODES.add(102
  /* ResolveMaybeLocal */
  , function (vm, _ref6) {
    var _name = _ref6.op1;
    var name = vm[CONSTANTS].getValue(_name);
    var locals = vm.scope().getPartialMap();
    var ref = locals[name];

    if (ref === undefined) {
      ref = reference.childRefFor(vm.getSelf(), name);
    }

    vm.stack.push(ref);
  });
  APPEND_OPCODES.add(37
  /* RootScope */
  , function (vm, _ref7) {
    var symbols = _ref7.op1;
    vm.pushRootScope(symbols, vm.getOwner());
  });
  APPEND_OPCODES.add(22
  /* GetProperty */
  , function (vm, _ref8) {
    var _key = _ref8.op1;
    var key = vm[CONSTANTS].getValue(_key);
    var expr = vm.stack.pop();
    vm.stack.push(reference.childRefFor(expr, key));
  });
  APPEND_OPCODES.add(23
  /* GetBlock */
  , function (vm, _ref9) {
    var _block = _ref9.op1;
    var stack = vm.stack;
    var block = vm.scope().getBlock(_block);
    stack.push(block);
  });
  APPEND_OPCODES.add(24
  /* SpreadBlock */
  , function (vm) {
    var stack = vm.stack;
    var block = stack.pop();

    if (block && !isUndefinedReference(block)) {
      var handleOrCompilable = block[0],
          scope = block[1],
          table = block[2];
      stack.push(table);
      stack.push(scope);
      stack.push(handleOrCompilable);
    } else {
      stack.push(null);
      stack.push(null);
      stack.push(null);
    }
  });

  function isUndefinedReference(input) {
    return input === reference.UNDEFINED_REFERENCE;
  }

  APPEND_OPCODES.add(25
  /* HasBlock */
  , function (vm) {
    var stack = vm.stack;
    var block = stack.pop();

    if (block && !isUndefinedReference(block)) {
      stack.push(reference.TRUE_REFERENCE);
    } else {
      stack.push(reference.FALSE_REFERENCE);
    }
  });
  APPEND_OPCODES.add(26
  /* HasBlockParams */
  , function (vm) {
    // FIXME(mmun): should only need to push the symbol table
    var block = vm.stack.pop();
    var scope = vm.stack.pop();
    var table = vm.stack.pop();
    var hasBlockParams = table && table.parameters.length;
    vm.stack.push(hasBlockParams ? reference.TRUE_REFERENCE : reference.FALSE_REFERENCE);
  });
  APPEND_OPCODES.add(27
  /* Concat */
  , function (vm, _ref10) {
    var count = _ref10.op1;
    var out = new Array(count);

    for (var i = count; i > 0; i--) {
      var offset = i - 1;
      out[offset] = vm.stack.pop();
    }

    vm.stack.push(createConcatRef(out));
  });
  APPEND_OPCODES.add(109
  /* IfInline */
  , function (vm) {
    var condition = vm.stack.pop();
    var truthy = vm.stack.pop();
    var falsy = vm.stack.pop();
    vm.stack.push(reference.createComputeRef(function () {
      if (globalContext.toBool(reference.valueForRef(condition)) === true) {
        return reference.valueForRef(truthy);
      } else {
        return reference.valueForRef(falsy);
      }
    }));
  });
  APPEND_OPCODES.add(110
  /* Not */
  , function (vm) {
    var ref = vm.stack.pop();
    vm.stack.push(reference.createComputeRef(function () {
      return !globalContext.toBool(reference.valueForRef(ref));
    }));
  });
  APPEND_OPCODES.add(111
  /* GetDynamicVar */
  , function (vm) {
    var scope = vm.dynamicScope();
    var stack = vm.stack;
    var nameRef = stack.pop();
    stack.push(reference.createComputeRef(function () {
      var name = String(reference.valueForRef(nameRef));
      return reference.valueForRef(scope.get(name));
    }));
  });
  APPEND_OPCODES.add(112
  /* Log */
  , function (vm$1) {
    var _vm$stack$pop$capture = vm$1.stack.pop().capture(),
        positional = _vm$stack$pop$capture.positional;

    vm$1.loadValue(vm.$v0, reference.createComputeRef(function () {
      var _console;

      // eslint-disable-next-line no-console
      (_console = console).log.apply(_console, reifyPositional(positional));
    }));
  });

  function resolveComponent(resolver, constants, name, owner) {
    var definition = resolver.lookupComponent(name, owner);

    if (env.DEBUG && !definition) {
      throw new Error("Attempted to resolve `" + name + "`, which was expected to be a component, but nothing was found.");
    }

    return constants.resolvedComponent(definition, name);
  }

  /** @internal */
  function hasCustomDebugRenderTreeLifecycle(manager) {
    return 'getDebugCustomRenderTree' in manager;
  }

  function createClassListRef(list) {
    return reference.createComputeRef(function () {
      var ret = [];

      for (var i = 0; i < list.length; i++) {
        var ref = list[i];
        var value = normalizeStringValue(typeof ref === 'string' ? ref : reference.valueForRef(list[i]));
        if (value) ret.push(value);
      }

      return ret.length === 0 ? null : ret.join(' ');
    });
  }

  APPEND_OPCODES.add(39
  /* ChildScope */
  , function (vm) {
    return vm.pushChildScope();
  });
  APPEND_OPCODES.add(40
  /* PopScope */
  , function (vm) {
    return vm.popScope();
  });
  APPEND_OPCODES.add(59
  /* PushDynamicScope */
  , function (vm) {
    return vm.pushDynamicScope();
  });
  APPEND_OPCODES.add(60
  /* PopDynamicScope */
  , function (vm) {
    return vm.popDynamicScope();
  });
  APPEND_OPCODES.add(28
  /* Constant */
  , function (vm, _ref) {
    var other = _ref.op1;
    vm.stack.push(vm[CONSTANTS].getValue(util.decodeHandle(other)));
  });
  APPEND_OPCODES.add(29
  /* ConstantReference */
  , function (vm, _ref2) {
    var other = _ref2.op1;
    vm.stack.push(reference.createConstRef(vm[CONSTANTS].getValue(util.decodeHandle(other)), false));
  });
  APPEND_OPCODES.add(30
  /* Primitive */
  , function (vm, _ref3) {
    var primitive = _ref3.op1;
    var stack = vm.stack;

    if (util.isHandle(primitive)) {
      // it is a handle which does not already exist on the stack
      var value = vm[CONSTANTS].getValue(util.decodeHandle(primitive));
      stack.push(value);
    } else {
      // is already an encoded immediate or primitive handle
      stack.push(util.decodeImmediate(primitive));
    }
  });
  APPEND_OPCODES.add(31
  /* PrimitiveReference */
  , function (vm) {
    var stack = vm.stack;
    var value = stack.pop();
    var ref;

    if (value === undefined) {
      ref = reference.UNDEFINED_REFERENCE;
    } else if (value === null) {
      ref = reference.NULL_REFERENCE;
    } else if (value === true) {
      ref = reference.TRUE_REFERENCE;
    } else if (value === false) {
      ref = reference.FALSE_REFERENCE;
    } else {
      ref = reference.createPrimitiveRef(value);
    }

    stack.push(ref);
  });
  APPEND_OPCODES.add(33
  /* Dup */
  , function (vm, _ref4) {
    var register = _ref4.op1,
        offset = _ref4.op2;
    var position = vm.fetchValue(register) - offset;
    vm.stack.dup(position);
  });
  APPEND_OPCODES.add(34
  /* Pop */
  , function (vm, _ref5) {
    var count = _ref5.op1;
    vm.stack.pop(count);
  });
  APPEND_OPCODES.add(35
  /* Load */
  , function (vm, _ref6) {
    var register = _ref6.op1;
    vm.load(register);
  });
  APPEND_OPCODES.add(36
  /* Fetch */
  , function (vm, _ref7) {
    var register = _ref7.op1;
    vm.fetch(register);
  });
  APPEND_OPCODES.add(58
  /* BindDynamicScope */
  , function (vm, _ref8) {
    var _names = _ref8.op1;
    var names = vm[CONSTANTS].getArray(_names);
    vm.bindDynamicScope(names);
  });
  APPEND_OPCODES.add(69
  /* Enter */
  , function (vm, _ref9) {
    var args = _ref9.op1;
    vm.enter(args);
  });
  APPEND_OPCODES.add(70
  /* Exit */
  , function (vm) {
    vm.exit();
  });
  APPEND_OPCODES.add(63
  /* PushSymbolTable */
  , function (vm, _ref10) {
    var _table = _ref10.op1;
    var stack = vm.stack;
    stack.push(vm[CONSTANTS].getValue(_table));
  });
  APPEND_OPCODES.add(62
  /* PushBlockScope */
  , function (vm) {
    var stack = vm.stack;
    stack.push(vm.scope());
  });
  APPEND_OPCODES.add(61
  /* CompileBlock */
  , function (vm) {
    var stack = vm.stack;
    var block = stack.pop();

    if (block) {
      stack.push(vm.compile(block));
    } else {
      stack.push(null);
    }
  });
  APPEND_OPCODES.add(64
  /* InvokeYield */
  , function (vm) {
    var stack = vm.stack;
    var handle = stack.pop();
    var scope = stack.pop();
    var table = stack.pop();
    var args = stack.pop();

    if (table === null) {
      // To balance the pop{Frame,Scope}
      vm.pushFrame();
      vm.pushScope(scope !== null && scope !== void 0 ? scope : vm.scope());
      return;
    }

    var invokingScope = scope; // If necessary, create a child scope

    {
      var locals = table.parameters;
      var localsCount = locals.length;

      if (localsCount > 0) {
        invokingScope = invokingScope.child();

        for (var i = 0; i < localsCount; i++) {
          invokingScope.bindSymbol(locals[i], args.at(i));
        }
      }
    }
    vm.pushFrame();
    vm.pushScope(invokingScope);
    vm.call(handle);
  });
  APPEND_OPCODES.add(65
  /* JumpIf */
  , function (vm, _ref11) {
    var target = _ref11.op1;
    var reference$1 = vm.stack.pop();
    var value = Boolean(reference.valueForRef(reference$1));

    if (reference.isConstRef(reference$1)) {
      if (value === true) {
        vm["goto"](target);
      }
    } else {
      if (value === true) {
        vm["goto"](target);
      }

      vm.updateWith(new Assert(reference$1));
    }
  });
  APPEND_OPCODES.add(66
  /* JumpUnless */
  , function (vm, _ref12) {
    var target = _ref12.op1;
    var reference$1 = vm.stack.pop();
    var value = Boolean(reference.valueForRef(reference$1));

    if (reference.isConstRef(reference$1)) {
      if (value === false) {
        vm["goto"](target);
      }
    } else {
      if (value === false) {
        vm["goto"](target);
      }

      vm.updateWith(new Assert(reference$1));
    }
  });
  APPEND_OPCODES.add(67
  /* JumpEq */
  , function (vm, _ref13) {
    var target = _ref13.op1,
        comparison = _ref13.op2;
    var other = vm.stack.peek();

    if (other === comparison) {
      vm["goto"](target);
    }
  });
  APPEND_OPCODES.add(68
  /* AssertSame */
  , function (vm) {
    var reference$1 = vm.stack.peek();

    if (reference.isConstRef(reference$1) === false) {
      vm.updateWith(new Assert(reference$1));
    }
  });
  APPEND_OPCODES.add(71
  /* ToBoolean */
  , function (vm) {
    var stack = vm.stack;
    var valueRef = stack.pop();
    stack.push(reference.createComputeRef(function () {
      return globalContext.toBool(reference.valueForRef(valueRef));
    }));
  });
  var Assert = /*#__PURE__*/function () {
    function Assert(ref) {
      this.ref = ref;
      this.last = reference.valueForRef(ref);
    }

    var _proto = Assert.prototype;

    _proto.evaluate = function evaluate(vm) {
      var last = this.last,
          ref = this.ref;
      var current = reference.valueForRef(ref);

      if (last !== current) {
        vm["throw"]();
      }
    };

    return Assert;
  }();
  var AssertFilter = /*#__PURE__*/function () {
    function AssertFilter(ref, filter) {
      this.ref = ref;
      this.filter = filter;
      this.last = filter(reference.valueForRef(ref));
    }

    var _proto2 = AssertFilter.prototype;

    _proto2.evaluate = function evaluate(vm) {
      var last = this.last,
          ref = this.ref,
          filter = this.filter;
      var current = filter(reference.valueForRef(ref));

      if (last !== current) {
        vm["throw"]();
      }
    };

    return AssertFilter;
  }();
  var JumpIfNotModifiedOpcode = /*#__PURE__*/function () {
    function JumpIfNotModifiedOpcode() {
      this.tag = validator.CONSTANT_TAG;
      this.lastRevision = validator.INITIAL;
    }

    var _proto3 = JumpIfNotModifiedOpcode.prototype;

    _proto3.finalize = function finalize(tag, target) {
      this.target = target;
      this.didModify(tag);
    };

    _proto3.evaluate = function evaluate(vm) {
      var tag = this.tag,
          target = this.target,
          lastRevision = this.lastRevision;

      if (!vm.alwaysRevalidate && validator.validateTag(tag, lastRevision)) {
        validator.consumeTag(tag);
        vm["goto"](target);
      }
    };

    _proto3.didModify = function didModify(tag) {
      this.tag = tag;
      this.lastRevision = validator.valueForTag(this.tag);
      validator.consumeTag(tag);
    };

    return JumpIfNotModifiedOpcode;
  }();
  var BeginTrackFrameOpcode = /*#__PURE__*/function () {
    function BeginTrackFrameOpcode(debugLabel) {
      this.debugLabel = debugLabel;
    }

    var _proto4 = BeginTrackFrameOpcode.prototype;

    _proto4.evaluate = function evaluate() {
      validator.beginTrackFrame(this.debugLabel);
    };

    return BeginTrackFrameOpcode;
  }();
  var EndTrackFrameOpcode = /*#__PURE__*/function () {
    function EndTrackFrameOpcode(target) {
      this.target = target;
    }

    var _proto5 = EndTrackFrameOpcode.prototype;

    _proto5.evaluate = function evaluate() {
      var tag = validator.endTrackFrame();
      this.target.didModify(tag);
    };

    return EndTrackFrameOpcode;
  }();

  APPEND_OPCODES.add(41
  /* Text */
  , function (vm, _ref) {
    var text = _ref.op1;
    vm.elements().appendText(vm[CONSTANTS].getValue(text));
  });
  APPEND_OPCODES.add(42
  /* Comment */
  , function (vm, _ref2) {
    var text = _ref2.op1;
    vm.elements().appendComment(vm[CONSTANTS].getValue(text));
  });
  APPEND_OPCODES.add(48
  /* OpenElement */
  , function (vm, _ref3) {
    var tag = _ref3.op1;
    vm.elements().openElement(vm[CONSTANTS].getValue(tag));
  });
  APPEND_OPCODES.add(49
  /* OpenDynamicElement */
  , function (vm) {
    var tagName = reference.valueForRef(vm.stack.pop());
    vm.elements().openElement(tagName);
  });
  APPEND_OPCODES.add(50
  /* PushRemoteElement */
  , function (vm) {
    var elementRef = vm.stack.pop();
    var insertBeforeRef = vm.stack.pop();
    var guidRef = vm.stack.pop();
    var element = reference.valueForRef(elementRef);
    var insertBefore = reference.valueForRef(insertBeforeRef);
    var guid = reference.valueForRef(guidRef);

    if (!reference.isConstRef(elementRef)) {
      vm.updateWith(new Assert(elementRef));
    }

    if (insertBefore !== undefined && !reference.isConstRef(insertBeforeRef)) {
      vm.updateWith(new Assert(insertBeforeRef));
    }

    var block = vm.elements().pushRemoteElement(element, guid, insertBefore);
    if (block) vm.associateDestroyable(block);
  });
  APPEND_OPCODES.add(56
  /* PopRemoteElement */
  , function (vm) {
    vm.elements().popRemoteElement();
  });
  APPEND_OPCODES.add(54
  /* FlushElement */
  , function (vm$1) {
    var operations = vm$1.fetchValue(vm.$t0);
    var modifiers = null;

    if (operations) {
      modifiers = operations.flush(vm$1);
      vm$1.loadValue(vm.$t0, null);
    }

    vm$1.elements().flushElement(modifiers);
  });
  APPEND_OPCODES.add(55
  /* CloseElement */
  , function (vm) {
    var modifiers = vm.elements().closeElement();

    if (modifiers) {
      modifiers.forEach(function (modifier) {
        vm.env.scheduleInstallModifier(modifier);
        var manager = modifier.manager,
            state = modifier.state;
        var d = manager.getDestroyable(state);

        if (d) {
          vm.associateDestroyable(d);
        }
      });
    }
  });
  APPEND_OPCODES.add(57
  /* Modifier */
  , function (vm$1, _ref4) {
    var handle = _ref4.op1;

    if (vm$1.env.isInteractive === false) {
      return;
    }

    var owner = vm$1.getOwner();
    var args = vm$1.stack.pop();
    var definition = vm$1[CONSTANTS].getValue(handle);
    var manager = definition.manager;

    var _vm$elements = vm$1.elements(),
        constructing = _vm$elements.constructing;

    var state = manager.create(owner, constructing, definition.state, args.capture());
    var instance = {
      manager: manager,
      state: state,
      definition: definition
    };
    var operations = vm$1.fetchValue(vm.$t0);
    operations.addModifier(instance);
    var tag = manager.getTag(state);

    if (tag !== null) {
      validator.consumeTag(tag);
      return vm$1.updateWith(new UpdateModifierOpcode(tag, instance));
    }
  });
  APPEND_OPCODES.add(108
  /* DynamicModifier */
  , function (vm$1) {
    if (vm$1.env.isInteractive === false) {
      return;
    }

    var stack = vm$1.stack,
        constants = vm$1[CONSTANTS];
    var ref = stack.pop();
    var args = stack.pop().capture();

    var _vm$elements2 = vm$1.elements(),
        constructing = _vm$elements2.constructing;

    var initialOwner = vm$1.getOwner();
    var instanceRef = reference.createComputeRef(function () {
      var value = reference.valueForRef(ref);
      var owner;

      if (!util.isObject(value)) {
        return;
      }

      var hostDefinition;

      if (isCurriedType(value, 2
      /* Modifier */
      )) {
        var _resolveCurriedValue = resolveCurriedValue(value),
            resolvedDefinition = _resolveCurriedValue.definition,
            curriedOwner = _resolveCurriedValue.owner,
            positional = _resolveCurriedValue.positional,
            named = _resolveCurriedValue.named;

        hostDefinition = resolvedDefinition;
        owner = curriedOwner;

        if (positional !== undefined) {
          args.positional = positional.concat(args.positional);
        }

        if (named !== undefined) {
          args.named = util.assign.apply(void 0, [{}].concat(named, [args.named]));
        }
      } else {
        hostDefinition = value;
        owner = initialOwner;
      }

      var handle = constants.modifier(hostDefinition, null, true);

      if (env.DEBUG && handle === null) {
        throw new Error("Expected a dynamic modifier definition, but received an object or function that did not have a modifier manager associated with it. The dynamic invocation was `{{" + ref.debugLabel + "}}`, and the incorrect definition is the value at the path `" + ref.debugLabel + "`, which was: " + util.debugToString(hostDefinition));
      }

      var definition = constants.getValue(handle);
      var manager = definition.manager;
      var state = manager.create(owner, constructing, definition.state, args);
      return {
        manager: manager,
        state: state,
        definition: definition
      };
    });
    var instance = reference.valueForRef(instanceRef);
    var tag = null;

    if (instance !== undefined) {
      var operations = vm$1.fetchValue(vm.$t0);
      operations.addModifier(instance);
      tag = instance.manager.getTag(instance.state);

      if (tag !== null) {
        validator.consumeTag(tag);
      }
    }

    if (!reference.isConstRef(ref) || tag) {
      return vm$1.updateWith(new UpdateDynamicModifierOpcode(tag, instance, instanceRef));
    }
  });
  var UpdateModifierOpcode = /*#__PURE__*/function () {
    function UpdateModifierOpcode(tag, modifier) {
      this.tag = tag;
      this.modifier = modifier;
      this.lastUpdated = validator.valueForTag(tag);
    }

    var _proto = UpdateModifierOpcode.prototype;

    _proto.evaluate = function evaluate(vm) {
      var modifier = this.modifier,
          tag = this.tag,
          lastUpdated = this.lastUpdated;
      validator.consumeTag(tag);

      if (!validator.validateTag(tag, lastUpdated)) {
        vm.env.scheduleUpdateModifier(modifier);
        this.lastUpdated = validator.valueForTag(tag);
      }
    };

    return UpdateModifierOpcode;
  }();
  var UpdateDynamicModifierOpcode = /*#__PURE__*/function () {
    function UpdateDynamicModifierOpcode(tag, instance, instanceRef) {
      this.tag = tag;
      this.instance = instance;
      this.instanceRef = instanceRef;
      this.lastUpdated = validator.valueForTag(tag !== null && tag !== void 0 ? tag : validator.CURRENT_TAG);
    }

    var _proto2 = UpdateDynamicModifierOpcode.prototype;

    _proto2.evaluate = function evaluate(vm) {
      var tag = this.tag,
          lastUpdated = this.lastUpdated,
          instance = this.instance,
          instanceRef = this.instanceRef;
      var newInstance = reference.valueForRef(instanceRef);

      if (newInstance !== instance) {
        if (instance !== undefined) {
          var destroyable$1 = instance.manager.getDestroyable(instance.state);

          if (destroyable$1 !== null) {
            destroyable.destroy(destroyable$1);
          }
        }

        if (newInstance !== undefined) {
          var manager = newInstance.manager,
              state = newInstance.state;

          var _destroyable = manager.getDestroyable(state);

          if (_destroyable !== null) {
            destroyable.associateDestroyableChild(this, _destroyable);
          }

          tag = manager.getTag(state);

          if (tag !== null) {
            this.lastUpdated = validator.valueForTag(tag);
          }

          this.tag = tag;
          vm.env.scheduleInstallModifier(newInstance);
        }

        this.instance = newInstance;
      } else if (tag !== null && !validator.validateTag(tag, lastUpdated)) {
        vm.env.scheduleUpdateModifier(instance);
        this.lastUpdated = validator.valueForTag(tag);
      }

      if (tag !== null) {
        validator.consumeTag(tag);
      }
    };

    return UpdateDynamicModifierOpcode;
  }();
  APPEND_OPCODES.add(51
  /* StaticAttr */
  , function (vm, _ref5) {
    var _name = _ref5.op1,
        _value = _ref5.op2,
        _namespace = _ref5.op3;
    var name = vm[CONSTANTS].getValue(_name);
    var value = vm[CONSTANTS].getValue(_value);
    var namespace = _namespace ? vm[CONSTANTS].getValue(_namespace) : null;
    vm.elements().setStaticAttribute(name, value, namespace);
  });
  APPEND_OPCODES.add(52
  /* DynamicAttr */
  , function (vm, _ref6) {
    var _name = _ref6.op1,
        _trusting = _ref6.op2,
        _namespace = _ref6.op3;
    var name = vm[CONSTANTS].getValue(_name);
    var trusting = vm[CONSTANTS].getValue(_trusting);
    var reference$1 = vm.stack.pop();
    var value = reference.valueForRef(reference$1);
    var namespace = _namespace ? vm[CONSTANTS].getValue(_namespace) : null;
    var attribute = vm.elements().setDynamicAttribute(name, value, trusting, namespace);

    if (!reference.isConstRef(reference$1)) {
      vm.updateWith(new UpdateDynamicAttributeOpcode(reference$1, attribute, vm.env));
    }
  });
  var UpdateDynamicAttributeOpcode = /*#__PURE__*/function () {
    function UpdateDynamicAttributeOpcode(reference$1, attribute, env) {
      var initialized = false;
      this.updateRef = reference.createComputeRef(function () {
        var value = reference.valueForRef(reference$1);

        if (initialized === true) {
          attribute.update(value, env);
        } else {
          initialized = true;
        }
      });
      reference.valueForRef(this.updateRef);
    }

    var _proto3 = UpdateDynamicAttributeOpcode.prototype;

    _proto3.evaluate = function evaluate() {
      reference.valueForRef(this.updateRef);
    };

    return UpdateDynamicAttributeOpcode;
  }();

  APPEND_OPCODES.add(78
  /* PushComponentDefinition */
  , function (vm, _ref) {
    var handle = _ref.op1;
    var definition = vm[CONSTANTS].getValue(handle);
    var manager = definition.manager,
        capabilities = definition.capabilities;
    var instance = {
      definition: definition,
      manager: manager,
      capabilities: capabilities,
      state: null,
      handle: null,
      table: null,
      lookup: null
    };
    vm.stack.push(instance);
  });
  APPEND_OPCODES.add(80
  /* ResolveDynamicComponent */
  , function (vm$1, _ref2) {
    var _isStrict = _ref2.op1;
    var stack = vm$1.stack;
    var component = reference.valueForRef(stack.pop());
    var constants = vm$1[CONSTANTS];
    var owner = vm$1.getOwner();
    var isStrict = constants.getValue(_isStrict);
    vm$1.loadValue(vm.$t1, null); // Clear the temp register

    var definition;

    if (typeof component === 'string') {
      if (env.DEBUG && isStrict) {
        throw new Error("Attempted to resolve a dynamic component with a string definition, `" + component + "` in a strict mode template. In strict mode, using strings to resolve component definitions is prohibited. You can instead import the component definition and use it directly.");
      }

      var resolvedDefinition = resolveComponent(vm$1.runtime.resolver, constants, component, owner);
      definition = resolvedDefinition;
    } else if (isCurriedValue(component)) {
      definition = component;
    } else {
      definition = constants.component(component, owner);
    }

    stack.push(definition);
  });
  APPEND_OPCODES.add(81
  /* ResolveCurriedComponent */
  , function (vm) {
    var stack = vm.stack;
    var ref = stack.pop();
    var value = reference.valueForRef(ref);
    var constants = vm[CONSTANTS];
    var definition;

    if (env.DEBUG && !(typeof value === 'function' || typeof value === 'object' && value !== null)) {
      throw new Error("Expected a component definition, but received " + value + ". You may have accidentally done <" + ref.debugLabel + ">, where \"" + ref.debugLabel + "\" was a string instead of a curried component definition. You must either use the component definition directly, or use the {{component}} helper to create a curried component definition when invoking dynamically.");
    }

    if (isCurriedValue(value)) {
      definition = value;
    } else {
      definition = constants.component(value, vm.getOwner(), true);

      if (env.DEBUG && definition === null) {
        throw new Error("Expected a dynamic component definition, but received an object or function that did not have a component manager associated with it. The dynamic invocation was `<" + ref.debugLabel + ">` or `{{" + ref.debugLabel + "}}`, and the incorrect definition is the value at the path `" + ref.debugLabel + "`, which was: " + util.debugToString(value));
      }
    }

    stack.push(definition);
  });
  APPEND_OPCODES.add(79
  /* PushDynamicComponentInstance */
  , function (vm) {
    var stack = vm.stack;
    var definition = stack.pop();
    var capabilities, manager;

    if (isCurriedValue(definition)) {
      manager = capabilities = null;
    } else {
      manager = definition.manager;
      capabilities = definition.capabilities;
    }

    stack.push({
      definition: definition,
      capabilities: capabilities,
      manager: manager,
      state: null,
      handle: null,
      table: null
    });
  });
  APPEND_OPCODES.add(82
  /* PushArgs */
  , function (vm, _ref3) {
    var _names = _ref3.op1,
        _blockNames = _ref3.op2,
        flags = _ref3.op3;
    var stack = vm.stack;
    var names = vm[CONSTANTS].getArray(_names);
    var positionalCount = flags >> 4;
    var atNames = flags & 8;
    var blockNames = flags & 7 ? vm[CONSTANTS].getArray(_blockNames) : util.EMPTY_STRING_ARRAY;
    vm[ARGS].setup(stack, names, blockNames, positionalCount, !!atNames);
    stack.push(vm[ARGS]);
  });
  APPEND_OPCODES.add(83
  /* PushEmptyArgs */
  , function (vm) {
    var stack = vm.stack;
    stack.push(vm[ARGS].empty(stack));
  });
  APPEND_OPCODES.add(86
  /* CaptureArgs */
  , function (vm) {
    var stack = vm.stack;
    var args = stack.pop();
    var capturedArgs = args.capture();
    stack.push(capturedArgs);
  });
  APPEND_OPCODES.add(85
  /* PrepareArgs */
  , function (vm$1, _ref4) {
    var _state = _ref4.op1;
    var stack = vm$1.stack;
    var instance = vm$1.fetchValue(_state);
    var args = stack.pop();
    var definition = instance.definition;

    if (isCurriedType(definition, 0
    /* Component */
    )) {
      var constants = vm$1[CONSTANTS];

      var _resolveCurriedValue = resolveCurriedValue(definition),
          resolvedDefinition = _resolveCurriedValue.definition,
          owner = _resolveCurriedValue.owner,
          resolved = _resolveCurriedValue.resolved,
          positional = _resolveCurriedValue.positional,
          named = _resolveCurriedValue.named;

      if (resolved === true) {
        definition = resolvedDefinition;
      } else if (typeof resolvedDefinition === 'string') {
        var resolvedValue = vm$1.runtime.resolver.lookupComponent(resolvedDefinition, owner);
        definition = constants.resolvedComponent(resolvedValue, resolvedDefinition);
      } else {
        definition = constants.component(resolvedDefinition, owner);
      }

      if (named !== undefined) {
        args.named.merge(util.assign.apply(void 0, [{}].concat(named)));
      }

      if (positional !== undefined) {
        args.realloc(positional.length);
        args.positional.prepend(positional);
      }

      var _definition = definition,
          _manager = _definition.manager;
      instance.definition = definition;
      instance.manager = _manager;
      instance.capabilities = definition.capabilities; // Save off the owner that this component was curried with. Later on,
      // we'll fetch the value of this register and set it as the owner on the
      // new root scope.

      vm$1.loadValue(vm.$t1, owner);
    }

    var _definition2 = definition,
        manager$1 = _definition2.manager,
        state = _definition2.state;
    var capabilities = instance.capabilities;

    if (!manager.managerHasCapability(manager$1, capabilities, 4
    /* PrepareArgs */
    )) {
      stack.push(args);
      return;
    }

    var blocks = args.blocks.values;
    var blockNames = args.blocks.names;
    var preparedArgs = manager$1.prepareArgs(state, args);

    if (preparedArgs) {
      args.clear();

      for (var i = 0; i < blocks.length; i++) {
        stack.push(blocks[i]);
      }

      var _positional = preparedArgs.positional,
          _named = preparedArgs.named;
      var positionalCount = _positional.length;

      for (var _i = 0; _i < positionalCount; _i++) {
        stack.push(_positional[_i]);
      }

      var names = Object.keys(_named);

      for (var _i2 = 0; _i2 < names.length; _i2++) {
        stack.push(_named[names[_i2]]);
      }

      args.setup(stack, names, blockNames, positionalCount, false);
    }

    stack.push(args);
  });
  APPEND_OPCODES.add(87
  /* CreateComponent */
  , function (vm, _ref5) {
    var flags = _ref5.op1,
        _state = _ref5.op2;
    var instance = vm.fetchValue(_state);
    var definition = instance.definition,
        manager$1 = instance.manager,
        capabilities = instance.capabilities;

    if (!manager.managerHasCapability(manager$1, capabilities, 512
    /* CreateInstance */
    )) {
      // TODO: Closure and Main components are always invoked dynamically, so this
      // opcode may run even if this capability is not enabled. In the future we
      // should handle this in a better way.
      return;
    }

    var dynamicScope = null;

    if (manager.managerHasCapability(manager$1, capabilities, 64
    /* DynamicScope */
    )) {
      dynamicScope = vm.dynamicScope();
    }

    var hasDefaultBlock = flags & 1;
    var args = null;

    if (manager.managerHasCapability(manager$1, capabilities, 8
    /* CreateArgs */
    )) {
      args = vm.stack.peek();
    }

    var self = null;

    if (manager.managerHasCapability(manager$1, capabilities, 128
    /* CreateCaller */
    )) {
      self = vm.getSelf();
    }

    var state = manager$1.create(vm.getOwner(), definition.state, args, vm.env, dynamicScope, self, !!hasDefaultBlock); // We want to reuse the `state` POJO here, because we know that the opcodes
    // only transition at exactly one place.

    instance.state = state;

    if (manager.managerHasCapability(manager$1, capabilities, 256
    /* UpdateHook */
    )) {
      vm.updateWith(new UpdateComponentOpcode(state, manager$1, dynamicScope));
    }
  });
  APPEND_OPCODES.add(88
  /* RegisterComponentDestructor */
  , function (vm, _ref6) {
    var _state = _ref6.op1;

    var _vm$fetchValue = vm.fetchValue(_state),
        manager$1 = _vm$fetchValue.manager,
        state = _vm$fetchValue.state,
        capabilities = _vm$fetchValue.capabilities;

    var d = manager$1.getDestroyable(state);

    if (env.DEBUG && !manager.managerHasCapability(manager$1, capabilities, 2048
    /* WillDestroy */
    ) && d !== null && typeof 'willDestroy' in d) {
      throw new Error('BUG: Destructor has willDestroy, but the willDestroy capability was not enabled for this component. Pre-destruction hooks must be explicitly opted into');
    }

    if (d) vm.associateDestroyable(d);
  });
  APPEND_OPCODES.add(97
  /* BeginComponentTransaction */
  , function (vm, _ref7) {
    var _state = _ref7.op1;

    var _a;

    var name;

    if (env.DEBUG) {
      var _vm$fetchValue2 = vm.fetchValue(_state),
          definition = _vm$fetchValue2.definition,
          manager = _vm$fetchValue2.manager;

      name = (_a = definition.resolvedName) !== null && _a !== void 0 ? _a : manager.getDebugName(definition.state);
    }

    vm.beginCacheGroup(name);
    vm.elements().pushSimpleBlock();
  });
  APPEND_OPCODES.add(89
  /* PutComponentOperations */
  , function (vm$1) {
    vm$1.loadValue(vm.$t0, new ComponentElementOperations());
  });
  APPEND_OPCODES.add(53
  /* ComponentAttr */
  , function (vm$1, _ref8) {
    var _name = _ref8.op1,
        _trusting = _ref8.op2,
        _namespace = _ref8.op3;
    var name = vm$1[CONSTANTS].getValue(_name);
    var trusting = vm$1[CONSTANTS].getValue(_trusting);
    var reference = vm$1.stack.pop();
    var namespace = _namespace ? vm$1[CONSTANTS].getValue(_namespace) : null;
    vm$1.fetchValue(vm.$t0).setAttribute(name, reference, trusting, namespace);
  });
  APPEND_OPCODES.add(105
  /* StaticComponentAttr */
  , function (vm$1, _ref9) {
    var _name = _ref9.op1,
        _value = _ref9.op2,
        _namespace = _ref9.op3;
    var name = vm$1[CONSTANTS].getValue(_name);
    var value = vm$1[CONSTANTS].getValue(_value);
    var namespace = _namespace ? vm$1[CONSTANTS].getValue(_namespace) : null;
    vm$1.fetchValue(vm.$t0).setStaticAttribute(name, value, namespace);
  });
  var ComponentElementOperations = /*#__PURE__*/function () {
    function ComponentElementOperations() {
      this.attributes = util.dict();
      this.classes = [];
      this.modifiers = [];
    }

    var _proto = ComponentElementOperations.prototype;

    _proto.setAttribute = function setAttribute(name, value, trusting, namespace) {
      var deferred = {
        value: value,
        namespace: namespace,
        trusting: trusting
      };

      if (name === 'class') {
        this.classes.push(value);
      }

      this.attributes[name] = deferred;
    };

    _proto.setStaticAttribute = function setStaticAttribute(name, value, namespace) {
      var deferred = {
        value: value,
        namespace: namespace
      };

      if (name === 'class') {
        this.classes.push(value);
      }

      this.attributes[name] = deferred;
    };

    _proto.addModifier = function addModifier(modifier) {
      this.modifiers.push(modifier);
    };

    _proto.flush = function flush(vm) {
      var type;
      var attributes = this.attributes;

      for (var name in this.attributes) {
        if (name === 'type') {
          type = attributes[name];
          continue;
        }

        var attr = this.attributes[name];

        if (name === 'class') {
          setDeferredAttr(vm, 'class', mergeClasses(this.classes), attr.namespace, attr.trusting);
        } else {
          setDeferredAttr(vm, name, attr.value, attr.namespace, attr.trusting);
        }
      }

      if (type !== undefined) {
        setDeferredAttr(vm, 'type', type.value, type.namespace, type.trusting);
      }

      return this.modifiers;
    };

    return ComponentElementOperations;
  }();

  function mergeClasses(classes) {
    if (classes.length === 0) {
      return '';
    }

    if (classes.length === 1) {
      return classes[0];
    }

    if (allStringClasses(classes)) {
      return classes.join(' ');
    }

    return createClassListRef(classes);
  }

  function allStringClasses(classes) {
    for (var i = 0; i < classes.length; i++) {
      if (typeof classes[i] !== 'string') {
        return false;
      }
    }

    return true;
  }

  function setDeferredAttr(vm, name, value, namespace, trusting) {
    if (trusting === void 0) {
      trusting = false;
    }

    if (typeof value === 'string') {
      vm.elements().setStaticAttribute(name, value, namespace);
    } else {
      var attribute = vm.elements().setDynamicAttribute(name, reference.valueForRef(value), trusting, namespace);

      if (!reference.isConstRef(value)) {
        vm.updateWith(new UpdateDynamicAttributeOpcode(value, attribute, vm.env));
      }
    }
  }

  APPEND_OPCODES.add(99
  /* DidCreateElement */
  , function (vm$1, _ref10) {
    var _state = _ref10.op1;

    var _vm$fetchValue3 = vm$1.fetchValue(_state),
        definition = _vm$fetchValue3.definition,
        state = _vm$fetchValue3.state;

    var manager = definition.manager;
    var operations = vm$1.fetchValue(vm.$t0);
    manager.didCreateElement(state, vm$1.elements().constructing, operations);
  });
  APPEND_OPCODES.add(90
  /* GetComponentSelf */
  , function (vm, _ref11) {
    var _state = _ref11.op1,
        _names = _ref11.op2;

    var _a;

    var instance = vm.fetchValue(_state);
    var definition = instance.definition,
        state = instance.state;
    var manager$1 = definition.manager;
    var selfRef = manager$1.getSelf(state);

    if (vm.env.debugRenderTree !== undefined) {
      var _instance = vm.fetchValue(_state);

      var _definition3 = _instance.definition,
          _manager2 = _instance.manager;
      var args;

      if (vm.stack.peek() === vm[ARGS]) {
        args = vm[ARGS].capture();
      } else {
        var names = vm[CONSTANTS].getArray(_names);
        vm[ARGS].setup(vm.stack, names, [], 0, true);
        args = vm[ARGS].capture();
      }

      var moduleName;
      var compilable = _definition3.compilable;

      if (compilable === null) {
        compilable = _manager2.getDynamicLayout(state, vm.runtime.resolver);

        if (compilable !== null) {
          moduleName = compilable.moduleName;
        } else {
          moduleName = '__default__.hbs';
        }
      } else {
        moduleName = compilable.moduleName;
      } // For tearing down the debugRenderTree


      vm.associateDestroyable(_instance);

      if (hasCustomDebugRenderTreeLifecycle(_manager2)) {
        var nodes = _manager2.getDebugCustomRenderTree(_instance.definition.state, _instance.state, args, moduleName);

        nodes.forEach(function (node) {
          var bucket = node.bucket;
          vm.env.debugRenderTree.create(bucket, node);
          destroyable.registerDestructor(_instance, function () {
            var _a;

            (_a = vm.env.debugRenderTree) === null || _a === void 0 ? void 0 : _a.willDestroy(bucket);
          });
          vm.updateWith(new DebugRenderTreeUpdateOpcode(bucket));
        });
      } else {
        var name = (_a = _definition3.resolvedName) !== null && _a !== void 0 ? _a : _manager2.getDebugName(_definition3.state);
        vm.env.debugRenderTree.create(_instance, {
          type: 'component',
          name: name,
          args: args,
          template: moduleName,
          instance: reference.valueForRef(selfRef)
        });
        vm.associateDestroyable(_instance);
        destroyable.registerDestructor(_instance, function () {
          var _a;

          (_a = vm.env.debugRenderTree) === null || _a === void 0 ? void 0 : _a.willDestroy(_instance);
        });
        vm.updateWith(new DebugRenderTreeUpdateOpcode(_instance));
      }
    }

    vm.stack.push(selfRef);
  });
  APPEND_OPCODES.add(91
  /* GetComponentTagName */
  , function (vm, _ref12) {
    var _state = _ref12.op1;

    var _vm$fetchValue4 = vm.fetchValue(_state),
        definition = _vm$fetchValue4.definition,
        state = _vm$fetchValue4.state;

    var manager = definition.manager;
    var tagName = manager.getTagName(state); // User provided value from JS, so we don't bother to encode

    vm.stack.push(tagName);
  }); // Dynamic Invocation Only

  APPEND_OPCODES.add(92
  /* GetComponentLayout */
  , function (vm, _ref13) {
    var _state = _ref13.op1;
    var instance = vm.fetchValue(_state);
    var manager$1 = instance.manager,
        definition = instance.definition;
    var stack = vm.stack;
    var compilable = definition.compilable;

    if (compilable === null) {
      var capabilities = instance.capabilities;
      compilable = manager$1.getDynamicLayout(instance.state, vm.runtime.resolver);

      if (compilable === null) {
        if (manager.managerHasCapability(manager$1, capabilities, 1024
        /* Wrapped */
        )) {
          compilable = util.unwrapTemplate(vm[CONSTANTS].defaultTemplate).asWrappedLayout();
        } else {
          compilable = util.unwrapTemplate(vm[CONSTANTS].defaultTemplate).asLayout();
        }
      }
    }

    var handle = compilable.compile(vm.context);
    stack.push(compilable.symbolTable);
    stack.push(handle);
  });
  APPEND_OPCODES.add(75
  /* Main */
  , function (vm, _ref14) {
    var register = _ref14.op1;
    var definition = vm.stack.pop();
    var invocation = vm.stack.pop();
    var manager = definition.manager,
        capabilities = definition.capabilities;
    var state = {
      definition: definition,
      manager: manager,
      capabilities: capabilities,
      state: null,
      handle: invocation.handle,
      table: invocation.symbolTable,
      lookup: null
    };
    vm.loadValue(register, state);
  });
  APPEND_OPCODES.add(95
  /* PopulateLayout */
  , function (vm, _ref15) {
    var _state = _ref15.op1;
    var stack = vm.stack; // In DEBUG handles could be ErrHandle objects

    var handle = stack.pop();
    var table = stack.pop();
    var state = vm.fetchValue(_state);
    state.handle = handle;
    state.table = table;
  });
  APPEND_OPCODES.add(38
  /* VirtualRootScope */
  , function (vm$1, _ref16) {
    var _state = _ref16.op1;

    var _vm$fetchValue5 = vm$1.fetchValue(_state),
        table = _vm$fetchValue5.table,
        manager$1 = _vm$fetchValue5.manager,
        capabilities = _vm$fetchValue5.capabilities,
        state = _vm$fetchValue5.state;

    var owner;

    if (manager.managerHasCapability(manager$1, capabilities, 4096
    /* HasSubOwner */
    )) {
      owner = manager$1.getOwner(state);
      vm$1.loadValue(vm.$t1, null); // Clear the temp register
    } else {
      // Check the temp register to see if an owner was resolved from currying
      owner = vm$1.fetchValue(vm.$t1);

      if (owner === null) {
        // If an owner wasn't found, default to using the current owner. This
        // will happen for normal dynamic component invocation,
        // e.g. <SomeClassicEmberComponent/>
        owner = vm$1.getOwner();
      } else {
        // Else the owner was found, so clear the temp register. This will happen
        // if we are loading a curried component, e.g. <@someCurriedComponent/>
        vm$1.loadValue(vm.$t1, null);
      }
    }

    vm$1.pushRootScope(table.symbols.length + 1, owner);
  });
  APPEND_OPCODES.add(94
  /* SetupForEval */
  , function (vm, _ref17) {
    var _state = _ref17.op1;
    var state = vm.fetchValue(_state);

    if (state.table.hasEval) {
      var lookup = state.lookup = util.dict();
      vm.scope().bindEvalScope(lookup);
    }
  });
  APPEND_OPCODES.add(17
  /* SetNamedVariables */
  , function (vm, _ref18) {
    var _state = _ref18.op1;
    var state = vm.fetchValue(_state);
    var scope = vm.scope();
    var args = vm.stack.peek();
    var callerNames = args.named.atNames;

    for (var i = callerNames.length - 1; i >= 0; i--) {
      var atName = callerNames[i];
      var symbol = state.table.symbols.indexOf(callerNames[i]);
      var value = args.named.get(atName, true);
      if (symbol !== -1) scope.bindSymbol(symbol + 1, value);
      if (state.lookup) state.lookup[atName] = value;
    }
  });

  function bindBlock(symbolName, blockName, state, blocks, vm) {
    var symbol = state.table.symbols.indexOf(symbolName);
    var block = blocks.get(blockName);
    if (symbol !== -1) vm.scope().bindBlock(symbol + 1, block);
    if (state.lookup) state.lookup[symbolName] = block;
  }

  APPEND_OPCODES.add(18
  /* SetBlocks */
  , function (vm, _ref19) {
    var _state = _ref19.op1;
    var state = vm.fetchValue(_state);

    var _vm$stack$peek = vm.stack.peek(),
        blocks = _vm$stack$peek.blocks;

    for (var i = 0; i < blocks.names.length; i++) {
      bindBlock(blocks.symbolNames[i], blocks.names[i], state, blocks, vm);
    }
  }); // Dynamic Invocation Only

  APPEND_OPCODES.add(96
  /* InvokeComponentLayout */
  , function (vm, _ref20) {
    var _state = _ref20.op1;
    var state = vm.fetchValue(_state);
    vm.call(state.handle);
  });
  APPEND_OPCODES.add(100
  /* DidRenderLayout */
  , function (vm, _ref21) {
    var _state = _ref21.op1;
    var instance = vm.fetchValue(_state);
    var manager$1 = instance.manager,
        state = instance.state,
        capabilities = instance.capabilities;
    var bounds = vm.elements().popBlock();

    if (vm.env.debugRenderTree !== undefined) {
      if (hasCustomDebugRenderTreeLifecycle(manager$1)) {
        var nodes = manager$1.getDebugCustomRenderTree(instance.definition.state, state, EMPTY_ARGS);
        nodes.reverse().forEach(function (node) {
          var bucket = node.bucket;
          vm.env.debugRenderTree.didRender(bucket, bounds);
          vm.updateWith(new DebugRenderTreeDidRenderOpcode(bucket, bounds));
        });
      } else {
        vm.env.debugRenderTree.didRender(instance, bounds);
        vm.updateWith(new DebugRenderTreeDidRenderOpcode(instance, bounds));
      }
    }

    if (manager.managerHasCapability(manager$1, capabilities, 512
    /* CreateInstance */
    )) {
      var mgr = manager$1;
      mgr.didRenderLayout(state, bounds);
      vm.env.didCreate(instance);
      vm.updateWith(new DidUpdateLayoutOpcode(instance, bounds));
    }
  });
  APPEND_OPCODES.add(98
  /* CommitComponentTransaction */
  , function (vm) {
    vm.commitCacheGroup();
  });
  var UpdateComponentOpcode = /*#__PURE__*/function () {
    function UpdateComponentOpcode(component, manager, dynamicScope) {
      this.component = component;
      this.manager = manager;
      this.dynamicScope = dynamicScope;
    }

    var _proto2 = UpdateComponentOpcode.prototype;

    _proto2.evaluate = function evaluate(_vm) {
      var component = this.component,
          manager = this.manager,
          dynamicScope = this.dynamicScope;
      manager.update(component, dynamicScope);
    };

    return UpdateComponentOpcode;
  }();
  var DidUpdateLayoutOpcode = /*#__PURE__*/function () {
    function DidUpdateLayoutOpcode(component, bounds) {
      this.component = component;
      this.bounds = bounds;
    }

    var _proto3 = DidUpdateLayoutOpcode.prototype;

    _proto3.evaluate = function evaluate(vm) {
      var component = this.component,
          bounds = this.bounds;
      var manager = component.manager,
          state = component.state;
      manager.didUpdateLayout(state, bounds);
      vm.env.didUpdate(component);
    };

    return DidUpdateLayoutOpcode;
  }();

  var DebugRenderTreeUpdateOpcode = /*#__PURE__*/function () {
    function DebugRenderTreeUpdateOpcode(bucket) {
      this.bucket = bucket;
    }

    var _proto4 = DebugRenderTreeUpdateOpcode.prototype;

    _proto4.evaluate = function evaluate(vm) {
      var _a;

      (_a = vm.env.debugRenderTree) === null || _a === void 0 ? void 0 : _a.update(this.bucket);
    };

    return DebugRenderTreeUpdateOpcode;
  }();

  var DebugRenderTreeDidRenderOpcode = /*#__PURE__*/function () {
    function DebugRenderTreeDidRenderOpcode(bucket, bounds) {
      this.bucket = bucket;
      this.bounds = bounds;
    }

    var _proto5 = DebugRenderTreeDidRenderOpcode.prototype;

    _proto5.evaluate = function evaluate(vm) {
      var _a;

      (_a = vm.env.debugRenderTree) === null || _a === void 0 ? void 0 : _a.didRender(this.bucket, this.bounds);
    };

    return DebugRenderTreeDidRenderOpcode;
  }();

  var DynamicTextContent = /*#__PURE__*/function () {
    function DynamicTextContent(node, reference, lastValue) {
      this.node = node;
      this.reference = reference;
      this.lastValue = lastValue;
    }

    var _proto = DynamicTextContent.prototype;

    _proto.evaluate = function evaluate() {
      var value = reference.valueForRef(this.reference);
      var lastValue = this.lastValue;
      if (value === lastValue) return;
      var normalized;

      if (isEmpty(value)) {
        normalized = '';
      } else if (isString(value)) {
        normalized = value;
      } else {
        normalized = String(value);
      }

      if (normalized !== lastValue) {
        var textNode = this.node;
        textNode.nodeValue = this.lastValue = normalized;
      }
    };

    return DynamicTextContent;
  }();

  function toContentType(value) {
    if (shouldCoerce(value)) {
      return 2
      /* String */
      ;
    } else if (isCurriedType(value, 0
    /* Component */
    ) || manager.hasInternalComponentManager(value)) {
      return 0
      /* Component */
      ;
    } else if (isCurriedType(value, 1
    /* Helper */
    ) || manager.hasInternalHelperManager(value)) {
      return 1
      /* Helper */
      ;
    } else if (isSafeString(value)) {
      return 4
      /* SafeString */
      ;
    } else if (isFragment(value)) {
      return 5
      /* Fragment */
      ;
    } else if (isNode(value)) {
      return 6
      /* Node */
      ;
    } else {
        return 2
        /* String */
        ;
      }
  }

  function toDynamicContentType(value) {
    if (!util.isObject(value)) {
      return 2
      /* String */
      ;
    }

    if (isCurriedType(value, 0
    /* Component */
    ) || manager.hasInternalComponentManager(value)) {
      return 0
      /* Component */
      ;
    } else {
      if (env.DEBUG && !isCurriedType(value, 1
      /* Helper */
      ) && !manager.hasInternalHelperManager(value)) {
        throw new Error("Attempted use a dynamic value as a component or helper, but that value did not have an associated component or helper manager. The value was: " + value);
      }

      return 1
      /* Helper */
      ;
    }
  }

  APPEND_OPCODES.add(76
  /* ContentType */
  , function (vm) {
    var reference$1 = vm.stack.peek();
    vm.stack.push(toContentType(reference.valueForRef(reference$1)));

    if (!reference.isConstRef(reference$1)) {
      vm.updateWith(new AssertFilter(reference$1, toContentType));
    }
  });
  APPEND_OPCODES.add(106
  /* DynamicContentType */
  , function (vm) {
    var reference$1 = vm.stack.peek();
    vm.stack.push(toDynamicContentType(reference.valueForRef(reference$1)));

    if (!reference.isConstRef(reference$1)) {
      vm.updateWith(new AssertFilter(reference$1, toDynamicContentType));
    }
  });
  APPEND_OPCODES.add(43
  /* AppendHTML */
  , function (vm) {
    var reference$1 = vm.stack.pop();
    var rawValue = reference.valueForRef(reference$1);
    var value = isEmpty(rawValue) ? '' : String(rawValue);
    vm.elements().appendDynamicHTML(value);
  });
  APPEND_OPCODES.add(44
  /* AppendSafeHTML */
  , function (vm) {
    var reference$1 = vm.stack.pop();
    var rawValue = reference.valueForRef(reference$1).toHTML();
    var value = isEmpty(rawValue) ? '' : rawValue;
    vm.elements().appendDynamicHTML(value);
  });
  APPEND_OPCODES.add(47
  /* AppendText */
  , function (vm) {
    var reference$1 = vm.stack.pop();
    var rawValue = reference.valueForRef(reference$1);
    var value = isEmpty(rawValue) ? '' : String(rawValue);
    var node = vm.elements().appendDynamicText(value);

    if (!reference.isConstRef(reference$1)) {
      vm.updateWith(new DynamicTextContent(node, reference$1, value));
    }
  });
  APPEND_OPCODES.add(45
  /* AppendDocumentFragment */
  , function (vm) {
    var reference$1 = vm.stack.pop();
    var value = reference.valueForRef(reference$1);
    vm.elements().appendDynamicFragment(value);
  });
  APPEND_OPCODES.add(46
  /* AppendNode */
  , function (vm) {
    var reference$1 = vm.stack.pop();
    var value = reference.valueForRef(reference$1);
    vm.elements().appendDynamicNode(value);
  });

  function debugCallback(context, get) {
    // eslint-disable-next-line no-console
    console.info('Use `context`, and `get(<path>)` to debug this template.'); // for example...
    // eslint-disable-next-line no-unused-expressions

    context === get('this'); // eslint-disable-next-line no-debugger

    debugger;
  }

  var callback = debugCallback; // For testing purposes

  function setDebuggerCallback(cb) {
    callback = cb;
  }
  function resetDebuggerCallback() {
    callback = debugCallback;
  }

  var ScopeInspector = /*#__PURE__*/function () {
    function ScopeInspector(scope, symbols, evalInfo) {
      this.scope = scope;
      this.locals = util.dict();

      for (var i = 0; i < evalInfo.length; i++) {
        var slot = evalInfo[i];
        var name = symbols[slot - 1];
        var ref = scope.getSymbol(slot);
        this.locals[name] = ref;
      }
    }

    var _proto = ScopeInspector.prototype;

    _proto.get = function get(path) {
      var scope = this.scope,
          locals = this.locals;
      var parts = path.split('.');

      var _path$split = path.split('.'),
          head = _path$split[0],
          tail = _path$split.slice(1);

      var evalScope = scope.getEvalScope();
      var ref;

      if (head === 'this') {
        ref = scope.getSelf();
      } else if (locals[head]) {
        ref = locals[head];
      } else if (head.indexOf('@') === 0 && evalScope[head]) {
        ref = evalScope[head];
      } else {
        ref = this.scope.getSelf();
        tail = parts;
      }

      return tail.reduce(function (r, part) {
        return reference.childRefFor(r, part);
      }, ref);
    };

    return ScopeInspector;
  }();

  APPEND_OPCODES.add(103
  /* Debugger */
  , function (vm, _ref) {
    var _symbols = _ref.op1,
        _evalInfo = _ref.op2;
    var symbols = vm[CONSTANTS].getArray(_symbols);
    var evalInfo = vm[CONSTANTS].getArray(util.decodeHandle(_evalInfo));
    var inspector = new ScopeInspector(vm.scope(), symbols, evalInfo);
    callback(reference.valueForRef(vm.getSelf()), function (path) {
      return reference.valueForRef(inspector.get(path));
    });
  });

  APPEND_OPCODES.add(72
  /* EnterList */
  , function (vm, _ref) {
    var relativeStart = _ref.op1,
        elseTarget = _ref.op2;
    var stack = vm.stack;
    var listRef = stack.pop();
    var keyRef = stack.pop();
    var keyValue = reference.valueForRef(keyRef);
    var key = keyValue === null ? '@identity' : String(keyValue);
    var iteratorRef = reference.createIteratorRef(listRef, key);
    var iterator = reference.valueForRef(iteratorRef);
    vm.updateWith(new AssertFilter(iteratorRef, function (iterator) {
      return iterator.isEmpty();
    }));

    if (iterator.isEmpty() === true) {
      // TODO: Fix this offset, should be accurate
      vm["goto"](elseTarget + 1);
    } else {
      vm.enterList(iteratorRef, relativeStart);
      vm.stack.push(iterator);
    }
  });
  APPEND_OPCODES.add(73
  /* ExitList */
  , function (vm) {
    vm.exitList();
  });
  APPEND_OPCODES.add(74
  /* Iterate */
  , function (vm, _ref2) {
    var breaks = _ref2.op1;
    var stack = vm.stack;
    var iterator = stack.peek();
    var item = iterator.next();

    if (item !== null) {
      vm.registerItem(vm.enterItem(item));
    } else {
      vm["goto"](breaks);
    }
  });

  var CAPABILITIES = {
    dynamicLayout: false,
    dynamicTag: false,
    prepareArgs: false,
    createArgs: false,
    attributeHook: false,
    elementHook: false,
    createCaller: false,
    dynamicScope: false,
    updateHook: false,
    createInstance: false,
    wrapped: false,
    willDestroy: false,
    hasSubOwner: false
  };
  var TemplateOnlyComponentManager = /*#__PURE__*/function () {
    function TemplateOnlyComponentManager() {}

    var _proto = TemplateOnlyComponentManager.prototype;

    _proto.getCapabilities = function getCapabilities() {
      return CAPABILITIES;
    };

    _proto.getDebugName = function getDebugName(_ref) {
      var name = _ref.name;
      return name;
    };

    _proto.getSelf = function getSelf() {
      return reference.NULL_REFERENCE;
    };

    _proto.getDestroyable = function getDestroyable() {
      return null;
    };

    return TemplateOnlyComponentManager;
  }();
  var TEMPLATE_ONLY_COMPONENT_MANAGER = new TemplateOnlyComponentManager(); // This is only exported for types, don't use this class directly

  var TemplateOnlyComponentDefinition = /*#__PURE__*/function () {
    function TemplateOnlyComponentDefinition(moduleName, name) {
      if (moduleName === void 0) {
        moduleName = '@glimmer/component/template-only';
      }

      if (name === void 0) {
        name = '(unknown template-only component)';
      }

      this.moduleName = moduleName;
      this.name = name;
    }

    var _proto2 = TemplateOnlyComponentDefinition.prototype;

    _proto2.toString = function toString() {
      return this.moduleName;
    };

    return TemplateOnlyComponentDefinition;
  }();
  manager.setInternalComponentManager(TEMPLATE_ONLY_COMPONENT_MANAGER, TemplateOnlyComponentDefinition.prototype);
  /**
    This utility function is used to declare a given component has no backing class. When the rendering engine detects this it
    is able to perform a number of optimizations. Templates that are associated with `templateOnly()` will be rendered _as is_
    without adding a wrapping `<div>` (or any of the other element customization behaviors of [@ember/component](/ember/release/classes/Component)).
    Specifically, this means that the template will be rendered as "outer HTML".

    In general, this method will be used by build time tooling and would not be directly written in an application. However,
    at times it may be useful to use directly to leverage the "outer HTML" semantics mentioned above. For example, if an addon would like
    to use these semantics for its templates but cannot be certain it will only be consumed by applications that have enabled the
    `template-only-glimmer-components` optional feature.

    @example

    ```js
    import { templateOnlyComponent } from '@glimmer/runtime';

    export default templateOnlyComponent();
    ```

    @public
    @method templateOnly
    @param {String} moduleName the module name that the template only component represents, this will be used for debugging purposes
    @category EMBER_GLIMMER_SET_COMPONENT_TEMPLATE
  */

  function templateOnlyComponent(moduleName, name) {
    return new TemplateOnlyComponentDefinition(moduleName, name);
  }

  var SVG_INTEGRATION_POINTS = {
    foreignObject: 1,
    desc: 1,
    title: 1
  }; // http://www.w3.org/TR/html/syntax.html#adjust-svg-attributes
  // TODO: Adjust SVG attributes
  // http://www.w3.org/TR/html/syntax.html#parsing-main-inforeign
  // TODO: Adjust SVG elements
  // http://www.w3.org/TR/html/syntax.html#parsing-main-inforeign

  var BLACKLIST_TABLE = Object.create(null);
  var DOMOperations = /*#__PURE__*/function () {
    function DOMOperations(document) {
      this.document = document;
      this.setupUselessElement();
    } // split into separate method so that NodeDOMTreeConstruction
    // can override it.


    var _proto = DOMOperations.prototype;

    _proto.setupUselessElement = function setupUselessElement() {
      this.uselessElement = this.document.createElement('div');
    };

    _proto.createElement = function createElement(tag, context) {
      var isElementInSVGNamespace, isHTMLIntegrationPoint;

      if (context) {
        isElementInSVGNamespace = context.namespaceURI === "http://www.w3.org/2000/svg"
        /* SVG */
        || tag === 'svg';
        isHTMLIntegrationPoint = !!SVG_INTEGRATION_POINTS[context.tagName];
      } else {
        isElementInSVGNamespace = tag === 'svg';
        isHTMLIntegrationPoint = false;
      }

      if (isElementInSVGNamespace && !isHTMLIntegrationPoint) {
        // FIXME: This does not properly handle <font> with color, face, or
        // size attributes, which is also disallowed by the spec. We should fix
        // this.
        if (BLACKLIST_TABLE[tag]) {
          throw new Error("Cannot create a " + tag + " inside an SVG context");
        }

        return this.document.createElementNS("http://www.w3.org/2000/svg"
        /* SVG */
        , tag);
      } else {
        return this.document.createElement(tag);
      }
    };

    _proto.insertBefore = function insertBefore(parent, node, reference) {
      parent.insertBefore(node, reference);
    };

    _proto.insertHTMLBefore = function insertHTMLBefore(parent, nextSibling, html) {
      if (html === '') {
        var comment = this.createComment('');
        parent.insertBefore(comment, nextSibling);
        return new ConcreteBounds(parent, comment, comment);
      }

      var prev = nextSibling ? nextSibling.previousSibling : parent.lastChild;
      var last;

      if (nextSibling === null) {
        parent.insertAdjacentHTML("beforeend"
        /* beforeend */
        , html);
        last = parent.lastChild;
      } else if (nextSibling instanceof HTMLElement) {
        nextSibling.insertAdjacentHTML('beforebegin', html);
        last = nextSibling.previousSibling;
      } else {
        // Non-element nodes do not support insertAdjacentHTML, so add an
        // element and call it on that element. Then remove the element.
        //
        // This also protects Edge, IE and Firefox w/o the inspector open
        // from merging adjacent text nodes. See ./compat/text-node-merging-fix.ts
        var uselessElement = this.uselessElement;
        parent.insertBefore(uselessElement, nextSibling);
        uselessElement.insertAdjacentHTML("beforebegin"
        /* beforebegin */
        , html);
        last = uselessElement.previousSibling;
        parent.removeChild(uselessElement);
      }

      var first = prev ? prev.nextSibling : parent.firstChild;
      return new ConcreteBounds(parent, first, last);
    };

    _proto.createTextNode = function createTextNode(text) {
      return this.document.createTextNode(text);
    };

    _proto.createComment = function createComment(data) {
      return this.document.createComment(data);
    };

    return DOMOperations;
  }();
  function moveNodesBefore(source, target, nextSibling) {
    var first = source.firstChild;
    var last = first;
    var current = first;

    while (current) {
      var next = current.nextSibling;
      target.insertBefore(current, nextSibling);
      last = current;
      current = next;
    }

    return new ConcreteBounds(target, first, last);
  }

  function _inheritsLoose$2(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  var SVG_NAMESPACE = "http://www.w3.org/2000/svg"
  /* SVG */
  ; // Patch:    insertAdjacentHTML on SVG Fix
  // Browsers: Safari, IE, Edge, Firefox ~33-34
  // Reason:   insertAdjacentHTML does not exist on SVG elements in Safari. It is
  //           present but throws an exception on IE and Edge. Old versions of
  //           Firefox create nodes in the incorrect namespace.
  // Fix:      Since IE and Edge silently fail to create SVG nodes using
  //           innerHTML, and because Firefox may create nodes in the incorrect
  //           namespace using innerHTML on SVG elements, an HTML-string wrapping
  //           approach is used. A pre/post SVG tag is added to the string, then
  //           that whole string is added to a div. The created nodes are plucked
  //           out and applied to the target location on DOM.

  function applySVGInnerHTMLFix(document, DOMClass, svgNamespace) {
    if (!document) return DOMClass;

    if (!shouldApplyFix(document, svgNamespace)) {
      return DOMClass;
    }

    var div = document.createElement('div');
    return /*#__PURE__*/function (_DOMClass) {
      _inheritsLoose$2(DOMChangesWithSVGInnerHTMLFix, _DOMClass);

      function DOMChangesWithSVGInnerHTMLFix() {
        return _DOMClass.apply(this, arguments) || this;
      }

      var _proto = DOMChangesWithSVGInnerHTMLFix.prototype;

      _proto.insertHTMLBefore = function insertHTMLBefore(parent, nextSibling, html) {
        if (html === '') {
          return _DOMClass.prototype.insertHTMLBefore.call(this, parent, nextSibling, html);
        }

        if (parent.namespaceURI !== svgNamespace) {
          return _DOMClass.prototype.insertHTMLBefore.call(this, parent, nextSibling, html);
        }

        return fixSVG(parent, div, html, nextSibling);
      };

      return DOMChangesWithSVGInnerHTMLFix;
    }(DOMClass);
  }

  function fixSVG(parent, div, html, reference) {
    var source; // This is important, because descendants of the <foreignObject> integration
    // point are parsed in the HTML namespace

    if (parent.tagName.toUpperCase() === 'FOREIGNOBJECT') {
      // IE, Edge: also do not correctly support using `innerHTML` on SVG
      // namespaced elements. So here a wrapper is used.
      var wrappedHtml = '<svg><foreignObject>' + html + '</foreignObject></svg>';
      util.clearElement(div);
      div.insertAdjacentHTML("afterbegin"
      /* afterbegin */
      , wrappedHtml);
      source = div.firstChild.firstChild;
    } else {
      // IE, Edge: also do not correctly support using `innerHTML` on SVG
      // namespaced elements. So here a wrapper is used.
      var _wrappedHtml = '<svg>' + html + '</svg>';

      util.clearElement(div);
      div.insertAdjacentHTML("afterbegin"
      /* afterbegin */
      , _wrappedHtml);
      source = div.firstChild;
    }

    return moveNodesBefore(source, parent, reference);
  }

  function shouldApplyFix(document, svgNamespace) {
    var svg = document.createElementNS(svgNamespace, 'svg');

    try {
      svg.insertAdjacentHTML("beforeend"
      /* beforeend */
      , '<circle></circle>');
    } catch (e) {// IE, Edge: Will throw, insertAdjacentHTML is unsupported on SVG
      // Safari: Will throw, insertAdjacentHTML is not present on SVG
    } finally {
      // FF: Old versions will create a node in the wrong namespace
      if (svg.childNodes.length === 1 && svg.firstChild.namespaceURI === SVG_NAMESPACE) {
        // The test worked as expected, no fix required
        return false;
      }

      return true;
    }
  }

  function _inheritsLoose$3(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

  // Patch:    Adjacent text node merging fix
  // Browsers: IE, Edge, Firefox w/o inspector open
  // Reason:   These browsers will merge adjacent text nodes. For example given
  //           <div>Hello</div> with div.insertAdjacentHTML(' world') browsers
  //           with proper behavior will populate div.childNodes with two items.
  //           These browsers will populate it with one merged node instead.
  // Fix:      Add these nodes to a wrapper element, then iterate the childNodes
  //           of that wrapper and move the nodes to their target location. Note
  //           that potential SVG bugs will have been handled before this fix.
  //           Note that this fix must only apply to the previous text node, as
  //           the base implementation of `insertHTMLBefore` already handles
  //           following text nodes correctly.
  function applyTextNodeMergingFix(document, DOMClass) {
    if (!document) return DOMClass;

    if (!shouldApplyFix$1(document)) {
      return DOMClass;
    }

    return /*#__PURE__*/function (_DOMClass) {
      _inheritsLoose$3(DOMChangesWithTextNodeMergingFix, _DOMClass);

      function DOMChangesWithTextNodeMergingFix(document) {
        var _this;

        _this = _DOMClass.call(this, document) || this;
        _this.uselessComment = document.createComment('');
        return _this;
      }

      var _proto = DOMChangesWithTextNodeMergingFix.prototype;

      _proto.insertHTMLBefore = function insertHTMLBefore(parent, nextSibling, html) {
        if (html === '') {
          return _DOMClass.prototype.insertHTMLBefore.call(this, parent, nextSibling, html);
        }

        var didSetUselessComment = false;
        var nextPrevious = nextSibling ? nextSibling.previousSibling : parent.lastChild;

        if (nextPrevious && nextPrevious instanceof Text) {
          didSetUselessComment = true;
          parent.insertBefore(this.uselessComment, nextSibling);
        }

        var bounds = _DOMClass.prototype.insertHTMLBefore.call(this, parent, nextSibling, html);

        if (didSetUselessComment) {
          parent.removeChild(this.uselessComment);
        }

        return bounds;
      };

      return DOMChangesWithTextNodeMergingFix;
    }(DOMClass);
  }

  function shouldApplyFix$1(document) {
    var mergingTextDiv = document.createElement('div');
    mergingTextDiv.appendChild(document.createTextNode('first'));
    mergingTextDiv.insertAdjacentHTML("beforeend"
    /* beforeend */
    , 'second');

    if (mergingTextDiv.childNodes.length === 2) {
      // It worked as expected, no fix required
      return false;
    }

    return true;
  }

  function _inheritsLoose$4(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  ['b', 'big', 'blockquote', 'body', 'br', 'center', 'code', 'dd', 'div', 'dl', 'dt', 'em', 'embed', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'hr', 'i', 'img', 'li', 'listing', 'main', 'meta', 'nobr', 'ol', 'p', 'pre', 'ruby', 's', 'small', 'span', 'strong', 'strike', 'sub', 'sup', 'table', 'tt', 'u', 'ul', 'var'].forEach(function (tag) {
    return BLACKLIST_TABLE[tag] = 1;
  });
  var WHITESPACE = /[\t-\r \xA0\u1680\u180E\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]/;
  var doc = typeof document === 'undefined' ? null : document;
  function isWhitespace(string) {
    return WHITESPACE.test(string);
  }
  var DOM;

  (function (DOM) {
    var TreeConstruction = /*#__PURE__*/function (_DOMOperations) {
      _inheritsLoose$4(TreeConstruction, _DOMOperations);

      function TreeConstruction() {
        return _DOMOperations.apply(this, arguments) || this;
      }

      var _proto = TreeConstruction.prototype;

      _proto.createElementNS = function createElementNS(namespace, tag) {
        return this.document.createElementNS(namespace, tag);
      };

      _proto.setAttribute = function setAttribute(element, name, value, namespace) {
        if (namespace === void 0) {
          namespace = null;
        }

        if (namespace) {
          element.setAttributeNS(namespace, name, value);
        } else {
          element.setAttribute(name, value);
        }
      };

      return TreeConstruction;
    }(DOMOperations);

    DOM.TreeConstruction = TreeConstruction;
    var appliedTreeConstruction = TreeConstruction;
    appliedTreeConstruction = applyTextNodeMergingFix(doc, appliedTreeConstruction);
    appliedTreeConstruction = applySVGInnerHTMLFix(doc, appliedTreeConstruction, "http://www.w3.org/2000/svg"
    /* SVG */
    );
    DOM.DOMTreeConstruction = appliedTreeConstruction;
  })(DOM || (DOM = {}));

  var DOMChangesImpl = /*#__PURE__*/function (_DOMOperations2) {
    _inheritsLoose$4(DOMChangesImpl, _DOMOperations2);

    function DOMChangesImpl(document) {
      var _this;

      _this = _DOMOperations2.call(this, document) || this;
      _this.document = document;
      _this.namespace = null;
      return _this;
    }

    var _proto2 = DOMChangesImpl.prototype;

    _proto2.setAttribute = function setAttribute(element, name, value) {
      element.setAttribute(name, value);
    };

    _proto2.removeAttribute = function removeAttribute(element, name) {
      element.removeAttribute(name);
    };

    _proto2.insertAfter = function insertAfter(element, node, reference) {
      this.insertBefore(element, node, reference.nextSibling);
    };

    return DOMChangesImpl;
  }(DOMOperations);
  var helper = DOMChangesImpl;
  helper = applyTextNodeMergingFix(doc, helper);
  helper = applySVGInnerHTMLFix(doc, helper, "http://www.w3.org/2000/svg"
  /* SVG */
  );
  var helper$1 = helper;
  var DOMTreeConstruction = DOM.DOMTreeConstruction;

  var GUID = 0;
  var Ref = /*#__PURE__*/function () {
    function Ref(value) {
      this.id = GUID++;
      this.value = value;
    }

    var _proto = Ref.prototype;

    _proto.get = function get() {
      return this.value;
    };

    _proto.release = function release() {
      if (env.DEBUG && this.value === null) {
        throw new Error('BUG: double release?');
      }

      this.value = null;
    };

    _proto.toString = function toString() {
      var label = "Ref " + this.id;

      if (this.value === null) {
        return label + " (released)";
      } else {
        try {
          return label + ": " + this.value;
        } catch (_a) {
          return label;
        }
      }
    };

    return Ref;
  }();

  var DebugRenderTreeImpl = /*#__PURE__*/function () {
    function DebugRenderTreeImpl() {
      this.stack = new util.Stack();
      this.refs = new WeakMap();
      this.roots = new Set();
      this.nodes = new WeakMap();
    }

    var _proto2 = DebugRenderTreeImpl.prototype;

    _proto2.begin = function begin() {
      this.reset();
    };

    _proto2.create = function create(state, node) {
      var internalNode = util.assign({}, node, {
        bounds: null,
        refs: new Set()
      });
      this.nodes.set(state, internalNode);
      this.appendChild(internalNode, state);
      this.enter(state);
    };

    _proto2.update = function update(state) {
      this.enter(state);
    };

    _proto2.didRender = function didRender(state, bounds) {
      if (env.DEBUG && this.stack.current !== state) {
        throw new Error("BUG: expecting " + this.stack.current + ", got " + state);
      }

      this.nodeFor(state).bounds = bounds;
      this.exit();
    };

    _proto2.willDestroy = function willDestroy(state) {
      this.refs.get(state).release();
    };

    _proto2.commit = function commit() {
      this.reset();
    };

    _proto2.capture = function capture() {
      return this.captureRefs(this.roots);
    };

    _proto2.reset = function reset() {
      if (this.stack.size !== 0) {
        // We probably encountered an error during the rendering loop. This will
        // likely trigger undefined behavior and memory leaks as the error left
        // things in an inconsistent state. It is recommended that the user
        // refresh the page.
        // TODO: We could warn here? But this happens all the time in our tests?
        // Clean up the root reference to prevent errors from happening if we
        // attempt to capture the render tree (Ember Inspector may do this)
        var root = this.stack.toArray()[0];
        var ref = this.refs.get(root);

        if (ref !== undefined) {
          this.roots["delete"](ref);
        }

        while (!this.stack.isEmpty()) {
          this.stack.pop();
        }
      }
    };

    _proto2.enter = function enter(state) {
      this.stack.push(state);
    };

    _proto2.exit = function exit() {
      if (env.DEBUG && this.stack.size === 0) {
        throw new Error('BUG: unbalanced pop');
      }

      this.stack.pop();
    };

    _proto2.nodeFor = function nodeFor(state) {
      return this.nodes.get(state);
    };

    _proto2.appendChild = function appendChild(node, state) {
      if (env.DEBUG && this.refs.has(state)) {
        throw new Error('BUG: child already appended');
      }

      var parent = this.stack.current;
      var ref = new Ref(state);
      this.refs.set(state, ref);

      if (parent) {
        var parentNode = this.nodeFor(parent);
        parentNode.refs.add(ref);
        node.parent = parentNode;
      } else {
        this.roots.add(ref);
      }
    };

    _proto2.captureRefs = function captureRefs(refs) {
      var _this = this;

      var captured = [];
      refs.forEach(function (ref) {
        var state = ref.get();

        if (state) {
          captured.push(_this.captureNode("render-node:" + ref.id, state));
        } else {
          refs["delete"](ref);
        }
      });
      return captured;
    };

    _proto2.captureNode = function captureNode(id, state) {
      var node = this.nodeFor(state);
      var type = node.type,
          name = node.name,
          args = node.args,
          instance = node.instance,
          refs = node.refs;
      var template = this.captureTemplate(node);
      var bounds = this.captureBounds(node);
      var children = this.captureRefs(refs);
      return {
        id: id,
        type: type,
        name: name,
        args: reifyArgs(args),
        instance: instance,
        template: template,
        bounds: bounds,
        children: children
      };
    };

    _proto2.captureTemplate = function captureTemplate(_ref) {
      var template = _ref.template;
      return template || null;
    };

    _proto2.captureBounds = function captureBounds(node) {
      var bounds = node.bounds;
      var parentElement = bounds.parentElement();
      var firstNode = bounds.firstNode();
      var lastNode = bounds.lastNode();
      return {
        parentElement: parentElement,
        firstNode: firstNode,
        lastNode: lastNode
      };
    };

    return DebugRenderTreeImpl;
  }();

  function _defineProperties$2(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$2(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$2(Constructor.prototype, protoProps); if (staticProps) _defineProperties$2(Constructor, staticProps); return Constructor; }

  var _a$1;
  var TRANSACTION = util.symbol('TRANSACTION');

  var TransactionImpl = /*#__PURE__*/function () {
    function TransactionImpl() {
      this.scheduledInstallModifiers = [];
      this.scheduledUpdateModifiers = [];
      this.createdComponents = [];
      this.updatedComponents = [];
    }

    var _proto = TransactionImpl.prototype;

    _proto.didCreate = function didCreate(component) {
      this.createdComponents.push(component);
    };

    _proto.didUpdate = function didUpdate(component) {
      this.updatedComponents.push(component);
    };

    _proto.scheduleInstallModifier = function scheduleInstallModifier(modifier) {
      this.scheduledInstallModifiers.push(modifier);
    };

    _proto.scheduleUpdateModifier = function scheduleUpdateModifier(modifier) {
      this.scheduledUpdateModifiers.push(modifier);
    };

    _proto.commit = function commit() {
      var createdComponents = this.createdComponents,
          updatedComponents = this.updatedComponents;

      for (var i = 0; i < createdComponents.length; i++) {
        var _createdComponents$i = createdComponents[i],
            _manager = _createdComponents$i.manager,
            _state = _createdComponents$i.state;

        _manager.didCreate(_state);
      }

      for (var _i = 0; _i < updatedComponents.length; _i++) {
        var _updatedComponents$_i = updatedComponents[_i],
            _manager2 = _updatedComponents$_i.manager,
            _state2 = _updatedComponents$_i.state;

        _manager2.didUpdate(_state2);
      }

      var scheduledInstallModifiers = this.scheduledInstallModifiers,
          scheduledUpdateModifiers = this.scheduledUpdateModifiers; // Prevent a transpilation issue we guard against in Ember, the
      // throw-if-closure-required issue

      var manager, state;

      for (var _i2 = 0; _i2 < scheduledInstallModifiers.length; _i2++) {
        var modifier = scheduledInstallModifiers[_i2];
        manager = modifier.manager;
        state = modifier.state;
        var modifierTag = manager.getTag(state);

        if (modifierTag !== null) {
          var tag = validator.track( // eslint-disable-next-line no-loop-func
          function () {
            return manager.install(state);
          }, env.DEBUG && "- While rendering:\n  (instance of a `" + (modifier.definition.resolvedName || manager.getDebugName(modifier.definition.state)) + "` modifier)");
          validator.updateTag(modifierTag, tag);
        } else {
          manager.install(state);
        }
      }

      for (var _i3 = 0; _i3 < scheduledUpdateModifiers.length; _i3++) {
        var _modifier = scheduledUpdateModifiers[_i3];
        manager = _modifier.manager;
        state = _modifier.state;

        var _modifierTag = manager.getTag(state);

        if (_modifierTag !== null) {
          var _tag = validator.track( // eslint-disable-next-line no-loop-func
          function () {
            return manager.update(state);
          }, env.DEBUG && "- While rendering:\n  (instance of a `" + (_modifier.definition.resolvedName || manager.getDebugName(_modifier.definition.state)) + "` modifier)");

          validator.updateTag(_modifierTag, _tag);
        } else {
          manager.update(state);
        }
      }
    };

    return TransactionImpl;
  }();

  var EnvironmentImpl = /*#__PURE__*/function () {
    function EnvironmentImpl(options, delegate) {
      this.delegate = delegate;
      this[_a$1] = null; // Delegate methods and values

      this.isInteractive = this.delegate.isInteractive;
      this.debugRenderTree = this.delegate.enableDebugTooling ? new DebugRenderTreeImpl() : undefined;

      if (options.appendOperations) {
        this.appendOperations = options.appendOperations;
        this.updateOperations = options.updateOperations;
      } else if (options.document) {
        this.appendOperations = new DOMTreeConstruction(options.document);
        this.updateOperations = new DOMChangesImpl(options.document);
      } else if (env.DEBUG) {
        throw new Error('you must pass document or appendOperations to a new runtime');
      }
    }

    var _proto2 = EnvironmentImpl.prototype;

    _proto2.getAppendOperations = function getAppendOperations() {
      return this.appendOperations;
    };

    _proto2.getDOM = function getDOM() {
      return this.updateOperations;
    };

    _proto2.begin = function begin() {
      var _b;
      (_b = this.debugRenderTree) === null || _b === void 0 ? void 0 : _b.begin();
      this[TRANSACTION] = new TransactionImpl();
    };

    _proto2.didCreate = function didCreate(component) {
      this.transaction.didCreate(component);
    };

    _proto2.didUpdate = function didUpdate(component) {
      this.transaction.didUpdate(component);
    };

    _proto2.scheduleInstallModifier = function scheduleInstallModifier(modifier) {
      if (this.isInteractive) {
        this.transaction.scheduleInstallModifier(modifier);
      }
    };

    _proto2.scheduleUpdateModifier = function scheduleUpdateModifier(modifier) {
      if (this.isInteractive) {
        this.transaction.scheduleUpdateModifier(modifier);
      }
    };

    _proto2.commit = function commit() {
      var _b;

      var transaction = this.transaction;
      this[TRANSACTION] = null;
      transaction.commit();
      (_b = this.debugRenderTree) === null || _b === void 0 ? void 0 : _b.commit();
      this.delegate.onTransactionCommit();
    };

    _createClass$2(EnvironmentImpl, [{
      key: "transaction",
      get: function get() {
        return this[TRANSACTION];
      }
    }]);

    return EnvironmentImpl;
  }();
  _a$1 = TRANSACTION;
  function runtimeContext(options, delegate, artifacts, resolver) {
    return {
      env: new EnvironmentImpl(options, delegate),
      program: new program.RuntimeProgramImpl(artifacts.constants, artifacts.heap),
      resolver: resolver
    };
  }
  function inTransaction(env, cb) {
    if (!env[TRANSACTION]) {
      env.begin();

      try {
        cb();
      } finally {
        env.commit();
      }
    } else {
      cb();
    }
  }

  function initializeRegistersWithSP(sp) {
    return [0, -1, sp, 0];
  }

  var LowLevelVM = /*#__PURE__*/function () {
    function LowLevelVM(stack, heap, program, externs, registers) {
      this.stack = stack;
      this.heap = heap;
      this.program = program;
      this.externs = externs;
      this.registers = registers;
      this.currentOpSize = 0;
    }

    var _proto = LowLevelVM.prototype;

    _proto.fetchRegister = function fetchRegister(register) {
      return this.registers[register];
    };

    _proto.loadRegister = function loadRegister(register, value) {
      this.registers[register] = value;
    };

    _proto.setPc = function setPc(pc) {
      this.registers[vm.$pc] = pc;
    } // Start a new frame and save $ra and $fp on the stack
    ;

    _proto.pushFrame = function pushFrame() {
      this.stack.push(this.registers[vm.$ra]);
      this.stack.push(this.registers[vm.$fp]);
      this.registers[vm.$fp] = this.registers[vm.$sp] - 1;
    } // Restore $ra, $sp and $fp
    ;

    _proto.popFrame = function popFrame() {
      this.registers[vm.$sp] = this.registers[vm.$fp] - 1;
      this.registers[vm.$ra] = this.stack.get(0);
      this.registers[vm.$fp] = this.stack.get(1);
    };

    _proto.pushSmallFrame = function pushSmallFrame() {
      this.stack.push(this.registers[vm.$ra]);
    };

    _proto.popSmallFrame = function popSmallFrame() {
      this.registers[vm.$ra] = this.stack.pop();
    } // Jump to an address in `program`
    ;

    _proto["goto"] = function goto(offset) {
      this.setPc(this.target(offset));
    };

    _proto.target = function target(offset) {
      return this.registers[vm.$pc] + offset - this.currentOpSize;
    } // Save $pc into $ra, then jump to a new address in `program` (jal in MIPS)
    ;

    _proto.call = function call(handle) {
      this.registers[vm.$ra] = this.registers[vm.$pc];
      this.setPc(this.heap.getaddr(handle));
    } // Put a specific `program` address in $ra
    ;

    _proto.returnTo = function returnTo(offset) {
      this.registers[vm.$ra] = this.target(offset);
    } // Return to the `program` address stored in $ra
    ;

    _proto["return"] = function _return() {
      this.setPc(this.registers[vm.$ra]);
    };

    _proto.nextStatement = function nextStatement() {
      var registers = this.registers,
          program = this.program;
      var pc = registers[vm.$pc];

      if (pc === -1) {
        return null;
      } // We have to save off the current operations size so that
      // when we do a jump we can calculate the correct offset
      // to where we are going. We can't simply ask for the size
      // in a jump because we have have already incremented the
      // program counter to the next instruction prior to executing.


      var opcode = program.opcode(pc);
      var operationSize = this.currentOpSize = opcode.size;
      this.registers[vm.$pc] += operationSize;
      return opcode;
    };

    _proto.evaluateOuter = function evaluateOuter(opcode, vm) {
      {
        this.evaluateInner(opcode, vm);
      }
    };

    _proto.evaluateInner = function evaluateInner(opcode, vm) {
      if (opcode.isMachine) {
        this.evaluateMachine(opcode);
      } else {
        this.evaluateSyscall(opcode, vm);
      }
    };

    _proto.evaluateMachine = function evaluateMachine(opcode) {
      switch (opcode.type) {
        case 0
        /* PushFrame */
        :
          return this.pushFrame();

        case 1
        /* PopFrame */
        :
          return this.popFrame();

        case 3
        /* InvokeStatic */
        :
          return this.call(opcode.op1);

        case 2
        /* InvokeVirtual */
        :
          return this.call(this.stack.pop());

        case 4
        /* Jump */
        :
          return this["goto"](opcode.op1);

        case 5
        /* Return */
        :
          return this["return"]();

        case 6
        /* ReturnTo */
        :
          return this.returnTo(opcode.op1);
      }
    };

    _proto.evaluateSyscall = function evaluateSyscall(opcode, vm) {
      APPEND_OPCODES.evaluate(vm, opcode, opcode.type);
    };

    return LowLevelVM;
  }();

  function _inheritsLoose$5(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

  function _defineProperties$3(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$3(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$3(Constructor.prototype, protoProps); if (staticProps) _defineProperties$3(Constructor, staticProps); return Constructor; }

  var UpdatingVMImpl = /*#__PURE__*/function () {
    function UpdatingVMImpl(env, _ref) {
      var _ref$alwaysRevalidate = _ref.alwaysRevalidate,
          alwaysRevalidate = _ref$alwaysRevalidate === void 0 ? false : _ref$alwaysRevalidate;
      this.frameStack = new util.Stack();
      this.env = env;
      this.dom = env.getDOM();
      this.alwaysRevalidate = alwaysRevalidate;
    }

    var _proto = UpdatingVMImpl.prototype;

    _proto.execute = function execute(opcodes, handler) {
      var _this = this;

      if (env.DEBUG) {
        var hasErrored = true;

        try {
          validator.runInTrackingTransaction(function () {
            return _this._execute(opcodes, handler);
          }, '- While rendering:'); // using a boolean here to avoid breaking ergonomics of "pause on uncaught exceptions"
          // which would happen with a `catch` + `throw`

          hasErrored = false;
        } finally {
          if (hasErrored) {
            // eslint-disable-next-line no-console
            console.error("\n\nError occurred:\n\n" + validator.resetTracking() + "\n\n");
          }
        }
      } else {
        this._execute(opcodes, handler);
      }
    };

    _proto._execute = function _execute(opcodes, handler) {
      var frameStack = this.frameStack;
      this["try"](opcodes, handler);

      while (true) {
        if (frameStack.isEmpty()) break;
        var opcode = this.frame.nextStatement();

        if (opcode === undefined) {
          frameStack.pop();
          continue;
        }

        opcode.evaluate(this);
      }
    };

    _proto["goto"] = function goto(index) {
      this.frame["goto"](index);
    };

    _proto["try"] = function _try(ops, handler) {
      this.frameStack.push(new UpdatingVMFrame(ops, handler));
    };

    _proto["throw"] = function _throw() {
      this.frame.handleException();
      this.frameStack.pop();
    };

    _createClass$3(UpdatingVMImpl, [{
      key: "frame",
      get: function get() {
        return this.frameStack.current;
      }
    }]);

    return UpdatingVMImpl;
  }();
  var ResumableVMStateImpl = /*#__PURE__*/function () {
    function ResumableVMStateImpl(state, resumeCallback) {
      this.state = state;
      this.resumeCallback = resumeCallback;
    }

    var _proto2 = ResumableVMStateImpl.prototype;

    _proto2.resume = function resume(runtime, builder) {
      return this.resumeCallback(runtime, this.state, builder);
    };

    return ResumableVMStateImpl;
  }();
  var BlockOpcode = /*#__PURE__*/function () {
    function BlockOpcode(state, runtime, bounds, children) {
      this.state = state;
      this.runtime = runtime;
      this.children = children;
      this.bounds = bounds;
    }

    var _proto3 = BlockOpcode.prototype;

    _proto3.parentElement = function parentElement() {
      return this.bounds.parentElement();
    };

    _proto3.firstNode = function firstNode() {
      return this.bounds.firstNode();
    };

    _proto3.lastNode = function lastNode() {
      return this.bounds.lastNode();
    };

    _proto3.evaluate = function evaluate(vm) {
      vm["try"](this.children, null);
    };

    return BlockOpcode;
  }();
  var TryOpcode = /*#__PURE__*/function (_BlockOpcode) {
    _inheritsLoose$5(TryOpcode, _BlockOpcode);

    function TryOpcode() {
      var _this2;

      _this2 = _BlockOpcode.apply(this, arguments) || this;
      _this2.type = 'try';
      return _this2;
    }

    var _proto4 = TryOpcode.prototype;

    _proto4.evaluate = function evaluate(vm) {
      vm["try"](this.children, this);
    };

    _proto4.handleException = function handleException() {
      var _this3 = this;

      var state = this.state,
          bounds = this.bounds,
          runtime = this.runtime;
      destroyable.destroyChildren(this);
      var elementStack = NewElementBuilder.resume(runtime.env, bounds);
      var vm = state.resume(runtime, elementStack);
      var updating = [];
      var children = this.children = [];
      var result = vm.execute(function (vm) {
        vm.pushUpdating(updating);
        vm.updateWith(_this3);
        vm.pushUpdating(children);
      });
      destroyable.associateDestroyableChild(this, result.drop);
    };

    return TryOpcode;
  }(BlockOpcode);
  var ListItemOpcode = /*#__PURE__*/function (_TryOpcode) {
    _inheritsLoose$5(ListItemOpcode, _TryOpcode);

    function ListItemOpcode(state, runtime, bounds, key, memo, value) {
      var _this4;

      _this4 = _TryOpcode.call(this, state, runtime, bounds, []) || this;
      _this4.key = key;
      _this4.memo = memo;
      _this4.value = value;
      _this4.retained = false;
      _this4.index = -1;
      return _this4;
    }

    var _proto5 = ListItemOpcode.prototype;

    _proto5.updateReferences = function updateReferences(item) {
      this.retained = true;
      reference.updateRef(this.value, item.value);
      reference.updateRef(this.memo, item.memo);
    };

    _proto5.shouldRemove = function shouldRemove() {
      return !this.retained;
    };

    _proto5.reset = function reset() {
      this.retained = false;
    };

    return ListItemOpcode;
  }(TryOpcode);
  var ListBlockOpcode = /*#__PURE__*/function (_BlockOpcode2) {
    _inheritsLoose$5(ListBlockOpcode, _BlockOpcode2);

    function ListBlockOpcode(state, runtime, bounds, children, iterableRef) {
      var _this5;

      _this5 = _BlockOpcode2.call(this, state, runtime, bounds, children) || this;
      _this5.iterableRef = iterableRef;
      _this5.type = 'list-block';
      _this5.opcodeMap = new Map();
      _this5.marker = null;
      _this5.lastIterator = reference.valueForRef(iterableRef);
      return _this5;
    }

    var _proto6 = ListBlockOpcode.prototype;

    _proto6.initializeChild = function initializeChild(opcode) {
      opcode.index = this.children.length - 1;
      this.opcodeMap.set(opcode.key, opcode);
    };

    _proto6.evaluate = function evaluate(vm) {
      var iterator = reference.valueForRef(this.iterableRef);

      if (this.lastIterator !== iterator) {
        var bounds = this.bounds;
        var dom = vm.dom;
        var marker = this.marker = dom.createComment('');
        dom.insertAfter(bounds.parentElement(), marker, bounds.lastNode());
        this.sync(iterator);
        this.parentElement().removeChild(marker);
        this.marker = null;
        this.lastIterator = iterator;
      } // Run now-updated updating opcodes


      _BlockOpcode2.prototype.evaluate.call(this, vm);
    };

    _proto6.sync = function sync(iterator) {
      var itemMap = this.opcodeMap,
          children = this.children;
      var currentOpcodeIndex = 0;
      var seenIndex = 0;
      this.children = this.bounds.boundList = [];

      while (true) {
        var item = iterator.next();
        if (item === null) break;
        var opcode = children[currentOpcodeIndex];
        var key = item.key; // Items that have already been found and moved will already be retained,
        // we can continue until we find the next unretained item

        while (opcode !== undefined && opcode.retained === true) {
          opcode = children[++currentOpcodeIndex];
        }

        if (opcode !== undefined && opcode.key === key) {
          this.retainItem(opcode, item);
          currentOpcodeIndex++;
        } else if (itemMap.has(key)) {
          var itemOpcode = itemMap.get(key); // The item opcode was seen already, so we should move it.

          if (itemOpcode.index < seenIndex) {
            this.moveItem(itemOpcode, item, opcode);
          } else {
            // Update the seen index, we are going to be moving this item around
            // so any other items that come before it will likely need to move as
            // well.
            seenIndex = itemOpcode.index;
            var seenUnretained = false; // iterate through all of the opcodes between the current position and
            // the position of the item's opcode, and determine if they are all
            // retained.

            for (var i = currentOpcodeIndex + 1; i < seenIndex; i++) {
              if (children[i].retained === false) {
                seenUnretained = true;
                break;
              }
            } // If we have seen only retained opcodes between this and the matching
            // opcode, it means that all the opcodes in between have been moved
            // already, and we can safely retain this item's opcode.


            if (seenUnretained === false) {
              this.retainItem(itemOpcode, item);
              currentOpcodeIndex = seenIndex + 1;
            } else {
              this.moveItem(itemOpcode, item, opcode);
              currentOpcodeIndex++;
            }
          }
        } else {
          this.insertItem(item, opcode);
        }
      }

      for (var _i = 0; _i < children.length; _i++) {
        var _opcode = children[_i];

        if (_opcode.retained === false) {
          this.deleteItem(_opcode);
        } else {
          _opcode.reset();
        }
      }
    };

    _proto6.retainItem = function retainItem(opcode, item) {

      var children = this.children;
      reference.updateRef(opcode.memo, item.memo);
      reference.updateRef(opcode.value, item.value);
      opcode.retained = true;
      opcode.index = children.length;
      children.push(opcode);
    };

    _proto6.insertItem = function insertItem(item, before) {
      var _this6 = this;

      var opcodeMap = this.opcodeMap,
          bounds = this.bounds,
          state = this.state,
          runtime = this.runtime,
          children = this.children;
      var key = item.key;
      var nextSibling = before === undefined ? this.marker : before.firstNode();
      var elementStack = NewElementBuilder.forInitialRender(runtime.env, {
        element: bounds.parentElement(),
        nextSibling: nextSibling
      });
      var vm = state.resume(runtime, elementStack);
      vm.execute(function (vm) {
        vm.pushUpdating();
        var opcode = vm.enterItem(item);
        opcode.index = children.length;
        children.push(opcode);
        opcodeMap.set(key, opcode);
        destroyable.associateDestroyableChild(_this6, opcode);
      });
    };

    _proto6.moveItem = function moveItem(opcode, item, before) {
      var children = this.children;
      reference.updateRef(opcode.memo, item.memo);
      reference.updateRef(opcode.value, item.value);
      opcode.retained = true;
      var currentSibling, nextSibling;

      if (before === undefined) {
        move(opcode, this.marker);
      } else {
        currentSibling = opcode.lastNode().nextSibling;
        nextSibling = before.firstNode(); // Items are moved throughout the algorithm, so there are cases where the
        // the items already happen to be siblings (e.g. an item in between was
        // moved before this move happened). Check to see if they are siblings
        // first before doing the move.

        if (currentSibling !== nextSibling) {
          move(opcode, nextSibling);
        }
      }

      opcode.index = children.length;
      children.push(opcode);
    };

    _proto6.deleteItem = function deleteItem(opcode) {

      destroyable.destroy(opcode);
      clear(opcode);
      this.opcodeMap["delete"](opcode.key);
    };

    return ListBlockOpcode;
  }(BlockOpcode);

  var UpdatingVMFrame = /*#__PURE__*/function () {
    function UpdatingVMFrame(ops, exceptionHandler) {
      this.ops = ops;
      this.exceptionHandler = exceptionHandler;
      this.current = 0;
    }

    var _proto7 = UpdatingVMFrame.prototype;

    _proto7["goto"] = function goto(index) {
      this.current = index;
    };

    _proto7.nextStatement = function nextStatement() {
      return this.ops[this.current++];
    };

    _proto7.handleException = function handleException() {
      if (this.exceptionHandler) {
        this.exceptionHandler.handleException();
      }
    };

    return UpdatingVMFrame;
  }();

  var RenderResultImpl = /*#__PURE__*/function () {
    function RenderResultImpl(env, updating, bounds, drop) {
      var _this = this;

      this.env = env;
      this.updating = updating;
      this.bounds = bounds;
      this.drop = drop;
      destroyable.associateDestroyableChild(this, drop);
      destroyable.registerDestructor(this, function () {
        return clear(_this.bounds);
      });
    }

    var _proto = RenderResultImpl.prototype;

    _proto.rerender = function rerender(_temp) {
      var _ref = _temp === void 0 ? {
        alwaysRevalidate: false
      } : _temp,
          _ref$alwaysRevalidate = _ref.alwaysRevalidate,
          alwaysRevalidate = _ref$alwaysRevalidate === void 0 ? false : _ref$alwaysRevalidate;

      var env = this.env,
          updating = this.updating;
      var vm = new UpdatingVMImpl(env, {
        alwaysRevalidate: alwaysRevalidate
      });
      vm.execute(updating, this);
    };

    _proto.parentElement = function parentElement() {
      return this.bounds.parentElement();
    };

    _proto.firstNode = function firstNode() {
      return this.bounds.firstNode();
    };

    _proto.lastNode = function lastNode() {
      return this.bounds.lastNode();
    };

    _proto.handleException = function handleException() {
      throw 'this should never happen';
    };

    return RenderResultImpl;
  }();

  var EvaluationStackImpl = /*#__PURE__*/function () {
    // fp -> sp
    function EvaluationStackImpl(stack, registers) {
      if (stack === void 0) {
        stack = [];
      }

      this.stack = stack;
      this[REGISTERS] = registers;
    }

    EvaluationStackImpl.restore = function restore(snapshot) {
      return new this(snapshot.slice(), initializeRegistersWithSP(snapshot.length - 1));
    };

    var _proto = EvaluationStackImpl.prototype;

    _proto.push = function push(value) {
      this.stack[++this[REGISTERS][vm.$sp]] = value;
    };

    _proto.dup = function dup(position) {
      if (position === void 0) {
        position = this[REGISTERS][vm.$sp];
      }

      this.stack[++this[REGISTERS][vm.$sp]] = this.stack[position];
    };

    _proto.copy = function copy(from, to) {
      this.stack[to] = this.stack[from];
    };

    _proto.pop = function pop(n) {
      if (n === void 0) {
        n = 1;
      }

      var top = this.stack[this[REGISTERS][vm.$sp]];
      this[REGISTERS][vm.$sp] -= n;
      return top;
    };

    _proto.peek = function peek(offset) {
      if (offset === void 0) {
        offset = 0;
      }

      return this.stack[this[REGISTERS][vm.$sp] - offset];
    };

    _proto.get = function get(offset, base) {
      if (base === void 0) {
        base = this[REGISTERS][vm.$fp];
      }

      return this.stack[base + offset];
    };

    _proto.set = function set(value, offset, base) {
      if (base === void 0) {
        base = this[REGISTERS][vm.$fp];
      }

      this.stack[base + offset] = value;
    };

    _proto.slice = function slice(start, end) {
      return this.stack.slice(start, end);
    };

    _proto.capture = function capture(items) {
      var end = this[REGISTERS][vm.$sp] + 1;
      var start = end - items;
      return this.stack.slice(start, end);
    };

    _proto.reset = function reset() {
      this.stack.length = 0;
    };

    _proto.toArray = function toArray() {
      return this.stack.slice(this[REGISTERS][vm.$fp], this[REGISTERS][vm.$sp] + 1);
    };

    return EvaluationStackImpl;
  }();

  function _defineProperties$4(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$4(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$4(Constructor.prototype, protoProps); if (staticProps) _defineProperties$4(Constructor, staticProps); return Constructor; }

  var _a$2, _b;

  var Stacks = function Stacks() {
    this.scope = new util.Stack();
    this.dynamicScope = new util.Stack();
    this.updating = new util.Stack();
    this.cache = new util.Stack();
    this.list = new util.Stack();
  };

  var VM = /*#__PURE__*/function () {
    /**
     * End of migrated.
     */
    function VM(runtime, _ref, elementStack, context) {
      var _this = this;

      var pc = _ref.pc,
          scope = _ref.scope,
          dynamicScope = _ref.dynamicScope,
          stack = _ref.stack;
      this.runtime = runtime;
      this.elementStack = elementStack;
      this.context = context;
      this[_a$2] = new Stacks();
      this[_b] = new util.Stack();
      this.s0 = null;
      this.s1 = null;
      this.t0 = null;
      this.t1 = null;
      this.v0 = null;
      this.resume = initVM(this.context);

      if (env.DEBUG) {
        globalContext.assertGlobalContextWasSet();
      }

      var evalStack = EvaluationStackImpl.restore(stack);
      evalStack[REGISTERS][vm.$pc] = pc;
      evalStack[REGISTERS][vm.$sp] = stack.length - 1;
      evalStack[REGISTERS][vm.$fp] = -1;
      this[HEAP] = this.program.heap;
      this[CONSTANTS] = this.program.constants;
      this.elementStack = elementStack;
      this[STACKS].scope.push(scope);
      this[STACKS].dynamicScope.push(dynamicScope);
      this[ARGS] = new VMArgumentsImpl();
      this[INNER_VM] = new LowLevelVM(evalStack, this[HEAP], runtime.program, {
        debugBefore: function debugBefore(opcode) {
          return APPEND_OPCODES.debugBefore(_this, opcode);
        },
        debugAfter: function debugAfter(state) {
          APPEND_OPCODES.debugAfter(_this, state);
        }
      }, evalStack[REGISTERS]);
      this.destructor = {};
      this[DESTROYABLE_STACK].push(this.destructor);
    }

    var _proto = VM.prototype;

    // Fetch a value from a register onto the stack
    _proto.fetch = function fetch(register) {
      var value = this.fetchValue(register);
      this.stack.push(value);
    } // Load a value from the stack into a register
    ;

    _proto.load = function load(register) {
      var value = this.stack.pop();
      this.loadValue(register, value);
    };

    _proto.fetchValue = function fetchValue(register) {
      if (vm.isLowLevelRegister(register)) {
        return this[INNER_VM].fetchRegister(register);
      }

      switch (register) {
        case vm.$s0:
          return this.s0;

        case vm.$s1:
          return this.s1;

        case vm.$t0:
          return this.t0;

        case vm.$t1:
          return this.t1;

        case vm.$v0:
          return this.v0;
      }
    } // Load a value into a register
    ;

    _proto.loadValue = function loadValue(register, value) {
      if (vm.isLowLevelRegister(register)) {
        this[INNER_VM].loadRegister(register, value);
      }

      switch (register) {
        case vm.$s0:
          this.s0 = value;
          break;

        case vm.$s1:
          this.s1 = value;
          break;

        case vm.$t0:
          this.t0 = value;
          break;

        case vm.$t1:
          this.t1 = value;
          break;

        case vm.$v0:
          this.v0 = value;
          break;
      }
    }
    /**
     * Migrated to Inner
     */
    // Start a new frame and save $ra and $fp on the stack
    ;

    _proto.pushFrame = function pushFrame() {
      this[INNER_VM].pushFrame();
    } // Restore $ra, $sp and $fp
    ;

    _proto.popFrame = function popFrame() {
      this[INNER_VM].popFrame();
    } // Jump to an address in `program`
    ;

    _proto["goto"] = function goto(offset) {
      this[INNER_VM]["goto"](offset);
    } // Save $pc into $ra, then jump to a new address in `program` (jal in MIPS)
    ;

    _proto.call = function call(handle) {
      this[INNER_VM].call(handle);
    } // Put a specific `program` address in $ra
    ;

    _proto.returnTo = function returnTo(offset) {
      this[INNER_VM].returnTo(offset);
    } // Return to the `program` address stored in $ra
    ;

    _proto["return"] = function _return() {
      this[INNER_VM]["return"]();
    };

    VM.initial = function initial(runtime, context, _ref2) {
      var handle = _ref2.handle,
          self = _ref2.self,
          dynamicScope = _ref2.dynamicScope,
          treeBuilder = _ref2.treeBuilder,
          numSymbols = _ref2.numSymbols,
          owner = _ref2.owner;
      var scope = PartialScopeImpl.root(self, numSymbols, owner);
      var state = vmState(runtime.program.heap.getaddr(handle), scope, dynamicScope);
      var vm = initVM(context)(runtime, state, treeBuilder);
      vm.pushUpdating();
      return vm;
    };

    VM.empty = function empty(runtime, _ref3, context) {
      var handle = _ref3.handle,
          treeBuilder = _ref3.treeBuilder,
          dynamicScope = _ref3.dynamicScope,
          owner = _ref3.owner;
      var vm = initVM(context)(runtime, vmState(runtime.program.heap.getaddr(handle), PartialScopeImpl.root(reference.UNDEFINED_REFERENCE, 0, owner), dynamicScope), treeBuilder);
      vm.pushUpdating();
      return vm;
    };

    _proto.compile = function compile(block) {
      var handle = util.unwrapHandle(block.compile(this.context));
      return handle;
    };

    _proto.captureState = function captureState(args, pc) {
      if (pc === void 0) {
        pc = this[INNER_VM].fetchRegister(vm.$pc);
      }

      return {
        pc: pc,
        scope: this.scope(),
        dynamicScope: this.dynamicScope(),
        stack: this.stack.capture(args)
      };
    };

    _proto.capture = function capture(args, pc) {
      if (pc === void 0) {
        pc = this[INNER_VM].fetchRegister(vm.$pc);
      }

      return new ResumableVMStateImpl(this.captureState(args, pc), this.resume);
    };

    _proto.beginCacheGroup = function beginCacheGroup(name) {
      var opcodes = this.updating();
      var guard = new JumpIfNotModifiedOpcode();
      opcodes.push(guard);
      opcodes.push(new BeginTrackFrameOpcode(name));
      this[STACKS].cache.push(guard);
      validator.beginTrackFrame(name);
    };

    _proto.commitCacheGroup = function commitCacheGroup() {
      var opcodes = this.updating();
      var guard = this[STACKS].cache.pop();
      var tag = validator.endTrackFrame();
      opcodes.push(new EndTrackFrameOpcode(guard));
      guard.finalize(tag, opcodes.length);
    };

    _proto.enter = function enter(args) {
      var updating = [];
      var state = this.capture(args);
      var block = this.elements().pushUpdatableBlock();
      var tryOpcode = new TryOpcode(state, this.runtime, block, updating);
      this.didEnter(tryOpcode);
    };

    _proto.enterItem = function enterItem(_ref4) {
      var key = _ref4.key,
          value = _ref4.value,
          memo = _ref4.memo;
      var stack = this.stack;
      var valueRef = reference.createIteratorItemRef(value);
      var memoRef = reference.createIteratorItemRef(memo);
      stack.push(valueRef);
      stack.push(memoRef);
      var state = this.capture(2);
      var block = this.elements().pushUpdatableBlock();
      var opcode = new ListItemOpcode(state, this.runtime, block, key, memoRef, valueRef);
      this.didEnter(opcode);
      return opcode;
    };

    _proto.registerItem = function registerItem(opcode) {
      this.listBlock().initializeChild(opcode);
    };

    _proto.enterList = function enterList(iterableRef, offset) {
      var updating = [];
      var addr = this[INNER_VM].target(offset);
      var state = this.capture(0, addr);
      var list = this.elements().pushBlockList(updating);
      var opcode = new ListBlockOpcode(state, this.runtime, list, updating, iterableRef);
      this[STACKS].list.push(opcode);
      this.didEnter(opcode);
    };

    _proto.didEnter = function didEnter(opcode) {
      this.associateDestroyable(opcode);
      this[DESTROYABLE_STACK].push(opcode);
      this.updateWith(opcode);
      this.pushUpdating(opcode.children);
    };

    _proto.exit = function exit() {
      this[DESTROYABLE_STACK].pop();
      this.elements().popBlock();
      this.popUpdating();
    };

    _proto.exitList = function exitList() {
      this.exit();
      this[STACKS].list.pop();
    };

    _proto.pushUpdating = function pushUpdating(list) {
      if (list === void 0) {
        list = [];
      }

      this[STACKS].updating.push(list);
    };

    _proto.popUpdating = function popUpdating() {
      return this[STACKS].updating.pop();
    };

    _proto.updateWith = function updateWith(opcode) {
      this.updating().push(opcode);
    };

    _proto.listBlock = function listBlock() {
      return this[STACKS].list.current;
    };

    _proto.associateDestroyable = function associateDestroyable(child) {
      var parent = this[DESTROYABLE_STACK].current;
      destroyable.associateDestroyableChild(parent, child);
    };

    _proto.tryUpdating = function tryUpdating() {
      return this[STACKS].updating.current;
    };

    _proto.updating = function updating() {
      return this[STACKS].updating.current;
    };

    _proto.elements = function elements() {
      return this.elementStack;
    };

    _proto.scope = function scope() {
      return this[STACKS].scope.current;
    };

    _proto.dynamicScope = function dynamicScope() {
      return this[STACKS].dynamicScope.current;
    };

    _proto.pushChildScope = function pushChildScope() {
      this[STACKS].scope.push(this.scope().child());
    };

    _proto.pushDynamicScope = function pushDynamicScope() {
      var child = this.dynamicScope().child();
      this[STACKS].dynamicScope.push(child);
      return child;
    };

    _proto.pushRootScope = function pushRootScope(size, owner) {
      var scope = PartialScopeImpl.sized(size, owner);
      this[STACKS].scope.push(scope);
      return scope;
    };

    _proto.pushScope = function pushScope(scope) {
      this[STACKS].scope.push(scope);
    };

    _proto.popScope = function popScope() {
      this[STACKS].scope.pop();
    };

    _proto.popDynamicScope = function popDynamicScope() {
      this[STACKS].dynamicScope.pop();
    } /// SCOPE HELPERS
    ;

    _proto.getOwner = function getOwner() {
      return this.scope().owner;
    };

    _proto.getSelf = function getSelf() {
      return this.scope().getSelf();
    };

    _proto.referenceForSymbol = function referenceForSymbol(symbol) {
      return this.scope().getSymbol(symbol);
    } /// EXECUTION
    ;

    _proto.execute = function execute(initialize) {
      if (env.DEBUG) {
        var hasErrored = true;

        try {
          var value = this._execute(initialize); // using a boolean here to avoid breaking ergonomics of "pause on uncaught exceptions"
          // which would happen with a `catch` + `throw`


          hasErrored = false;
          return value;
        } finally {
          if (hasErrored) {
            // If any existing blocks are open, due to an error or something like
            // that, we need to close them all and clean things up properly.
            var elements = this.elements();

            while (elements.hasBlocks) {
              elements.popBlock();
            } // eslint-disable-next-line no-console


            console.error("\n\nError occurred:\n\n" + validator.resetTracking() + "\n\n");
          }
        }
      } else {
        return this._execute(initialize);
      }
    };

    _proto._execute = function _execute(initialize) {

      if (initialize) initialize(this);
      var result;

      while (true) {
        result = this.next();
        if (result.done) break;
      }

      return result.value;
    };

    _proto.next = function next() {
      var env = this.env,
          elementStack = this.elementStack;
      var opcode = this[INNER_VM].nextStatement();
      var result;

      if (opcode !== null) {
        this[INNER_VM].evaluateOuter(opcode, this);
        result = {
          done: false,
          value: null
        };
      } else {
        // Unload the stack
        this.stack.reset();
        result = {
          done: true,
          value: new RenderResultImpl(env, this.popUpdating(), elementStack.popBlock(), this.destructor)
        };
      }

      return result;
    };

    _proto.bindDynamicScope = function bindDynamicScope(names) {
      var scope = this.dynamicScope();

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i];
        scope.set(name, this.stack.pop());
      }
    };

    _createClass$4(VM, [{
      key: "stack",
      get: function get() {
        return this[INNER_VM].stack;
      }
      /* Registers */

    }, {
      key: "pc",
      get: function get() {
        return this[INNER_VM].fetchRegister(vm.$pc);
      }
    }, {
      key: "program",
      get: function get() {
        return this.runtime.program;
      }
    }, {
      key: "env",
      get: function get() {
        return this.runtime.env;
      }
    }]);

    return VM;
  }();
  _a$2 = STACKS, _b = DESTROYABLE_STACK;

  function vmState(pc, scope, dynamicScope) {
    return {
      pc: pc,
      scope: scope,
      dynamicScope: dynamicScope,
      stack: []
    };
  }

  function initVM(context) {
    return function (runtime, state, builder) {
      return new VM(runtime, state, builder, context);
    };
  }

  var TemplateIteratorImpl = /*#__PURE__*/function () {
    function TemplateIteratorImpl(vm) {
      this.vm = vm;
    }

    var _proto = TemplateIteratorImpl.prototype;

    _proto.next = function next() {
      return this.vm.next();
    };

    _proto.sync = function sync() {
      var _this = this;

      if (env.DEBUG) {
        return validator.runInTrackingTransaction(function () {
          return _this.vm.execute();
        }, '- While rendering:');
      } else {
        return this.vm.execute();
      }
    };

    return TemplateIteratorImpl;
  }();

  function renderSync(env, iterator) {
    var result;
    inTransaction(env, function () {
      return result = iterator.sync();
    });
    return result;
  }
  function renderMain(runtime, context, owner, self, treeBuilder, layout, dynamicScope) {
    if (dynamicScope === void 0) {
      dynamicScope = new DynamicScopeImpl();
    }

    var handle = util.unwrapHandle(layout.compile(context));
    var numSymbols = layout.symbolTable.symbols.length;
    var vm = VM.initial(runtime, context, {
      self: self,
      dynamicScope: dynamicScope,
      treeBuilder: treeBuilder,
      handle: handle,
      numSymbols: numSymbols,
      owner: owner
    });
    return new TemplateIteratorImpl(vm);
  }

  function renderInvocation(vm, context, owner, definition, args) {
    // Get a list of tuples of argument names and references, like
    // [['title', reference], ['name', reference]]
    var argList = Object.keys(args).map(function (key) {
      return [key, args[key]];
    });
    var blockNames = ['main', 'else', 'attrs']; // Prefix argument names with `@` symbol

    var argNames = argList.map(function (_ref) {
      var name = _ref[0];
      return "@" + name;
    });
    var reified = vm[CONSTANTS].component(definition, owner);
    vm.pushFrame(); // Push blocks on to the stack, three stack values per block

    for (var i = 0; i < 3 * blockNames.length; i++) {
      vm.stack.push(null);
    }

    vm.stack.push(null); // For each argument, push its backing reference on to the stack

    argList.forEach(function (_ref2) {
      var reference = _ref2[1];
      vm.stack.push(reference);
    }); // Configure VM based on blocks and args just pushed on to the stack.

    vm[ARGS].setup(vm.stack, argNames, blockNames, 0, true);
    var compilable = reified.compilable;
    var layoutHandle = util.unwrapHandle(compilable.compile(context));
    var invocation = {
      handle: layoutHandle,
      symbolTable: compilable.symbolTable
    }; // Needed for the Op.Main opcode: arguments, component invocation object, and
    // component definition.

    vm.stack.push(vm[ARGS]);
    vm.stack.push(invocation);
    vm.stack.push(reified);
    return new TemplateIteratorImpl(vm);
  }

  function renderComponent(runtime, treeBuilder, context, owner, definition, args, dynamicScope) {
    if (args === void 0) {
      args = {};
    }

    if (dynamicScope === void 0) {
      dynamicScope = new DynamicScopeImpl();
    }

    var vm = VM.empty(runtime, {
      treeBuilder: treeBuilder,
      handle: context.stdlib.main,
      dynamicScope: dynamicScope,
      owner: owner
    }, context);
    return renderInvocation(vm, context, owner, definition, recordToReference(args));
  }

  function recordToReference(record) {
    var root = reference.createConstRef(record, 'args');
    return Object.keys(record).reduce(function (acc, key) {
      acc[key] = reference.childRefFor(root, key);
      return acc;
    }, {});
  }

  function _defineProperties$5(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$5(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$5(Constructor.prototype, protoProps); if (staticProps) _defineProperties$5(Constructor, staticProps); return Constructor; }

  function _inheritsLoose$6(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  var SERIALIZATION_FIRST_NODE_STRING = '%+b:0%';
  function isSerializationFirstNode(node) {
    return node.nodeValue === SERIALIZATION_FIRST_NODE_STRING;
  }
  var RehydratingCursor = /*#__PURE__*/function (_CursorImpl) {
    _inheritsLoose$6(RehydratingCursor, _CursorImpl);

    function RehydratingCursor(element, nextSibling, startingBlockDepth) {
      var _this;

      _this = _CursorImpl.call(this, element, nextSibling) || this;
      _this.startingBlockDepth = startingBlockDepth;
      _this.candidate = null;
      _this.injectedOmittedNode = false;
      _this.openBlockDepth = startingBlockDepth - 1;
      return _this;
    }

    return RehydratingCursor;
  }(CursorImpl);
  var RehydrateBuilder = /*#__PURE__*/function (_NewElementBuilder) {
    _inheritsLoose$6(RehydrateBuilder, _NewElementBuilder);

    function RehydrateBuilder(env, parentNode, nextSibling) {
      var _this2;

      _this2 = _NewElementBuilder.call(this, env, parentNode, nextSibling) || this;
      _this2.unmatchedAttributes = null;
      _this2.blockDepth = 0;
      if (nextSibling) throw new Error('Rehydration with nextSibling not supported');
      var node = _this2.currentCursor.element.firstChild;

      while (node !== null) {
        if (isOpenBlock(node)) {
          break;
        }

        node = node.nextSibling;
      }
      _this2.candidate = node;
      var startingBlockOffset = getBlockDepth(node);

      if (startingBlockOffset !== 0) {
        // We are rehydrating from a partial tree and not the root component
        // We need to add an extra block before the first block to rehydrate correctly
        // The extra block is needed since the renderComponent API creates a synthetic component invocation which generates the extra block
        var newBlockDepth = startingBlockOffset - 1;

        var newCandidate = _this2.dom.createComment("%+b:" + newBlockDepth + "%");

        node.parentNode.insertBefore(newCandidate, _this2.candidate);
        var closingNode = node.nextSibling;

        while (closingNode !== null) {
          if (isCloseBlock(closingNode) && getBlockDepth(closingNode) === startingBlockOffset) {
            break;
          }

          closingNode = closingNode.nextSibling;
        }

        var newClosingBlock = _this2.dom.createComment("%-b:" + newBlockDepth + "%");

        node.parentNode.insertBefore(newClosingBlock, closingNode.nextSibling);
        _this2.candidate = newCandidate;
        _this2.startingBlockOffset = newBlockDepth;
      } else {
        _this2.startingBlockOffset = 0;
      }

      return _this2;
    }

    var _proto = RehydrateBuilder.prototype;

    _proto.disableRehydration = function disableRehydration(nextSibling) {
      var currentCursor = this.currentCursor; // rehydration will be disabled until we either:
      // * hit popElement (and return to using the parent elements cursor)
      // * hit closeBlock and the next sibling is a close block comment
      //   matching the expected openBlockDepth

      currentCursor.candidate = null;
      currentCursor.nextSibling = nextSibling;
    };

    _proto.enableRehydration = function enableRehydration(candidate) {
      var currentCursor = this.currentCursor;
      currentCursor.candidate = candidate;
      currentCursor.nextSibling = null;
    };

    _proto.pushElement = function pushElement(element, nextSibling) {
      if (nextSibling === void 0) {
        nextSibling = null;
      }

      var cursor = new RehydratingCursor(element, nextSibling, this.blockDepth || 0);
      /**
       * <div>   <---------------  currentCursor.element
       *   <!--%+b:1%--> <-------  would have been removed during openBlock
       *   <div> <---------------  currentCursor.candidate -> cursor.element
       *     <!--%+b:2%--> <-----  currentCursor.candidate.firstChild -> cursor.candidate
       *     Foo
       *     <!--%-b:2%-->
       *   </div>
       *   <!--%-b:1%-->  <------  becomes currentCursor.candidate
       */

      if (this.candidate !== null) {
        cursor.candidate = element.firstChild;
        this.candidate = element.nextSibling;
      }

      this[CURSOR_STACK].push(cursor);
    } // clears until the end of the current container
    // either the current open block or higher
    ;

    _proto.clearMismatch = function clearMismatch(candidate) {
      var current = candidate;
      var currentCursor = this.currentCursor;

      if (currentCursor !== null) {
        var openBlockDepth = currentCursor.openBlockDepth;

        if (openBlockDepth >= currentCursor.startingBlockDepth) {
          while (current) {
            if (isCloseBlock(current)) {
              var closeBlockDepth = getBlockDepthWithOffset(current, this.startingBlockOffset);

              if (openBlockDepth >= closeBlockDepth) {
                break;
              }
            }

            current = this.remove(current);
          }
        } else {
          while (current !== null) {
            current = this.remove(current);
          }
        } // current cursor parentNode should be openCandidate if element
        // or openCandidate.parentNode if comment


        this.disableRehydration(current);
      }
    };

    _proto.__openBlock = function __openBlock() {
      var currentCursor = this.currentCursor;
      if (currentCursor === null) return;
      var blockDepth = this.blockDepth;
      this.blockDepth++;
      var candidate = currentCursor.candidate;
      if (candidate === null) return;
      var tagName = currentCursor.element.tagName;

      if (isOpenBlock(candidate) && getBlockDepthWithOffset(candidate, this.startingBlockOffset) === blockDepth) {
        this.candidate = this.remove(candidate);
        currentCursor.openBlockDepth = blockDepth;
      } else if (tagName !== 'TITLE' && tagName !== 'SCRIPT' && tagName !== 'STYLE') {
        this.clearMismatch(candidate);
      }
    };

    _proto.__closeBlock = function __closeBlock() {
      var currentCursor = this.currentCursor;
      if (currentCursor === null) return; // openBlock is the last rehydrated open block

      var openBlockDepth = currentCursor.openBlockDepth; // this currently is the expected next open block depth

      this.blockDepth--;
      var candidate = currentCursor.candidate;
      var isRehydrating = false;

      if (candidate !== null) {
        isRehydrating = true; //assert(
        //  openBlockDepth === this.blockDepth,
        //  'when rehydrating, openBlockDepth should match this.blockDepth here'
        //);

        if (isCloseBlock(candidate) && getBlockDepthWithOffset(candidate, this.startingBlockOffset) === openBlockDepth) {
          var nextSibling = this.remove(candidate);
          this.candidate = nextSibling;
          currentCursor.openBlockDepth--;
        } else {
          // close the block and clear mismatch in parent container
          // we will be either at the end of the element
          // or at the end of our containing block
          this.clearMismatch(candidate);
          isRehydrating = false;
        }
      }

      if (isRehydrating === false) {
        // check if nextSibling matches our expected close block
        // if so, we remove the close block comment and
        // restore rehydration after clearMismatch disabled
        var _nextSibling = currentCursor.nextSibling;

        if (_nextSibling !== null && isCloseBlock(_nextSibling) && getBlockDepthWithOffset(_nextSibling, this.startingBlockOffset) === this.blockDepth) {
          // restore rehydration state
          var _candidate2 = this.remove(_nextSibling);

          this.enableRehydration(_candidate2);
          currentCursor.openBlockDepth--;
        }
      }
    };

    _proto.__appendNode = function __appendNode(node) {
      var candidate = this.candidate; // This code path is only used when inserting precisely one node. It needs more
      // comparison logic, but we can probably lean on the cases where this code path
      // is actually used.

      if (candidate) {
        return candidate;
      } else {
        return _NewElementBuilder.prototype.__appendNode.call(this, node);
      }
    };

    _proto.__appendHTML = function __appendHTML(html) {
      var candidateBounds = this.markerBounds();

      if (candidateBounds) {
        var first = candidateBounds.firstNode();
        var last = candidateBounds.lastNode();
        var newBounds = new ConcreteBounds(this.element, first.nextSibling, last.previousSibling);
        var possibleEmptyMarker = this.remove(first);
        this.remove(last);

        if (possibleEmptyMarker !== null && isEmpty$1(possibleEmptyMarker)) {
          this.candidate = this.remove(possibleEmptyMarker);

          if (this.candidate !== null) {
            this.clearMismatch(this.candidate);
          }
        }

        return newBounds;
      } else {
        return _NewElementBuilder.prototype.__appendHTML.call(this, html);
      }
    };

    _proto.remove = function remove(node) {
      var element = node.parentNode;
      var next = node.nextSibling;
      element.removeChild(node);
      return next;
    };

    _proto.markerBounds = function markerBounds() {
      var _candidate = this.candidate;

      if (_candidate && isMarker(_candidate)) {
        var first = _candidate;
        var last = first.nextSibling;

        while (last && !isMarker(last)) {
          last = last.nextSibling;
        }

        return new ConcreteBounds(this.element, first, last);
      } else {
        return null;
      }
    };

    _proto.__appendText = function __appendText(string) {
      var candidate = this.candidate;

      if (candidate) {
        if (isTextNode(candidate)) {
          if (candidate.nodeValue !== string) {
            candidate.nodeValue = string;
          }

          this.candidate = candidate.nextSibling;
          return candidate;
        } else if (isSeparator(candidate)) {
          this.candidate = this.remove(candidate);
          return this.__appendText(string);
        } else if (isEmpty$1(candidate) && string === '') {
          this.candidate = this.remove(candidate);
          return this.__appendText(string);
        } else {
          this.clearMismatch(candidate);
          return _NewElementBuilder.prototype.__appendText.call(this, string);
        }
      } else {
        return _NewElementBuilder.prototype.__appendText.call(this, string);
      }
    };

    _proto.__appendComment = function __appendComment(string) {
      var _candidate = this.candidate;

      if (_candidate && isComment(_candidate)) {
        if (_candidate.nodeValue !== string) {
          _candidate.nodeValue = string;
        }

        this.candidate = _candidate.nextSibling;
        return _candidate;
      } else if (_candidate) {
        this.clearMismatch(_candidate);
      }

      return _NewElementBuilder.prototype.__appendComment.call(this, string);
    };

    _proto.__openElement = function __openElement(tag) {
      var _candidate = this.candidate;

      if (_candidate && isElement(_candidate) && isSameNodeType(_candidate, tag)) {
        this.unmatchedAttributes = [].slice.call(_candidate.attributes);
        return _candidate;
      } else if (_candidate) {
        if (isElement(_candidate) && _candidate.tagName === 'TBODY') {
          this.pushElement(_candidate, null);
          this.currentCursor.injectedOmittedNode = true;
          return this.__openElement(tag);
        }

        this.clearMismatch(_candidate);
      }

      return _NewElementBuilder.prototype.__openElement.call(this, tag);
    };

    _proto.__setAttribute = function __setAttribute(name, value, namespace) {
      var unmatched = this.unmatchedAttributes;

      if (unmatched) {
        var attr = findByName(unmatched, name);

        if (attr) {
          if (attr.value !== value) {
            attr.value = value;
          }

          unmatched.splice(unmatched.indexOf(attr), 1);
          return;
        }
      }

      return _NewElementBuilder.prototype.__setAttribute.call(this, name, value, namespace);
    };

    _proto.__setProperty = function __setProperty(name, value) {
      var unmatched = this.unmatchedAttributes;

      if (unmatched) {
        var attr = findByName(unmatched, name);

        if (attr) {
          if (attr.value !== value) {
            attr.value = value;
          }

          unmatched.splice(unmatched.indexOf(attr), 1);
          return;
        }
      }

      return _NewElementBuilder.prototype.__setProperty.call(this, name, value);
    };

    _proto.__flushElement = function __flushElement(parent, constructing) {
      var unmatched = this.unmatchedAttributes;

      if (unmatched) {
        for (var i = 0; i < unmatched.length; i++) {
          this.constructing.removeAttribute(unmatched[i].name);
        }

        this.unmatchedAttributes = null;
      } else {
        _NewElementBuilder.prototype.__flushElement.call(this, parent, constructing);
      }
    };

    _proto.willCloseElement = function willCloseElement() {
      var candidate = this.candidate,
          currentCursor = this.currentCursor;

      if (candidate !== null) {
        this.clearMismatch(candidate);
      }

      if (currentCursor && currentCursor.injectedOmittedNode) {
        this.popElement();
      }

      _NewElementBuilder.prototype.willCloseElement.call(this);
    };

    _proto.getMarker = function getMarker(element, guid) {
      var marker = element.querySelector("script[glmr=\"" + guid + "\"]");

      if (marker) {
        return marker;
      }

      return null;
    };

    _proto.__pushRemoteElement = function __pushRemoteElement(element, cursorId, insertBefore) {
      var marker = this.getMarker(element, cursorId);

      if (insertBefore === undefined) {
        while (element.firstChild !== null && element.firstChild !== marker) {
          this.remove(element.firstChild);
        }

        insertBefore = null;
      }

      var cursor = new RehydratingCursor(element, null, this.blockDepth);
      this[CURSOR_STACK].push(cursor);

      if (marker === null) {
        this.disableRehydration(insertBefore);
      } else {
        this.candidate = this.remove(marker);
      }

      var block = new RemoteLiveBlock(element);
      return this.pushLiveBlock(block, true);
    };

    _proto.didAppendBounds = function didAppendBounds(bounds) {
      _NewElementBuilder.prototype.didAppendBounds.call(this, bounds);

      if (this.candidate) {
        var last = bounds.lastNode();
        this.candidate = last && last.nextSibling;
      }

      return bounds;
    };

    _createClass$5(RehydrateBuilder, [{
      key: "currentCursor",
      get: function get() {
        return this[CURSOR_STACK].current;
      }
    }, {
      key: "candidate",
      get: function get() {
        if (this.currentCursor) {
          return this.currentCursor.candidate;
        }

        return null;
      },
      set: function set(node) {
        var currentCursor = this.currentCursor;
        currentCursor.candidate = node;
      }
    }]);

    return RehydrateBuilder;
  }(NewElementBuilder);

  function isTextNode(node) {
    return node.nodeType === 3;
  }

  function isComment(node) {
    return node.nodeType === 8;
  }

  function isOpenBlock(node) {
    return node.nodeType === 8
    /* COMMENT_NODE */
    && node.nodeValue.lastIndexOf('%+b:', 0) === 0;
  }

  function isCloseBlock(node) {
    return node.nodeType === 8
    /* COMMENT_NODE */
    && node.nodeValue.lastIndexOf('%-b:', 0) === 0;
  }

  function getBlockDepth(node) {
    return parseInt(node.nodeValue.slice(4), 10);
  }

  function getBlockDepthWithOffset(node, offset) {
    return getBlockDepth(node) - offset;
  }

  function isElement(node) {
    return node.nodeType === 1;
  }

  function isMarker(node) {
    return node.nodeType === 8 && node.nodeValue === '%glmr%';
  }

  function isSeparator(node) {
    return node.nodeType === 8 && node.nodeValue === '%|%';
  }

  function isEmpty$1(node) {
    return node.nodeType === 8 && node.nodeValue === '% %';
  }

  function isSameNodeType(candidate, tag) {
    if (candidate.namespaceURI === "http://www.w3.org/2000/svg"
    /* SVG */
    ) {
        return candidate.tagName === tag;
      }

    return candidate.tagName === tag.toUpperCase();
  }

  function findByName(array, name) {
    for (var i = 0; i < array.length; i++) {
      var attr = array[i];
      if (attr.name === name) return attr;
    }

    return undefined;
  }

  function rehydrationBuilder(env, cursor) {
    return RehydrateBuilder.forInitialRender(env, cursor);
  }

  function _defineProperties$6(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$6(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$6(Constructor.prototype, protoProps); if (staticProps) _defineProperties$6(Constructor, staticProps); return Constructor; }
  var ARGS_CACHES = env.DEBUG ? new WeakMap() : undefined;

  function getArgs(proxy) {
    return validator.getValue(env.DEBUG ? ARGS_CACHES.get(proxy) : proxy.argsCache);
  }

  var SimpleArgsProxy = /*#__PURE__*/function () {
    function SimpleArgsProxy(context, computeArgs) {
      if (computeArgs === void 0) {
        computeArgs = function computeArgs() {
          return EMPTY_ARGS;
        };
      }

      var argsCache = validator.createCache(function () {
        return computeArgs(context);
      });

      if (env.DEBUG) {
        ARGS_CACHES.set(this, argsCache);
        Object.freeze(this);
      } else {
        this.argsCache = argsCache;
      }
    }

    _createClass$6(SimpleArgsProxy, [{
      key: "named",
      get: function get() {
        return getArgs(this).named || EMPTY_NAMED;
      }
    }, {
      key: "positional",
      get: function get() {
        return getArgs(this).positional || EMPTY_POSITIONAL;
      }
    }]);

    return SimpleArgsProxy;
  }(); ////////////


  function invokeHelper(context, definition, computeArgs) {
    if (env.DEBUG && (typeof context !== 'object' || context === null)) {
      throw new Error("Expected a context object to be passed as the first parameter to invokeHelper, got " + context);
    }

    var owner$1 = owner.getOwner(context);
    var internalManager = manager.getInternalHelperManager(definition); // TODO: figure out why assert isn't using the TS assert thing

    if (env.DEBUG && !internalManager) {
      throw new Error("Expected a helper definition to be passed as the second parameter to invokeHelper, but no helper manager was found. The definition value that was passed was `" + util.debugToString(definition) + "`. Did you use setHelperManager to associate a helper manager with this value?");
    }

    if (env.DEBUG && typeof internalManager === 'function') {
      throw new Error('Found a helper manager, but it was an internal built-in helper manager. `invokeHelper` does not support internal helpers yet.');
    }

    var manager$1 = internalManager.getDelegateFor(owner$1);
    var args = new SimpleArgsProxy(context, computeArgs);
    var bucket = manager$1.createHelper(definition, args);
    var cache;

    if (manager.hasValue(manager$1)) {
      cache = validator.createCache(function () {
        if (env.DEBUG && (destroyable.isDestroying(cache) || destroyable.isDestroyed(cache))) {
          throw new Error("You attempted to get the value of a helper after the helper was destroyed, which is not allowed");
        }

        return manager$1.getValue(bucket);
      });
      destroyable.associateDestroyableChild(context, cache);
    } else {
      throw new Error('TODO: unreachable, to be implemented with hasScheduledEffect');
    }

    if (manager.hasDestroyable(manager$1)) {
      var destroyable$1 = manager$1.getDestroyable(bucket);
      destroyable.associateDestroyableChild(cache, destroyable$1);
    }

    return cache;
  }

  function internalHelper(helper) {
    return manager.setInternalHelperManager(helper, {});
  }

  var context = util.buildUntouchableThis('`fn` helper');
  /**
    The `fn` helper allows you to ensure a function that you are passing off
    to another component, helper, or modifier has access to arguments that are
    available in the template.

    For example, if you have an `each` helper looping over a number of items, you
    may need to pass a function that expects to receive the item as an argument
    to a component invoked within the loop. Here's how you could use the `fn`
    helper to pass both the function and its arguments together:

      ```app/templates/components/items-listing.hbs
    {{#each @items as |item|}}
      <DisplayItem @item=item @select={{fn this.handleSelected item}} />
    {{/each}}
    ```

    ```app/components/items-list.js
    import Component from '@glimmer/component';
    import { action } from '@ember/object';

    export default class ItemsList extends Component {
      handleSelected = (item) => {
        // ...snip...
      }
    }
    ```

    In this case the `display-item` component will receive a normal function
    that it can invoke. When it invokes the function, the `handleSelected`
    function will receive the `item` and any arguments passed, thanks to the
    `fn` helper.

    Let's take look at what that means in a couple circumstances:

    - When invoked as `this.args.select()` the `handleSelected` function will
      receive the `item` from the loop as its first and only argument.
    - When invoked as `this.args.select('foo')` the `handleSelected` function
      will receive the `item` from the loop as its first argument and the
      string `'foo'` as its second argument.

    In the example above, we used an arrow function to ensure that
    `handleSelected` is properly bound to the `items-list`, but let's explore what
    happens if we left out the arrow function:

    ```app/components/items-list.js
    import Component from '@glimmer/component';

    export default class ItemsList extends Component {
      handleSelected(item) {
        // ...snip...
      }
    }
    ```

    In this example, when `handleSelected` is invoked inside the `display-item`
    component, it will **not** have access to the component instance. In other
    words, it will have no `this` context, so please make sure your functions
    are bound (via an arrow function or other means) before passing into `fn`!

    See also [partial application](https://en.wikipedia.org/wiki/Partial_application).

    @method fn
    @public
  */

  var fn = internalHelper(function (_ref) {
    var positional = _ref.positional;
    var callbackRef = positional[0];
    if (env.DEBUG) assertCallbackIsFn(callbackRef);
    return reference.createComputeRef(function () {
      return function () {
        var _reifyPositional = runtime.reifyPositional(positional),
            fn = _reifyPositional[0],
            args = _reifyPositional.slice(1);

        if (env.DEBUG) assertCallbackIsFn(callbackRef);

        for (var _len = arguments.length, invocationArgs = new Array(_len), _key = 0; _key < _len; _key++) {
          invocationArgs[_key] = arguments[_key];
        }

        if (reference.isInvokableRef(callbackRef)) {
          var value = args.length > 0 ? args[0] : invocationArgs[0];
          return reference.updateRef(callbackRef, value);
        } else {
          return fn.call.apply(fn, [context].concat(args, invocationArgs));
        }
      };
    }, null, 'fn');
  });

  function assertCallbackIsFn(callbackRef) {
    if (!(callbackRef && (reference.isInvokableRef(callbackRef) || typeof reference.valueForRef(callbackRef) === 'function'))) {
      throw new Error("You must pass a function as the `fn` helper's first argument, you passed " + (callbackRef ? reference.valueForRef(callbackRef) : callbackRef) + ". While rendering:\n\n" + (callbackRef === null || callbackRef === void 0 ? void 0 : callbackRef.debugLabel));
    }
  }

  var wrapHashProxy;

  if (env.DEBUG) {
    wrapHashProxy = function wrapHashProxy(hash) {
      return new Proxy(hash, {
        set: function set(target, key, value) {
          globalContext.deprecate("You set the '" + String(key) + "' property on a {{hash}} object. Setting properties on objects generated by {{hash}} is deprecated. Please update to use an object created with a tracked property or getter, or with a custom helper.", false, {
            id: 'setting-on-hash'
          });
          target[key] = value;
          return true;
        }
      });
    };
  }
  /**
     Use the `{{hash}}` helper to create a hash to pass as an option to your
     components. This is specially useful for contextual components where you can
     just yield a hash:

     ```handlebars
     {{yield (hash
        name='Sarah'
        title=office
     )}}
     ```

     Would result in an object such as:

     ```js
     { name: 'Sarah', title: this.get('office') }
     ```

     Where the `title` is bound to updates of the `office` property.

     Note that the hash is an empty object with no prototype chain, therefore
     common methods like `toString` are not available in the resulting hash.
     If you need to use such a method, you can use the `call` or `apply`
     approach:

     ```js
     function toString(obj) {
       return Object.prototype.toString.apply(obj);
     }
     ```

     @method hash
     @param {Object} options
     @return {Object} Hash
     @public
   */


  var hash = internalHelper(function (_ref) {
    var named = _ref.named;
    var ref = reference.createComputeRef(function () {
      var hash = runtime.reifyNamed(named);

      if (env.DEBUG && util.HAS_NATIVE_PROXY) {
        hash = wrapHashProxy(hash);
      }

      return hash;
    }, null, 'hash'); // Setup the children so that templates can bypass getting the value of
    // the reference and treat children lazily

    var children = new Map();

    for (var name in named) {
      children.set(name, named[name]);
    }

    ref.children = children;
    return ref;
  });

  /**
     Use the `{{array}}` helper to create an array to pass as an option to your
     components.

     ```handlebars
     <MyComponent @people={{array
       'Tom Dale'
       'Yehuda Katz'
       this.myOtherPerson}}
     />
     ```
      or
     ```handlebars
     {{my-component people=(array
       'Tom Dale'
       'Yehuda Katz'
       this.myOtherPerson)
     }}
     ```

     Would result in an object such as:

     ```js
     ['Tom Dale', 'Yehuda Katz', this.get('myOtherPerson')]
     ```

     Where the 3rd item in the array is bound to updates of the `myOtherPerson` property.

     @method array
     @param {Array} options
     @return {Array} Array
     @public
   */

  var array = internalHelper(function (_ref) {
    var positional = _ref.positional;
    return reference.createComputeRef(function () {
      return runtime.reifyPositional(positional);
    }, null, 'array');
  });

  /**
    Dynamically look up a property on an object. The second argument to `{{get}}`
    should have a string value, although it can be bound.

    For example, these two usages are equivalent:

    ```app/components/developer-detail.js
    import Component from '@glimmer/component';
    import { tracked } from '@glimmer/tracking';

    export default class extends Component {
      @tracked developer = {
        name: "Sandi Metz",
        language: "Ruby"
      }
    }
    ```

    ```handlebars
    {{this.developer.name}}
    {{get this.developer "name"}}
    ```

    If there were several facts about a person, the `{{get}}` helper can dynamically
    pick one:

    ```app/templates/application.hbs
    <DeveloperDetail @factName="language" />
    ```

    ```handlebars
    {{get this.developer @factName}}
    ```

    For a more complex example, this template would allow the user to switch
    between showing the user's height and weight with a click:

    ```app/components/developer-detail.js
    import Component from '@glimmer/component';
    import { tracked } from '@glimmer/tracking';

    export default class extends Component {
      @tracked developer = {
        name: "Sandi Metz",
        language: "Ruby"
      }

      @tracked currentFact = 'name'

      showFact = (fact) => {
        this.currentFact = fact;
      }
    }
    ```

    ```app/components/developer-detail.js
    {{get this.developer this.currentFact}}

    <button {{on 'click' (fn this.showFact "name")}}>Show name</button>
    <button {{on 'click' (fn this.showFact "language")}}>Show language</button>
    ```

    The `{{get}}` helper can also respect mutable values itself. For example:

    ```app/components/developer-detail.js
    <Input @value={{mut (get this.person this.currentFact)}} />

    <button {{on 'click' (fn this.showFact "name")}}>Show name</button>
    <button {{on 'click' (fn this.showFact "language")}}>Show language</button>
    ```

    Would allow the user to swap what fact is being displayed, and also edit
    that fact via a two-way mutable binding.

    @public
    @method get
   */

  var get = internalHelper(function (_ref) {
    var positional = _ref.positional;

    var _a, _b;

    var sourceRef = (_a = positional[0]) !== null && _a !== void 0 ? _a : reference.UNDEFINED_REFERENCE;
    var pathRef = (_b = positional[1]) !== null && _b !== void 0 ? _b : reference.UNDEFINED_REFERENCE;
    return reference.createComputeRef(function () {
      var source = reference.valueForRef(sourceRef);

      if (util.isDict(source)) {
        return globalContext.getPath(source, String(reference.valueForRef(pathRef)));
      }
    }, function (value) {
      var source = reference.valueForRef(sourceRef);

      if (util.isDict(source)) {
        return globalContext.setPath(source, String(reference.valueForRef(pathRef)), value);
      }
    }, 'get');
  });

  var isEmpty$2 = function isEmpty(value) {
    return value === null || value === undefined || typeof value.toString !== 'function';
  };

  var normalizeTextValue = function normalizeTextValue(value) {
    if (isEmpty$2(value)) {
      return '';
    }

    return String(value);
  };
  /**
    Concatenates the given arguments into a string.

    Example:

    ```handlebars
    {{some-component name=(concat firstName " " lastName)}}

    {{! would pass name="<first name value> <last name value>" to the component}}
    ```

    or for angle bracket invocation, you actually don't need concat at all.

    ```handlebars
    <SomeComponent @name="{{firstName}} {{lastName}}" />
    ```

    @public
    @method concat
  */


  var concat = internalHelper(function (_ref) {
    var positional = _ref.positional;
    return reference.createComputeRef(function () {
      return runtime.reifyPositional(positional).map(normalizeTextValue).join('');
    }, null, 'concat');
  });

  function _defineProperties$7(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$7(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$7(Constructor.prototype, protoProps); if (staticProps) _defineProperties$7(Constructor, staticProps); return Constructor; }
  var untouchableContext = util.buildUntouchableThis('`on` modifier');
  /*
    Internet Explorer 11 does not support `once` and also does not support
    passing `eventOptions`. In some situations it then throws a weird script
    error, like:

    ```
    Could not complete the operation due to error 80020101
    ```

    This flag determines, whether `{ once: true }` and thus also event options in
    general are supported.
  */

  var SUPPORTS_EVENT_OPTIONS = function () {
    try {
      var div = document.createElement('div');
      var counter = 0;
      div.addEventListener('click', function () {
        return counter++;
      }, {
        once: true
      });
      var event;

      if (typeof Event === 'function') {
        event = new Event('click');
      } else {
        event = document.createEvent('Event');
        event.initEvent('click', true, true);
      }

      div.dispatchEvent(event);
      div.dispatchEvent(event);
      return counter === 1;
    } catch (error) {
      return false;
    }
  }();

  var OnModifierState = /*#__PURE__*/function () {
    function OnModifierState(element, args) {
      this.tag = validator.createUpdatableTag();
      this.shouldUpdate = true;
      this.element = element;
      this.args = args;
    }

    var _proto = OnModifierState.prototype;

    _proto.updateFromArgs = function updateFromArgs() {
      var args = this.args;

      var _reifyNamed = runtime.reifyNamed(args.named),
          once = _reifyNamed.once,
          passive = _reifyNamed.passive,
          capture = _reifyNamed.capture;

      if (once !== this.once) {
        this.once = once;
        this.shouldUpdate = true;
      }

      if (passive !== this.passive) {
        this.passive = passive;
        this.shouldUpdate = true;
      }

      if (capture !== this.capture) {
        this.capture = capture;
        this.shouldUpdate = true;
      }

      var options; // we want to handle both `true` and `false` because both have a meaning:
      // https://bugs.chromium.org/p/chromium/issues/detail?id=770208

      if (once !== undefined || passive !== undefined || capture !== undefined) {
        options = this.options = {
          once: once,
          passive: passive,
          capture: capture
        };
      } else {
        this.options = undefined;
      }

      if (env.DEBUG && (args.positional[0] === undefined || typeof reference.valueForRef(args.positional[0]) !== 'string')) {
        throw new Error('You must pass a valid DOM event name as the first argument to the `on` modifier');
      }

      var eventName = reference.valueForRef(args.positional[0]);

      if (eventName !== this.eventName) {
        this.eventName = eventName;
        this.shouldUpdate = true;
      }

      var userProvidedCallbackReference = args.positional[1];

      if (env.DEBUG) {
        if (args.positional[1] === undefined) {
          throw new Error("You must pass a function as the second argument to the `on` modifier.");
        }

        var value = reference.valueForRef(userProvidedCallbackReference);

        if (typeof value !== 'function') {
          throw new Error("You must pass a function as the second argument to the `on` modifier; you passed " + (value === null ? 'null' : typeof value) + ". While rendering:\n\n" + userProvidedCallbackReference.debugLabel);
        }
      }

      var userProvidedCallback = reference.valueForRef(userProvidedCallbackReference);

      if (userProvidedCallback !== this.userProvidedCallback) {
        this.userProvidedCallback = userProvidedCallback;
        this.shouldUpdate = true;
      }

      if (env.DEBUG && args.positional.length !== 2) {
        throw new Error("You can only pass two positional arguments (event name and callback) to the `on` modifier, but you provided " + args.positional.length + ". Consider using the `fn` helper to provide additional arguments to the `on` callback.");
      }

      var needsCustomCallback = SUPPORTS_EVENT_OPTIONS === false && once ||
      /* needs manual once implementation */
      env.DEBUG && passive;
      /* needs passive enforcement */

      if (this.shouldUpdate) {
        if (needsCustomCallback) {
          var callback = this.callback = function (event) {
            if (env.DEBUG && passive) {
              event.preventDefault = function () {
                throw new Error("You marked this listener as 'passive', meaning that you must not call 'event.preventDefault()': \n\n" + userProvidedCallback);
              };
            }

            if (!SUPPORTS_EVENT_OPTIONS && once) {
              removeEventListener(this, eventName, callback, options);
            }

            return userProvidedCallback.call(untouchableContext, event);
          };
        } else if (env.DEBUG) {
          // prevent the callback from being bound to the element
          this.callback = userProvidedCallback.bind(untouchableContext);
        } else {
          this.callback = userProvidedCallback;
        }
      }
    };

    return OnModifierState;
  }();
  var adds = 0;
  var removes = 0;

  function removeEventListener(element, eventName, callback, options) {
    removes++;

    if (SUPPORTS_EVENT_OPTIONS) {
      // when options are supported, use them across the board
      element.removeEventListener(eventName, callback, options);
    } else if (options !== undefined && options.capture) {
      // used only in the following case:
      //
      // `{ once: true | false, passive: true | false, capture: true }
      //
      // `once` is handled via a custom callback that removes after first
      // invocation so we only care about capture here as a boolean
      element.removeEventListener(eventName, callback, true);
    } else {
      // used only in the following cases:
      //
      // * where there is no options
      // * `{ once: true | false, passive: true | false, capture: false }
      element.removeEventListener(eventName, callback);
    }
  }

  function addEventListener(element, eventName, callback, options) {
    adds++;

    if (SUPPORTS_EVENT_OPTIONS) {
      // when options are supported, use them across the board
      element.addEventListener(eventName, callback, options);
    } else if (options !== undefined && options.capture) {
      // used only in the following case:
      //
      // `{ once: true | false, passive: true | false, capture: true }
      //
      // `once` is handled via a custom callback that removes after first
      // invocation so we only care about capture here as a boolean
      element.addEventListener(eventName, callback, true);
    } else {
      // used only in the following cases:
      //
      // * where there is no options
      // * `{ once: true | false, passive: true | false, capture: false }
      element.addEventListener(eventName, callback);
    }
  }
  /**
    The `{{on}}` modifier lets you easily add event listeners (it uses
    [EventTarget.addEventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener)
    internally).

    For example, if you'd like to run a function on your component when a `<button>`
    in the components template is clicked you might do something like:

    ```app/components/like-post.hbs
    <button {{on 'click' this.saveLike}}>Like this post!</button>
    ```

    ```app/components/like-post.js
    import Component from '@glimmer/component';
    import { action } from '@ember/object';

    export default class LikePostComponent extends Component {
      saveLike = () => {
        // someone likes your post!
        // better send a request off to your server...
      }
    }
    ```

    ### Arguments

    `{{on}}` accepts two positional arguments, and a few named arguments.

    The positional arguments are:

    - `event` -- the name to use when calling `addEventListener`
    - `callback` -- the function to be passed to `addEventListener`

    The named arguments are:

    - capture -- a `true` value indicates that events of this type will be dispatched
      to the registered listener before being dispatched to any EventTarget beneath it
      in the DOM tree.
    - once -- indicates that the listener should be invoked at most once after being
      added. If true, the listener would be automatically removed when invoked.
    - passive -- if `true`, indicates that the function specified by listener will never
      call preventDefault(). If a passive listener does call preventDefault(), the user
      agent will do nothing other than generate a console warning. See
      [Improving scrolling performance with passive listeners](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Improving_scrolling_performance_with_passive_listeners)
      to learn more.

    The callback function passed to `{{on}}` will receive any arguments that are passed
    to the event handler. Most commonly this would be the `event` itself.

    If you would like to pass additional arguments to the function you should use
    the `{{fn}}` helper.

    For example, in our example case above if you'd like to pass in the post that
    was being liked when the button is clicked you could do something like:

    ```app/components/like-post.hbs
    <button {{on 'click' (fn this.saveLike @post)}}>Like this post!</button>
    ```

    In this case, the `saveLike` function will receive two arguments: the click event
    and the value of `@post`.

    ### Function Context

    In the example above, we used an arrow function to ensure that `likePost` is
    properly bound to the `items-list`, but let's explore what happens if we
    left out the arrow function:

    ```app/components/like-post.js
    import Component from '@glimmer/component';

    export default class LikePostComponent extends Component {
      saveLike() {
        // ...snip...
      }
    }
    ```

    In this example, when the button is clicked `saveLike` will be invoked,
    it will **not** have access to the component instance. In other
    words, it will have no `this` context, so please make sure your functions
    are bound (via an arrow function or other means) before passing into `on`!

    @method on
    @public
  */


  var OnModifierManager = /*#__PURE__*/function () {
    function OnModifierManager() {
      this.SUPPORTS_EVENT_OPTIONS = SUPPORTS_EVENT_OPTIONS;
    }

    var _proto2 = OnModifierManager.prototype;

    _proto2.getDebugName = function getDebugName() {
      return 'on';
    };

    _proto2.create = function create(_owner, element, _state, args) {
      return new OnModifierState(element, args);
    };

    _proto2.getTag = function getTag(state) {
      if (state === null) {
        return null;
      }

      return state.tag;
    };

    _proto2.install = function install(state) {
      if (state === null) {
        return;
      }

      state.updateFromArgs();
      var element = state.element,
          eventName = state.eventName,
          callback = state.callback,
          options = state.options;
      addEventListener(element, eventName, callback, options);
      destroyable.registerDestructor(state, function () {
        return removeEventListener(element, eventName, callback, options);
      });
      state.shouldUpdate = false;
    };

    _proto2.update = function update(state) {
      if (state === null) {
        return;
      } // stash prior state for el.removeEventListener


      var element = state.element,
          eventName = state.eventName,
          callback = state.callback,
          options = state.options;
      state.updateFromArgs();

      if (!state.shouldUpdate) {
        return;
      } // use prior state values for removal


      removeEventListener(element, eventName, callback, options); // read updated values from the state object

      addEventListener(state.element, state.eventName, state.callback, state.options);
      state.shouldUpdate = false;
    };

    _proto2.getDestroyable = function getDestroyable(state) {
      return state;
    };

    _createClass$7(OnModifierManager, [{
      key: "counters",
      get: function get() {
        return {
          adds: adds,
          removes: removes
        };
      }
    }]);

    return OnModifierManager;
  }();

  var on = manager.setInternalModifierManager(new OnModifierManager(), {});

  Object.defineProperty(exports, 'destroy', {
    enumerable: true,
    get: function () {
      return destroyable.destroy;
    }
  });
  Object.defineProperty(exports, 'isDestroyed', {
    enumerable: true,
    get: function () {
      return destroyable.isDestroyed;
    }
  });
  Object.defineProperty(exports, 'isDestroying', {
    enumerable: true,
    get: function () {
      return destroyable.isDestroying;
    }
  });
  Object.defineProperty(exports, 'registerDestructor', {
    enumerable: true,
    get: function () {
      return destroyable.registerDestructor;
    }
  });
  exports.ConcreteBounds = ConcreteBounds;
  exports.CurriedValue = CurriedValue;
  exports.CursorImpl = CursorImpl;
  exports.DOMChanges = helper$1;
  exports.DOMTreeConstruction = DOMTreeConstruction;
  exports.DynamicAttribute = DynamicAttribute;
  exports.DynamicScopeImpl = DynamicScopeImpl;
  exports.EMPTY_ARGS = EMPTY_ARGS;
  exports.EMPTY_NAMED = EMPTY_NAMED;
  exports.EMPTY_POSITIONAL = EMPTY_POSITIONAL;
  exports.EnvironmentImpl = EnvironmentImpl;
  exports.IDOMChanges = DOMChangesImpl;
  exports.LowLevelVM = VM;
  exports.NewElementBuilder = NewElementBuilder;
  exports.PartialScopeImpl = PartialScopeImpl;
  exports.RehydrateBuilder = RehydrateBuilder;
  exports.RemoteLiveBlock = RemoteLiveBlock;
  exports.SERIALIZATION_FIRST_NODE_STRING = SERIALIZATION_FIRST_NODE_STRING;
  exports.SimpleDynamicAttribute = SimpleDynamicAttribute;
  exports.TEMPLATE_ONLY_COMPONENT_MANAGER = TEMPLATE_ONLY_COMPONENT_MANAGER;
  exports.TemplateOnlyComponent = TemplateOnlyComponentDefinition;
  exports.TemplateOnlyComponentManager = TemplateOnlyComponentManager;
  exports.UpdatableBlockImpl = UpdatableBlockImpl;
  exports.UpdatingVM = UpdatingVMImpl;
  exports.array = array;
  exports.clear = clear;
  exports.clientBuilder = clientBuilder;
  exports.concat = concat;
  exports.createCapturedArgs = createCapturedArgs;
  exports.curry = curry;
  exports.dynamicAttribute = dynamicAttribute;
  exports.fn = fn;
  exports.get = get;
  exports.hash = hash;
  exports.inTransaction = inTransaction;
  exports.invokeHelper = invokeHelper;
  exports.isSerializationFirstNode = isSerializationFirstNode;
  exports.isWhitespace = isWhitespace;
  exports.normalizeProperty = normalizeProperty;
  exports.on = on;
  exports.rehydrationBuilder = rehydrationBuilder;
  exports.reifyArgs = reifyArgs;
  exports.reifyNamed = reifyNamed;
  exports.reifyPositional = reifyPositional;
  exports.renderComponent = renderComponent;
  exports.renderMain = renderMain;
  exports.renderSync = renderSync;
  exports.resetDebuggerCallback = resetDebuggerCallback;
  exports.runtimeContext = runtimeContext;
  exports.setDebuggerCallback = setDebuggerCallback;
  exports.templateOnlyComponent = templateOnlyComponent;

  Object.defineProperty(exports, '__esModule', { value: true });

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2xpbW1lci1ydW50aW1lLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi9zY29wZS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL3N5bWJvbHMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi9ib3VuZHMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi9kb20vbm9ybWFsaXplLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvcnVudGltZS9saWIvZG9tL3Byb3BzLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvcnVudGltZS9saWIvZG9tL3Nhbml0aXplZC12YWx1ZXMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi92bS9hdHRyaWJ1dGVzL2R5bmFtaWMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi92bS9lbGVtZW50LWJ1aWxkZXIudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi9vcGNvZGVzLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvcnVudGltZS9saWIvY29tcGlsZWQvZXhwcmVzc2lvbnMvY29uY2F0LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvcnVudGltZS9saWIvY3VycmllZC12YWx1ZS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL3JlZmVyZW5jZXMvY3VycnktdmFsdWUudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi92bS9hcmd1bWVudHMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi9jb21waWxlZC9vcGNvZGVzL2V4cHJlc3Npb25zLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvcnVudGltZS9saWIvY29tcG9uZW50L3Jlc29sdmUudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi9jb21wb25lbnQvaW50ZXJmYWNlcy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL3JlZmVyZW5jZXMvY2xhc3MtbGlzdC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL2NvbXBpbGVkL29wY29kZXMvdm0udHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi9jb21waWxlZC9vcGNvZGVzL2RvbS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL2NvbXBpbGVkL29wY29kZXMvY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvcnVudGltZS9saWIvdm0vY29udGVudC90ZXh0LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvcnVudGltZS9saWIvY29tcGlsZWQvb3Bjb2Rlcy9jb250ZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvcnVudGltZS9saWIvY29tcGlsZWQvb3Bjb2Rlcy9kZWJ1Z2dlci50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL2NvbXBpbGVkL29wY29kZXMvbGlzdHMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi9jb21wb25lbnQvdGVtcGxhdGUtb25seS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL2RvbS9vcGVyYXRpb25zLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvcnVudGltZS9saWIvY29tcGF0L3N2Zy1pbm5lci1odG1sLWZpeC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL2NvbXBhdC90ZXh0LW5vZGUtbWVyZ2luZy1maXgudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi9kb20vaGVscGVyLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvcnVudGltZS9saWIvZGVidWctcmVuZGVyLXRyZWUudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi9lbnZpcm9ubWVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL3ZtL2xvdy1sZXZlbC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL3ZtL3VwZGF0ZS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL3ZtL3JlbmRlci1yZXN1bHQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi92bS9zdGFjay50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL3ZtL2FwcGVuZC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL3JlbmRlci50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL3ZtL3JlaHlkcmF0ZS1idWlsZGVyLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvcnVudGltZS9saWIvaGVscGVycy9pbnZva2UudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi9oZWxwZXJzL2ludGVybmFsLWhlbHBlci50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL2hlbHBlcnMvZm4udHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi9oZWxwZXJzL2hhc2gudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi9oZWxwZXJzL2FycmF5LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvcnVudGltZS9saWIvaGVscGVycy9nZXQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi9oZWxwZXJzL2NvbmNhdC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL21vZGlmaWVycy9vbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBEeW5hbWljU2NvcGUsXG4gIERpY3QsXG4gIFBhcnRpYWxTY29wZSxcbiAgU2NvcGVTbG90LFxuICBTY29wZUJsb2NrLFxuICBPcHRpb24sXG4gIFNjb3BlLFxuICBPd25lcixcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBhc3NpZ24gfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IFJlZmVyZW5jZSwgVU5ERUZJTkVEX1JFRkVSRU5DRSB9IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5cbmV4cG9ydCBjbGFzcyBEeW5hbWljU2NvcGVJbXBsIGltcGxlbWVudHMgRHluYW1pY1Njb3BlIHtcbiAgcHJpdmF0ZSBidWNrZXQ6IERpY3Q8UmVmZXJlbmNlPjtcblxuICBjb25zdHJ1Y3RvcihidWNrZXQ/OiBEaWN0PFJlZmVyZW5jZT4pIHtcbiAgICBpZiAoYnVja2V0KSB7XG4gICAgICB0aGlzLmJ1Y2tldCA9IGFzc2lnbih7fSwgYnVja2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5idWNrZXQgPSB7fTtcbiAgICB9XG4gIH1cblxuICBnZXQoa2V5OiBzdHJpbmcpOiBSZWZlcmVuY2Uge1xuICAgIHJldHVybiB0aGlzLmJ1Y2tldFtrZXldO1xuICB9XG5cbiAgc2V0KGtleTogc3RyaW5nLCByZWZlcmVuY2U6IFJlZmVyZW5jZSk6IFJlZmVyZW5jZSB7XG4gICAgcmV0dXJuICh0aGlzLmJ1Y2tldFtrZXldID0gcmVmZXJlbmNlKTtcbiAgfVxuXG4gIGNoaWxkKCk6IER5bmFtaWNTY29wZUltcGwge1xuICAgIHJldHVybiBuZXcgRHluYW1pY1Njb3BlSW1wbCh0aGlzLmJ1Y2tldCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU2NvcGVSZWZlcmVuY2UoczogU2NvcGVTbG90KTogcyBpcyBSZWZlcmVuY2Uge1xuICBpZiAocyA9PT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KHMpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgY2xhc3MgUGFydGlhbFNjb3BlSW1wbCBpbXBsZW1lbnRzIFBhcnRpYWxTY29wZSB7XG4gIHN0YXRpYyByb290KHNlbGY6IFJlZmVyZW5jZTx1bmtub3duPiwgc2l6ZSA9IDAsIG93bmVyOiBPd25lcik6IFBhcnRpYWxTY29wZSB7XG4gICAgbGV0IHJlZnM6IFJlZmVyZW5jZTx1bmtub3duPltdID0gbmV3IEFycmF5KHNpemUgKyAxKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHNpemU7IGkrKykge1xuICAgICAgcmVmc1tpXSA9IFVOREVGSU5FRF9SRUZFUkVOQ0U7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQYXJ0aWFsU2NvcGVJbXBsKHJlZnMsIG93bmVyLCBudWxsLCBudWxsLCBudWxsKS5pbml0KHsgc2VsZiB9KTtcbiAgfVxuXG4gIHN0YXRpYyBzaXplZChzaXplID0gMCwgb3duZXI6IE93bmVyKTogU2NvcGUge1xuICAgIGxldCByZWZzOiBSZWZlcmVuY2U8dW5rbm93bj5bXSA9IG5ldyBBcnJheShzaXplICsgMSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBzaXplOyBpKyspIHtcbiAgICAgIHJlZnNbaV0gPSBVTkRFRklORURfUkVGRVJFTkNFO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUGFydGlhbFNjb3BlSW1wbChyZWZzLCBvd25lciwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICAvLyB0aGUgMHRoIHNsb3QgaXMgYHNlbGZgXG4gICAgcmVhZG9ubHkgc2xvdHM6IEFycmF5PFNjb3BlU2xvdD4sXG4gICAgcmVhZG9ubHkgb3duZXI6IE93bmVyLFxuICAgIHByaXZhdGUgY2FsbGVyU2NvcGU6IFNjb3BlIHwgbnVsbCxcbiAgICAvLyBuYW1lZCBhcmd1bWVudHMgYW5kIGJsb2NrcyBwYXNzZWQgdG8gYSBsYXlvdXQgdGhhdCB1c2VzIGV2YWxcbiAgICBwcml2YXRlIGV2YWxTY29wZTogRGljdDxTY29wZVNsb3Q+IHwgbnVsbCxcbiAgICAvLyBsb2NhbHMgaW4gc2NvcGUgd2hlbiB0aGUgcGFydGlhbCB3YXMgaW52b2tlZFxuICAgIHByaXZhdGUgcGFydGlhbE1hcDogRGljdDxSZWZlcmVuY2U8dW5rbm93bj4+IHwgbnVsbFxuICApIHt9XG5cbiAgaW5pdCh7IHNlbGYgfTogeyBzZWxmOiBSZWZlcmVuY2U8dW5rbm93bj4gfSk6IHRoaXMge1xuICAgIHRoaXMuc2xvdHNbMF0gPSBzZWxmO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0U2VsZigpOiBSZWZlcmVuY2U8dW5rbm93bj4ge1xuICAgIHJldHVybiB0aGlzLmdldDxSZWZlcmVuY2U8dW5rbm93bj4+KDApO1xuICB9XG5cbiAgZ2V0U3ltYm9sKHN5bWJvbDogbnVtYmVyKTogUmVmZXJlbmNlPHVua25vd24+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQ8UmVmZXJlbmNlPHVua25vd24+PihzeW1ib2wpO1xuICB9XG5cbiAgZ2V0QmxvY2soc3ltYm9sOiBudW1iZXIpOiBPcHRpb248U2NvcGVCbG9jaz4ge1xuICAgIGxldCBibG9jayA9IHRoaXMuZ2V0KHN5bWJvbCk7XG4gICAgcmV0dXJuIGJsb2NrID09PSBVTkRFRklORURfUkVGRVJFTkNFID8gbnVsbCA6IChibG9jayBhcyBTY29wZUJsb2NrKTtcbiAgfVxuXG4gIGdldEV2YWxTY29wZSgpOiBPcHRpb248RGljdDxTY29wZVNsb3Q+PiB7XG4gICAgcmV0dXJuIHRoaXMuZXZhbFNjb3BlO1xuICB9XG5cbiAgZ2V0UGFydGlhbE1hcCgpOiBPcHRpb248RGljdDxSZWZlcmVuY2U8dW5rbm93bj4+PiB7XG4gICAgcmV0dXJuIHRoaXMucGFydGlhbE1hcDtcbiAgfVxuXG4gIGJpbmQoc3ltYm9sOiBudW1iZXIsIHZhbHVlOiBTY29wZVNsb3QpIHtcbiAgICB0aGlzLnNldChzeW1ib2wsIHZhbHVlKTtcbiAgfVxuXG4gIGJpbmRTZWxmKHNlbGY6IFJlZmVyZW5jZTx1bmtub3duPikge1xuICAgIHRoaXMuc2V0PFJlZmVyZW5jZTx1bmtub3duPj4oMCwgc2VsZik7XG4gIH1cblxuICBiaW5kU3ltYm9sKHN5bWJvbDogbnVtYmVyLCB2YWx1ZTogUmVmZXJlbmNlPHVua25vd24+KSB7XG4gICAgdGhpcy5zZXQoc3ltYm9sLCB2YWx1ZSk7XG4gIH1cblxuICBiaW5kQmxvY2soc3ltYm9sOiBudW1iZXIsIHZhbHVlOiBPcHRpb248U2NvcGVCbG9jaz4pIHtcbiAgICB0aGlzLnNldDxPcHRpb248U2NvcGVCbG9jaz4+KHN5bWJvbCwgdmFsdWUpO1xuICB9XG5cbiAgYmluZEV2YWxTY29wZShtYXA6IE9wdGlvbjxEaWN0PFNjb3BlU2xvdD4+KSB7XG4gICAgdGhpcy5ldmFsU2NvcGUgPSBtYXA7XG4gIH1cblxuICBiaW5kUGFydGlhbE1hcChtYXA6IERpY3Q8UmVmZXJlbmNlPHVua25vd24+Pikge1xuICAgIHRoaXMucGFydGlhbE1hcCA9IG1hcDtcbiAgfVxuXG4gIGJpbmRDYWxsZXJTY29wZShzY29wZTogT3B0aW9uPFNjb3BlPik6IHZvaWQge1xuICAgIHRoaXMuY2FsbGVyU2NvcGUgPSBzY29wZTtcbiAgfVxuXG4gIGdldENhbGxlclNjb3BlKCk6IE9wdGlvbjxTY29wZT4ge1xuICAgIHJldHVybiB0aGlzLmNhbGxlclNjb3BlO1xuICB9XG5cbiAgY2hpbGQoKTogU2NvcGUge1xuICAgIHJldHVybiBuZXcgUGFydGlhbFNjb3BlSW1wbChcbiAgICAgIHRoaXMuc2xvdHMuc2xpY2UoKSxcbiAgICAgIHRoaXMub3duZXIsXG4gICAgICB0aGlzLmNhbGxlclNjb3BlLFxuICAgICAgdGhpcy5ldmFsU2NvcGUsXG4gICAgICB0aGlzLnBhcnRpYWxNYXBcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQ8VCBleHRlbmRzIFNjb3BlU2xvdD4oaW5kZXg6IG51bWJlcik6IFQge1xuICAgIGlmIChpbmRleCA+PSB0aGlzLnNsb3RzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEJVRzogY2Fubm90IGdldCAkJHtpbmRleH0gZnJvbSBzY29wZTsgbGVuZ3RoPSR7dGhpcy5zbG90cy5sZW5ndGh9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2xvdHNbaW5kZXhdIGFzIFQ7XG4gIH1cblxuICBwcml2YXRlIHNldDxUIGV4dGVuZHMgU2NvcGVTbG90PihpbmRleDogbnVtYmVyLCB2YWx1ZTogVCk6IHZvaWQge1xuICAgIGlmIChpbmRleCA+PSB0aGlzLnNsb3RzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEJVRzogY2Fubm90IGdldCAkJHtpbmRleH0gZnJvbSBzY29wZTsgbGVuZ3RoPSR7dGhpcy5zbG90cy5sZW5ndGh9YCk7XG4gICAgfVxuXG4gICAgdGhpcy5zbG90c1tpbmRleF0gPSB2YWx1ZTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgc3ltYm9sIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbi8vIFRoZXNlIHN5bWJvbHMgcmVwcmVzZW50IFwiZnJpZW5kXCIgcHJvcGVydGllcyB0aGF0IGFyZSB1c2VkIGluc2lkZSBvZlxuLy8gdGhlIFZNIGluIG90aGVyIGNsYXNzZXMsIGJ1dCBhcmUgbm90IGludGVuZGVkIHRvIGJlIGEgcGFydCBvZlxuLy8gR2xpbW1lcidzIEFQSS5cblxuZXhwb3J0IGNvbnN0IElOTkVSX1ZNOiB1bmlxdWUgc3ltYm9sID0gc3ltYm9sKCdJTk5FUl9WTScpO1xuZXhwb3J0IGNvbnN0IERFU1RST1lBQkxFX1NUQUNLOiB1bmlxdWUgc3ltYm9sID0gc3ltYm9sKCdERVNUUk9ZQUJMRV9TVEFDSycpO1xuZXhwb3J0IGNvbnN0IFNUQUNLUzogdW5pcXVlIHN5bWJvbCA9IHN5bWJvbCgnU1RBQ0tTJyk7XG5leHBvcnQgY29uc3QgUkVHSVNURVJTOiB1bmlxdWUgc3ltYm9sID0gc3ltYm9sKCdSRUdJU1RFUlMnKTtcbmV4cG9ydCBjb25zdCBIRUFQOiB1bmlxdWUgc3ltYm9sID0gc3ltYm9sKCdIRUFQJyk7XG5leHBvcnQgY29uc3QgQ09OU1RBTlRTOiB1bmlxdWUgc3ltYm9sID0gc3ltYm9sKCdDT05TVEFOVFMnKTtcbmV4cG9ydCBjb25zdCBBUkdTOiB1bmlxdWUgc3ltYm9sID0gc3ltYm9sKCdBUkdTJyk7XG5leHBvcnQgY29uc3QgUEM6IHVuaXF1ZSBzeW1ib2wgPSBzeW1ib2woJ1BDJyk7XG4iLCJpbXBvcnQgeyBCb3VuZHMsIEN1cnNvciwgT3B0aW9uIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBTaW1wbGVFbGVtZW50LCBTaW1wbGVOb2RlIH0gZnJvbSAnQHNpbXBsZS1kb20vaW50ZXJmYWNlJztcbmltcG9ydCB7IGV4cGVjdCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuXG5leHBvcnQgY2xhc3MgQ3Vyc29ySW1wbCBpbXBsZW1lbnRzIEN1cnNvciB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBlbGVtZW50OiBTaW1wbGVFbGVtZW50LCBwdWJsaWMgbmV4dFNpYmxpbmc6IE9wdGlvbjxTaW1wbGVOb2RlPikge31cbn1cblxuZXhwb3J0IHR5cGUgRGVzdHJveWFibGVCb3VuZHMgPSBCb3VuZHM7XG5cbmV4cG9ydCBjbGFzcyBDb25jcmV0ZUJvdW5kcyBpbXBsZW1lbnRzIEJvdW5kcyB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBwYXJlbnROb2RlOiBTaW1wbGVFbGVtZW50LFxuICAgIHByaXZhdGUgZmlyc3Q6IFNpbXBsZU5vZGUsXG4gICAgcHJpdmF0ZSBsYXN0OiBTaW1wbGVOb2RlXG4gICkge31cblxuICBwYXJlbnRFbGVtZW50KCk6IFNpbXBsZUVsZW1lbnQge1xuICAgIHJldHVybiB0aGlzLnBhcmVudE5vZGU7XG4gIH1cblxuICBmaXJzdE5vZGUoKTogU2ltcGxlTm9kZSB7XG4gICAgcmV0dXJuIHRoaXMuZmlyc3Q7XG4gIH1cblxuICBsYXN0Tm9kZSgpOiBTaW1wbGVOb2RlIHtcbiAgICByZXR1cm4gdGhpcy5sYXN0O1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTaW5nbGVOb2RlQm91bmRzIGltcGxlbWVudHMgQm91bmRzIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBwYXJlbnROb2RlOiBTaW1wbGVFbGVtZW50LCBwcml2YXRlIG5vZGU6IFNpbXBsZU5vZGUpIHt9XG5cbiAgcGFyZW50RWxlbWVudCgpOiBTaW1wbGVFbGVtZW50IHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnROb2RlO1xuICB9XG5cbiAgZmlyc3ROb2RlKCk6IFNpbXBsZU5vZGUge1xuICAgIHJldHVybiB0aGlzLm5vZGU7XG4gIH1cblxuICBsYXN0Tm9kZSgpOiBTaW1wbGVOb2RlIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb3ZlKGJvdW5kczogQm91bmRzLCByZWZlcmVuY2U6IE9wdGlvbjxTaW1wbGVOb2RlPik6IE9wdGlvbjxTaW1wbGVOb2RlPiB7XG4gIGxldCBwYXJlbnQgPSBib3VuZHMucGFyZW50RWxlbWVudCgpO1xuICBsZXQgZmlyc3QgPSBib3VuZHMuZmlyc3ROb2RlKCk7XG4gIGxldCBsYXN0ID0gYm91bmRzLmxhc3ROb2RlKCk7XG5cbiAgbGV0IGN1cnJlbnQ6IFNpbXBsZU5vZGUgPSBmaXJzdDtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGxldCBuZXh0ID0gY3VycmVudC5uZXh0U2libGluZztcblxuICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY3VycmVudCwgcmVmZXJlbmNlKTtcblxuICAgIGlmIChjdXJyZW50ID09PSBsYXN0KSB7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9XG5cbiAgICBjdXJyZW50ID0gZXhwZWN0KG5leHQsICdpbnZhbGlkIGJvdW5kcycpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhcihib3VuZHM6IEJvdW5kcyk6IE9wdGlvbjxTaW1wbGVOb2RlPiB7XG4gIGxldCBwYXJlbnQgPSBib3VuZHMucGFyZW50RWxlbWVudCgpO1xuICBsZXQgZmlyc3QgPSBib3VuZHMuZmlyc3ROb2RlKCk7XG4gIGxldCBsYXN0ID0gYm91bmRzLmxhc3ROb2RlKCk7XG5cbiAgbGV0IGN1cnJlbnQ6IFNpbXBsZU5vZGUgPSBmaXJzdDtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGxldCBuZXh0ID0gY3VycmVudC5uZXh0U2libGluZztcblxuICAgIHBhcmVudC5yZW1vdmVDaGlsZChjdXJyZW50KTtcblxuICAgIGlmIChjdXJyZW50ID09PSBsYXN0KSB7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9XG5cbiAgICBjdXJyZW50ID0gZXhwZWN0KG5leHQsICdpbnZhbGlkIGJvdW5kcycpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBEaWN0IH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBTaW1wbGVOb2RlLCBTaW1wbGVEb2N1bWVudEZyYWdtZW50IH0gZnJvbSAnQHNpbXBsZS1kb20vaW50ZXJmYWNlJztcblxuZXhwb3J0IGludGVyZmFjZSBTYWZlU3RyaW5nIHtcbiAgdG9IVE1MKCk6IHN0cmluZztcbn1cblxuZXhwb3J0IHR5cGUgSW5zZXJ0aW9uID0gQ2F1dGlvdXNJbnNlcnRpb24gfCBUcnVzdGluZ0luc2VydGlvbjtcbmV4cG9ydCB0eXBlIENhdXRpb3VzSW5zZXJ0aW9uID0gc3RyaW5nIHwgU2FmZVN0cmluZyB8IFNpbXBsZU5vZGU7XG5leHBvcnQgdHlwZSBUcnVzdGluZ0luc2VydGlvbiA9IHN0cmluZyB8IFNpbXBsZU5vZGU7XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVTdHJpbmdWYWx1ZSh2YWx1ZTogdW5rbm93bik6IHN0cmluZyB7XG4gIGlmIChpc0VtcHR5KHZhbHVlKSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVRydXN0ZWRWYWx1ZSh2YWx1ZTogdW5rbm93bik6IFRydXN0aW5nSW5zZXJ0aW9uIHtcbiAgaWYgKGlzRW1wdHkodmFsdWUpKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU2FmZVN0cmluZyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUudG9IVE1MKCk7XG4gIH1cbiAgaWYgKGlzTm9kZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRDb2VyY2UoXG4gIHZhbHVlOiB1bmtub3duXG4pOiB2YWx1ZSBpcyBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiAoXG4gICAgaXNTdHJpbmcodmFsdWUpIHx8IGlzRW1wdHkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcidcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHkodmFsdWU6IHVua25vd24pOiBib29sZWFuIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mICh2YWx1ZSBhcyBEaWN0KS50b1N0cmluZyAhPT0gJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU2FmZVN0cmluZyh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFNhZmVTdHJpbmcge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgKHZhbHVlIGFzIGFueSkudG9IVE1MID09PSAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOb2RlKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgU2ltcGxlTm9kZSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiAodmFsdWUgYXMgYW55KS5ub2RlVHlwZSA9PT0gJ251bWJlcic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ZyYWdtZW50KHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgU2ltcGxlRG9jdW1lbnRGcmFnbWVudCB7XG4gIHJldHVybiBpc05vZGUodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSAxMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgc3RyaW5nIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG59XG4iLCJpbXBvcnQgeyBEaWN0IH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBTaW1wbGVFbGVtZW50IH0gZnJvbSAnQHNpbXBsZS1kb20vaW50ZXJmYWNlJztcblxuLypcbiAqIEBtZXRob2Qgbm9ybWFsaXplUHJvcGVydHlcbiAqIEBwYXJhbSBlbGVtZW50IHtIVE1MRWxlbWVudH1cbiAqIEBwYXJhbSBzbG90TmFtZSB7U3RyaW5nfVxuICogQHJldHVybnMge09iamVjdH0geyBuYW1lLCB0eXBlIH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BlcnR5KGVsZW1lbnQ6IFNpbXBsZUVsZW1lbnQsIHNsb3ROYW1lOiBzdHJpbmcpIHtcbiAgbGV0IHR5cGUsIG5vcm1hbGl6ZWQ7XG5cbiAgaWYgKHNsb3ROYW1lIGluIGVsZW1lbnQpIHtcbiAgICBub3JtYWxpemVkID0gc2xvdE5hbWU7XG4gICAgdHlwZSA9ICdwcm9wJztcbiAgfSBlbHNlIHtcbiAgICBsZXQgbG93ZXIgPSBzbG90TmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsb3dlciBpbiBlbGVtZW50KSB7XG4gICAgICB0eXBlID0gJ3Byb3AnO1xuICAgICAgbm9ybWFsaXplZCA9IGxvd2VyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gJ2F0dHInO1xuICAgICAgbm9ybWFsaXplZCA9IHNsb3ROYW1lO1xuICAgIH1cbiAgfVxuXG4gIGlmIChcbiAgICB0eXBlID09PSAncHJvcCcgJiZcbiAgICAobm9ybWFsaXplZC50b0xvd2VyQ2FzZSgpID09PSAnc3R5bGUnIHx8IHByZWZlckF0dHIoZWxlbWVudC50YWdOYW1lLCBub3JtYWxpemVkKSlcbiAgKSB7XG4gICAgdHlwZSA9ICdhdHRyJztcbiAgfVxuXG4gIHJldHVybiB7IG5vcm1hbGl6ZWQsIHR5cGUgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BlcnR5VmFsdWUodmFsdWU6IHVua25vd24pOiB1bmtub3duIHtcbiAgaWYgKHZhbHVlID09PSAnJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyBwcm9wZXJ0aWVzIHRoYXQgTVVTVCBiZSBzZXQgYXMgYXR0cmlidXRlcywgZHVlIHRvOlxuLy8gKiBicm93c2VyIGJ1Z1xuLy8gKiBzdHJhbmdlIHNwZWMgb3V0bGllclxuY29uc3QgQVRUUl9PVkVSUklERVM6IERpY3Q8RGljdD4gPSB7XG4gIElOUFVUOiB7XG4gICAgZm9ybTogdHJ1ZSxcbiAgICAvLyBDaHJvbWUgNDYuMC4yNDY0LjA6ICdhdXRvY29ycmVjdCcgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKSA9PT0gZmFsc2VcbiAgICAvLyBTYWZhcmkgOC4wLjc6ICdhdXRvY29ycmVjdCcgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKSA9PT0gZmFsc2VcbiAgICAvLyBNb2JpbGUgU2FmYXJpIChpT1MgOC40IHNpbXVsYXRvcik6ICdhdXRvY29ycmVjdCcgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKSA9PT0gdHJ1ZVxuICAgIGF1dG9jb3JyZWN0OiB0cnVlLFxuICAgIC8vIENocm9tZSA1NC4wLjI4NDAuOTg6ICdsaXN0JyBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpID09PSB0cnVlXG4gICAgLy8gU2FmYXJpIDkuMS4zOiAnbGlzdCcgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKSA9PT0gZmFsc2VcbiAgICBsaXN0OiB0cnVlLFxuICB9LFxuXG4gIC8vIGVsZW1lbnQuZm9ybSBpcyBhY3R1YWxseSBhIGxlZ2l0aW1hdGUgcmVhZE9ubHkgcHJvcGVydHksIHRoYXQgaXMgdG8gYmVcbiAgLy8gbXV0YXRlZCwgYnV0IG11c3QgYmUgbXV0YXRlZCBieSBzZXRBdHRyaWJ1dGUuLi5cbiAgU0VMRUNUOiB7IGZvcm06IHRydWUgfSxcbiAgT1BUSU9OOiB7IGZvcm06IHRydWUgfSxcbiAgVEVYVEFSRUE6IHsgZm9ybTogdHJ1ZSB9LFxuICBMQUJFTDogeyBmb3JtOiB0cnVlIH0sXG4gIEZJRUxEU0VUOiB7IGZvcm06IHRydWUgfSxcbiAgTEVHRU5EOiB7IGZvcm06IHRydWUgfSxcbiAgT0JKRUNUOiB7IGZvcm06IHRydWUgfSxcbiAgT1VUUFVUOiB7IGZvcm06IHRydWUgfSxcbiAgQlVUVE9OOiB7IGZvcm06IHRydWUgfSxcbn07XG5cbmZ1bmN0aW9uIHByZWZlckF0dHIodGFnTmFtZTogc3RyaW5nLCBwcm9wTmFtZTogc3RyaW5nKSB7XG4gIGxldCB0YWcgPSBBVFRSX09WRVJSSURFU1t0YWdOYW1lLnRvVXBwZXJDYXNlKCldO1xuICByZXR1cm4gKHRhZyAmJiB0YWdbcHJvcE5hbWUudG9Mb3dlckNhc2UoKV0pIHx8IGZhbHNlO1xufVxuIiwiaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBTaW1wbGVFbGVtZW50IH0gZnJvbSAnQHNpbXBsZS1kb20vaW50ZXJmYWNlJztcbmltcG9ydCB7IGlzU2FmZVN0cmluZywgbm9ybWFsaXplU3RyaW5nVmFsdWUgfSBmcm9tICcuLi9kb20vbm9ybWFsaXplJztcblxuY29uc3QgYmFkUHJvdG9jb2xzID0gWydqYXZhc2NyaXB0OicsICd2YnNjcmlwdDonXTtcblxuY29uc3QgYmFkVGFncyA9IFsnQScsICdCT0RZJywgJ0xJTksnLCAnSU1HJywgJ0lGUkFNRScsICdCQVNFJywgJ0ZPUk0nXTtcblxuY29uc3QgYmFkVGFnc0ZvckRhdGFVUkkgPSBbJ0VNQkVEJ107XG5cbmNvbnN0IGJhZEF0dHJpYnV0ZXMgPSBbJ2hyZWYnLCAnc3JjJywgJ2JhY2tncm91bmQnLCAnYWN0aW9uJ107XG5cbmNvbnN0IGJhZEF0dHJpYnV0ZXNGb3JEYXRhVVJJID0gWydzcmMnXTtcblxuZnVuY3Rpb24gaGFzKGFycmF5OiBBcnJheTxzdHJpbmc+LCBpdGVtOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIGFycmF5LmluZGV4T2YoaXRlbSkgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBjaGVja1VSSSh0YWdOYW1lOiBPcHRpb248c3RyaW5nPiwgYXR0cmlidXRlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuICh0YWdOYW1lID09PSBudWxsIHx8IGhhcyhiYWRUYWdzLCB0YWdOYW1lKSkgJiYgaGFzKGJhZEF0dHJpYnV0ZXMsIGF0dHJpYnV0ZSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRGF0YVVSSSh0YWdOYW1lOiBPcHRpb248c3RyaW5nPiwgYXR0cmlidXRlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKHRhZ05hbWUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGhhcyhiYWRUYWdzRm9yRGF0YVVSSSwgdGFnTmFtZSkgJiYgaGFzKGJhZEF0dHJpYnV0ZXNGb3JEYXRhVVJJLCBhdHRyaWJ1dGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVxdWlyZXNTYW5pdGl6YXRpb24odGFnTmFtZTogc3RyaW5nLCBhdHRyaWJ1dGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gY2hlY2tVUkkodGFnTmFtZSwgYXR0cmlidXRlKSB8fCBjaGVja0RhdGFVUkkodGFnTmFtZSwgYXR0cmlidXRlKTtcbn1cblxuaW50ZXJmYWNlIE5vZGVVcmxQYXJzZVJlc3VsdCB7XG4gIHByb3RvY29sOiBzdHJpbmcgfCBudWxsO1xufVxuXG5pbnRlcmZhY2UgTm9kZVVybE1vZHVsZSB7XG4gIHBhcnNlKHVybDogc3RyaW5nKTogTm9kZVVybFBhcnNlUmVzdWx0O1xufVxuXG5sZXQgcHJvdG9jb2xGb3JVcmw6ICh1cmw6IHN0cmluZykgPT4gc3RyaW5nO1xuXG5pZiAoXG4gIHR5cGVvZiBVUkwgPT09ICdvYmplY3QnICYmXG4gIFVSTCAhPT0gbnVsbCAmJlxuICAvLyB0aGlzIGlzIHN1cGVyIGFubm95aW5nLCBUUyB0aGlua3MgdGhhdCBVUkwgKiptdXN0KiogYmUgYSBmdW5jdGlvbiBzbyBgVVJMLnBhcnNlYCBjaGVja1xuICAvLyB0aGlua3MgaXQgaXMgYG5ldmVyYCB3aXRob3V0IHRoaXMgYGFzIHVua25vd24gYXMgYW55YFxuICB0eXBlb2YgKChVUkwgYXMgdW5rbm93bikgYXMgYW55KS5wYXJzZSA9PT0gJ2Z1bmN0aW9uJ1xuKSB7XG4gIC8vIEluIEVtYmVyLWxhbmQgdGhlIGBmYXN0Ym9vdGAgcGFja2FnZSBzZXRzIHRoZSBgVVJMYCBnbG9iYWwgdG8gYHJlcXVpcmUoJ3VybCcpYFxuICAvLyB1bHRpbWF0ZWx5LCB0aGlzIHNob3VsZCBiZSBjaGFuZ2VkIChzbyB0aGF0IHdlIGNhbiBlaXRoZXIgcmVseSBvbiB0aGUgbmF0dXJhbCBgVVJMYCBnbG9iYWxcbiAgLy8gdGhhdCBleGlzdHMpIGJ1dCBmb3Igbm93IHdlIGhhdmUgdG8gZGV0ZWN0IHRoZSBzcGVjaWZpYyBgRmFzdEJvb3RgIGNhc2UgZmlyc3RcbiAgLy9cbiAgLy8gYSBmdXR1cmUgdmVyc2lvbiBvZiBgZmFzdGJvb3RgIHdpbGwgZGV0ZWN0IGlmIHRoaXMgbGVnYWN5IFVSTCBzZXR1cCBpcyByZXF1aXJlZCAoYnlcbiAgLy8gaW5zcGVjdGluZyBFbWJlciB2ZXJzaW9uKSBhbmQgaWYgbmV3IGVub3VnaCwgaXQgd2lsbCBhdm9pZCBzaGFkb3dpbmcgdGhlIGBVUkxgIGdsb2JhbFxuICAvLyBjb25zdHJ1Y3RvciB3aXRoIGByZXF1aXJlKCd1cmwnKWAuXG4gIGxldCBub2RlVVJMID0gVVJMIGFzIE5vZGVVcmxNb2R1bGU7XG5cbiAgcHJvdG9jb2xGb3JVcmwgPSAodXJsOiBzdHJpbmcpID0+IHtcbiAgICBsZXQgcHJvdG9jb2wgPSBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBwcm90b2NvbCA9IG5vZGVVUkwucGFyc2UodXJsKS5wcm90b2NvbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvdG9jb2wgPT09IG51bGwgPyAnOicgOiBwcm90b2NvbDtcbiAgfTtcbn0gZWxzZSBpZiAodHlwZW9mIFVSTCA9PT0gJ2Z1bmN0aW9uJykge1xuICBwcm90b2NvbEZvclVybCA9IChfdXJsOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgbGV0IHVybCA9IG5ldyBVUkwoX3VybCk7XG5cbiAgICAgIHJldHVybiB1cmwucHJvdG9jb2w7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIGFueSBub24tZnVsbHkgcXVhbGlmaWVkIHVybCBzdHJpbmcgd2lsbCB0cmlnZ2VyIGFuIGVycm9yIChiZWNhdXNlIHRoZXJlIGlzIG5vXG4gICAgICAvLyBiYXNlVVJJIHRoYXQgd2UgY2FuIHByb3ZpZGU7IGluIHRoYXQgY2FzZSB3ZSAqKmtub3cqKiB0aGF0IHRoZSBwcm90b2NvbCBpc1xuICAgICAgLy8gXCJzYWZlXCIgYmVjYXVzZSBpdCBpc24ndCBzcGVjaWZpY2FsbHkgb25lIG9mIHRoZSBgYmFkUHJvdG9jb2xzYCBsaXN0ZWQgYWJvdmVcbiAgICAgIC8vIChhbmQgdGhvc2UgcHJvdG9jb2xzIGNhbiBuZXZlciBiZSB0aGUgZGVmYXVsdCBiYXNlVVJJKVxuICAgICAgcmV0dXJuICc6JztcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBmYWxsYmFjayBmb3IgSUUxMSBzdXBwb3J0XG4gIGxldCBwYXJzaW5nTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblxuICBwcm90b2NvbEZvclVybCA9ICh1cmw6IHN0cmluZykgPT4ge1xuICAgIHBhcnNpbmdOb2RlLmhyZWYgPSB1cmw7XG4gICAgcmV0dXJuIHBhcnNpbmdOb2RlLnByb3RvY29sO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpemVBdHRyaWJ1dGVWYWx1ZShcbiAgZWxlbWVudDogU2ltcGxlRWxlbWVudCxcbiAgYXR0cmlidXRlOiBzdHJpbmcsXG4gIHZhbHVlOiB1bmtub3duXG4pOiB1bmtub3duIHtcbiAgbGV0IHRhZ05hbWU6IE9wdGlvbjxzdHJpbmc+ID0gbnVsbDtcblxuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmIChpc1NhZmVTdHJpbmcodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvSFRNTCgpO1xuICB9XG5cbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgdGFnTmFtZSA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgdGFnTmFtZSA9IGVsZW1lbnQudGFnTmFtZS50b1VwcGVyQ2FzZSgpO1xuICB9XG5cbiAgbGV0IHN0ciA9IG5vcm1hbGl6ZVN0cmluZ1ZhbHVlKHZhbHVlKTtcblxuICBpZiAoY2hlY2tVUkkodGFnTmFtZSwgYXR0cmlidXRlKSkge1xuICAgIGxldCBwcm90b2NvbCA9IHByb3RvY29sRm9yVXJsKHN0cik7XG4gICAgaWYgKGhhcyhiYWRQcm90b2NvbHMsIHByb3RvY29sKSkge1xuICAgICAgcmV0dXJuIGB1bnNhZmU6JHtzdHJ9YDtcbiAgICB9XG4gIH1cblxuICBpZiAoY2hlY2tEYXRhVVJJKHRhZ05hbWUsIGF0dHJpYnV0ZSkpIHtcbiAgICByZXR1cm4gYHVuc2FmZToke3N0cn1gO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cbiIsImltcG9ydCB7XG4gIERpY3QsXG4gIEVudmlyb25tZW50LFxuICBPcHRpb24sXG4gIEVsZW1lbnRCdWlsZGVyLFxuICBBdHRyaWJ1dGVPcGVyYXRpb24sXG4gIEF0dHJpYnV0ZUN1cnNvcixcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyB3YXJuSWZTdHlsZU5vdFRydXN0ZWQgfSBmcm9tICdAZ2xpbW1lci9nbG9iYWwtY29udGV4dCc7XG5pbXBvcnQgeyBBdHRyTmFtZXNwYWNlLCBOYW1lc3BhY2UsIFNpbXBsZUVsZW1lbnQgfSBmcm9tICdAc2ltcGxlLWRvbS9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgbm9ybWFsaXplU3RyaW5nVmFsdWUgfSBmcm9tICcuLi8uLi9kb20vbm9ybWFsaXplJztcbmltcG9ydCB7IG5vcm1hbGl6ZVByb3BlcnR5IH0gZnJvbSAnLi4vLi4vZG9tL3Byb3BzJztcbmltcG9ydCB7IHJlcXVpcmVzU2FuaXRpemF0aW9uLCBzYW5pdGl6ZUF0dHJpYnV0ZVZhbHVlIH0gZnJvbSAnLi4vLi4vZG9tL3Nhbml0aXplZC12YWx1ZXMnO1xuaW1wb3J0IHsgREVCVUcgfSBmcm9tICdAZ2xpbW1lci9lbnYnO1xuaW1wb3J0IHsgY2FzdFRvQnJvd3NlciB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuXG5leHBvcnQgZnVuY3Rpb24gZHluYW1pY0F0dHJpYnV0ZShcbiAgZWxlbWVudDogU2ltcGxlRWxlbWVudCxcbiAgYXR0cjogc3RyaW5nLFxuICBuYW1lc3BhY2U6IE9wdGlvbjxBdHRyTmFtZXNwYWNlPixcbiAgaXNUcnVzdGluZyA9IGZhbHNlXG4pOiBEeW5hbWljQXR0cmlidXRlIHtcbiAgbGV0IHsgdGFnTmFtZSwgbmFtZXNwYWNlVVJJIH0gPSBlbGVtZW50O1xuICBsZXQgYXR0cmlidXRlID0geyBlbGVtZW50LCBuYW1lOiBhdHRyLCBuYW1lc3BhY2UgfTtcblxuICBpZiAoREVCVUcgJiYgYXR0ciA9PT0gJ3N0eWxlJyAmJiAhaXNUcnVzdGluZykge1xuICAgIHJldHVybiBuZXcgRGVidWdTdHlsZUF0dHJpYnV0ZU1hbmFnZXIoYXR0cmlidXRlKTtcbiAgfVxuXG4gIGlmIChuYW1lc3BhY2VVUkkgPT09IE5hbWVzcGFjZS5TVkcpIHtcbiAgICByZXR1cm4gYnVpbGREeW5hbWljQXR0cmlidXRlKHRhZ05hbWUsIGF0dHIsIGF0dHJpYnV0ZSk7XG4gIH1cblxuICBsZXQgeyB0eXBlLCBub3JtYWxpemVkIH0gPSBub3JtYWxpemVQcm9wZXJ0eShlbGVtZW50LCBhdHRyKTtcblxuICBpZiAodHlwZSA9PT0gJ2F0dHInKSB7XG4gICAgcmV0dXJuIGJ1aWxkRHluYW1pY0F0dHJpYnV0ZSh0YWdOYW1lLCBub3JtYWxpemVkLCBhdHRyaWJ1dGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBidWlsZER5bmFtaWNQcm9wZXJ0eSh0YWdOYW1lLCBub3JtYWxpemVkLCBhdHRyaWJ1dGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRHluYW1pY0F0dHJpYnV0ZShcbiAgdGFnTmFtZTogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGF0dHJpYnV0ZTogQXR0cmlidXRlQ3Vyc29yXG4pOiBEeW5hbWljQXR0cmlidXRlIHtcbiAgaWYgKHJlcXVpcmVzU2FuaXRpemF0aW9uKHRhZ05hbWUsIG5hbWUpKSB7XG4gICAgcmV0dXJuIG5ldyBTYWZlRHluYW1pY0F0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgU2ltcGxlRHluYW1pY0F0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRHluYW1pY1Byb3BlcnR5KFxuICB0YWdOYW1lOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgYXR0cmlidXRlOiBBdHRyaWJ1dGVDdXJzb3Jcbik6IER5bmFtaWNBdHRyaWJ1dGUge1xuICBpZiAocmVxdWlyZXNTYW5pdGl6YXRpb24odGFnTmFtZSwgbmFtZSkpIHtcbiAgICByZXR1cm4gbmV3IFNhZmVEeW5hbWljUHJvcGVydHkobmFtZSwgYXR0cmlidXRlKTtcbiAgfVxuXG4gIGlmIChpc1VzZXJJbnB1dFZhbHVlKHRhZ05hbWUsIG5hbWUpKSB7XG4gICAgcmV0dXJuIG5ldyBJbnB1dFZhbHVlRHluYW1pY0F0dHJpYnV0ZShuYW1lLCBhdHRyaWJ1dGUpO1xuICB9XG5cbiAgaWYgKGlzT3B0aW9uU2VsZWN0ZWQodGFnTmFtZSwgbmFtZSkpIHtcbiAgICByZXR1cm4gbmV3IE9wdGlvblNlbGVjdGVkRHluYW1pY0F0dHJpYnV0ZShuYW1lLCBhdHRyaWJ1dGUpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBEZWZhdWx0RHluYW1pY1Byb3BlcnR5KG5hbWUsIGF0dHJpYnV0ZSk7XG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBEeW5hbWljQXR0cmlidXRlIGltcGxlbWVudHMgQXR0cmlidXRlT3BlcmF0aW9uIHtcbiAgY29uc3RydWN0b3IocHVibGljIGF0dHJpYnV0ZTogQXR0cmlidXRlQ3Vyc29yKSB7fVxuXG4gIGFic3RyYWN0IHNldChkb206IEVsZW1lbnRCdWlsZGVyLCB2YWx1ZTogdW5rbm93biwgZW52OiBFbnZpcm9ubWVudCk6IHZvaWQ7XG4gIGFic3RyYWN0IHVwZGF0ZSh2YWx1ZTogdW5rbm93biwgZW52OiBFbnZpcm9ubWVudCk6IHZvaWQ7XG59XG5cbmV4cG9ydCBjbGFzcyBTaW1wbGVEeW5hbWljQXR0cmlidXRlIGV4dGVuZHMgRHluYW1pY0F0dHJpYnV0ZSB7XG4gIHNldChkb206IEVsZW1lbnRCdWlsZGVyLCB2YWx1ZTogdW5rbm93biwgX2VudjogRW52aXJvbm1lbnQpOiB2b2lkIHtcbiAgICBsZXQgbm9ybWFsaXplZFZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuXG4gICAgaWYgKG5vcm1hbGl6ZWRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgbGV0IHsgbmFtZSwgbmFtZXNwYWNlIH0gPSB0aGlzLmF0dHJpYnV0ZTtcbiAgICAgIGRvbS5fX3NldEF0dHJpYnV0ZShuYW1lLCBub3JtYWxpemVkVmFsdWUsIG5hbWVzcGFjZSk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKHZhbHVlOiB1bmtub3duLCBfZW52OiBFbnZpcm9ubWVudCk6IHZvaWQge1xuICAgIGxldCBub3JtYWxpemVkVmFsdWUgPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSk7XG4gICAgbGV0IHsgZWxlbWVudCwgbmFtZSB9ID0gdGhpcy5hdHRyaWJ1dGU7XG5cbiAgICBpZiAobm9ybWFsaXplZFZhbHVlID09PSBudWxsKSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgbm9ybWFsaXplZFZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIERlZmF1bHREeW5hbWljUHJvcGVydHkgZXh0ZW5kcyBEeW5hbWljQXR0cmlidXRlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBub3JtYWxpemVkTmFtZTogc3RyaW5nLCBhdHRyaWJ1dGU6IEF0dHJpYnV0ZUN1cnNvcikge1xuICAgIHN1cGVyKGF0dHJpYnV0ZSk7XG4gIH1cblxuICB2YWx1ZTogdW5rbm93bjtcbiAgc2V0KGRvbTogRWxlbWVudEJ1aWxkZXIsIHZhbHVlOiB1bmtub3duLCBfZW52OiBFbnZpcm9ubWVudCk6IHZvaWQge1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBkb20uX19zZXRQcm9wZXJ0eSh0aGlzLm5vcm1hbGl6ZWROYW1lLCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKHZhbHVlOiB1bmtub3duLCBfZW52OiBFbnZpcm9ubWVudCk6IHZvaWQge1xuICAgIGxldCB7IGVsZW1lbnQgfSA9IHRoaXMuYXR0cmlidXRlO1xuXG4gICAgaWYgKHRoaXMudmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAoZWxlbWVudCBhcyBhbnkpW3RoaXMubm9ybWFsaXplZE5hbWVdID0gdGhpcy52YWx1ZSA9IHZhbHVlO1xuXG4gICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCByZW1vdmVBdHRyaWJ1dGUoKSB7XG4gICAgLy8gVE9ETyB0aGlzIHN1Y2tzIGJ1dCB0byBwcmVzZXJ2ZSBwcm9wZXJ0aWVzIGZpcnN0IGFuZCB0byBtZWV0IGN1cnJlbnRcbiAgICAvLyBzZW1hbnRpY3Mgd2UgbXVzdCBkbyB0aGlzLlxuICAgIGxldCB7IGVsZW1lbnQsIG5hbWVzcGFjZSB9ID0gdGhpcy5hdHRyaWJ1dGU7XG5cbiAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgdGhpcy5ub3JtYWxpemVkTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHRoaXMubm9ybWFsaXplZE5hbWUpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU2FmZUR5bmFtaWNQcm9wZXJ0eSBleHRlbmRzIERlZmF1bHREeW5hbWljUHJvcGVydHkge1xuICBzZXQoZG9tOiBFbGVtZW50QnVpbGRlciwgdmFsdWU6IHVua25vd24sIGVudjogRW52aXJvbm1lbnQpOiB2b2lkIHtcbiAgICBsZXQgeyBlbGVtZW50LCBuYW1lIH0gPSB0aGlzLmF0dHJpYnV0ZTtcbiAgICBsZXQgc2FuaXRpemVkID0gc2FuaXRpemVBdHRyaWJ1dGVWYWx1ZShlbGVtZW50LCBuYW1lLCB2YWx1ZSk7XG4gICAgc3VwZXIuc2V0KGRvbSwgc2FuaXRpemVkLCBlbnYpO1xuICB9XG5cbiAgdXBkYXRlKHZhbHVlOiB1bmtub3duLCBlbnY6IEVudmlyb25tZW50KTogdm9pZCB7XG4gICAgbGV0IHsgZWxlbWVudCwgbmFtZSB9ID0gdGhpcy5hdHRyaWJ1dGU7XG4gICAgbGV0IHNhbml0aXplZCA9IHNhbml0aXplQXR0cmlidXRlVmFsdWUoZWxlbWVudCwgbmFtZSwgdmFsdWUpO1xuICAgIHN1cGVyLnVwZGF0ZShzYW5pdGl6ZWQsIGVudik7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNhZmVEeW5hbWljQXR0cmlidXRlIGV4dGVuZHMgU2ltcGxlRHluYW1pY0F0dHJpYnV0ZSB7XG4gIHNldChkb206IEVsZW1lbnRCdWlsZGVyLCB2YWx1ZTogdW5rbm93biwgZW52OiBFbnZpcm9ubWVudCk6IHZvaWQge1xuICAgIGxldCB7IGVsZW1lbnQsIG5hbWUgfSA9IHRoaXMuYXR0cmlidXRlO1xuICAgIGxldCBzYW5pdGl6ZWQgPSBzYW5pdGl6ZUF0dHJpYnV0ZVZhbHVlKGVsZW1lbnQsIG5hbWUsIHZhbHVlKTtcbiAgICBzdXBlci5zZXQoZG9tLCBzYW5pdGl6ZWQsIGVudik7XG4gIH1cblxuICB1cGRhdGUodmFsdWU6IHVua25vd24sIGVudjogRW52aXJvbm1lbnQpOiB2b2lkIHtcbiAgICBsZXQgeyBlbGVtZW50LCBuYW1lIH0gPSB0aGlzLmF0dHJpYnV0ZTtcbiAgICBsZXQgc2FuaXRpemVkID0gc2FuaXRpemVBdHRyaWJ1dGVWYWx1ZShlbGVtZW50LCBuYW1lLCB2YWx1ZSk7XG4gICAgc3VwZXIudXBkYXRlKHNhbml0aXplZCwgZW52KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgSW5wdXRWYWx1ZUR5bmFtaWNBdHRyaWJ1dGUgZXh0ZW5kcyBEZWZhdWx0RHluYW1pY1Byb3BlcnR5IHtcbiAgc2V0KGRvbTogRWxlbWVudEJ1aWxkZXIsIHZhbHVlOiB1bmtub3duKSB7XG4gICAgZG9tLl9fc2V0UHJvcGVydHkoJ3ZhbHVlJywgbm9ybWFsaXplU3RyaW5nVmFsdWUodmFsdWUpKTtcbiAgfVxuXG4gIHVwZGF0ZSh2YWx1ZTogdW5rbm93bikge1xuICAgIGxldCBpbnB1dCA9IGNhc3RUb0Jyb3dzZXIodGhpcy5hdHRyaWJ1dGUuZWxlbWVudCwgWydpbnB1dCcsICd0ZXh0YXJlYSddKTtcbiAgICBsZXQgY3VycmVudFZhbHVlID0gaW5wdXQudmFsdWU7XG4gICAgbGV0IG5vcm1hbGl6ZWRWYWx1ZSA9IG5vcm1hbGl6ZVN0cmluZ1ZhbHVlKHZhbHVlKTtcbiAgICBpZiAoY3VycmVudFZhbHVlICE9PSBub3JtYWxpemVkVmFsdWUpIHtcbiAgICAgIGlucHV0LnZhbHVlID0gbm9ybWFsaXplZFZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgT3B0aW9uU2VsZWN0ZWREeW5hbWljQXR0cmlidXRlIGV4dGVuZHMgRGVmYXVsdER5bmFtaWNQcm9wZXJ0eSB7XG4gIHNldChkb206IEVsZW1lbnRCdWlsZGVyLCB2YWx1ZTogdW5rbm93bik6IHZvaWQge1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgZG9tLl9fc2V0UHJvcGVydHkoJ3NlbGVjdGVkJywgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKHZhbHVlOiB1bmtub3duKTogdm9pZCB7XG4gICAgbGV0IG9wdGlvbiA9IGNhc3RUb0Jyb3dzZXIodGhpcy5hdHRyaWJ1dGUuZWxlbWVudCwgJ29wdGlvbicpO1xuXG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb24uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNPcHRpb25TZWxlY3RlZCh0YWdOYW1lOiBzdHJpbmcsIGF0dHJpYnV0ZTogc3RyaW5nKSB7XG4gIHJldHVybiB0YWdOYW1lID09PSAnT1BUSU9OJyAmJiBhdHRyaWJ1dGUgPT09ICdzZWxlY3RlZCc7XG59XG5cbmZ1bmN0aW9uIGlzVXNlcklucHV0VmFsdWUodGFnTmFtZTogc3RyaW5nLCBhdHRyaWJ1dGU6IHN0cmluZykge1xuICByZXR1cm4gKHRhZ05hbWUgPT09ICdJTlBVVCcgfHwgdGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykgJiYgYXR0cmlidXRlID09PSAndmFsdWUnO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZTogdW5rbm93bik6IE9wdGlvbjxzdHJpbmc+IHtcbiAgaWYgKFxuICAgIHZhbHVlID09PSBmYWxzZSB8fFxuICAgIHZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICB2YWx1ZSA9PT0gbnVsbCB8fFxuICAgIHR5cGVvZiAodmFsdWUgYXMgRGljdCkudG9TdHJpbmcgPT09ICd1bmRlZmluZWQnXG4gICkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICAvLyBvbmNsaWNrIGZ1bmN0aW9uIGV0YyBpbiBTU1JcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG59XG5cbmxldCBEZWJ1Z1N0eWxlQXR0cmlidXRlTWFuYWdlcjoge1xuICBuZXcgKGF0dHJpYnV0ZTogQXR0cmlidXRlQ3Vyc29yKTogQXR0cmlidXRlT3BlcmF0aW9uO1xufTtcblxuaWYgKERFQlVHKSB7XG4gIERlYnVnU3R5bGVBdHRyaWJ1dGVNYW5hZ2VyID0gY2xhc3MgZXh0ZW5kcyBTaW1wbGVEeW5hbWljQXR0cmlidXRlIHtcbiAgICBzZXQoZG9tOiBFbGVtZW50QnVpbGRlciwgdmFsdWU6IHVua25vd24sIGVudjogRW52aXJvbm1lbnQpOiB2b2lkIHtcbiAgICAgIHdhcm5JZlN0eWxlTm90VHJ1c3RlZCh2YWx1ZSk7XG5cbiAgICAgIHN1cGVyLnNldChkb20sIHZhbHVlLCBlbnYpO1xuICAgIH1cbiAgICB1cGRhdGUodmFsdWU6IHVua25vd24sIGVudjogRW52aXJvbm1lbnQpOiB2b2lkIHtcbiAgICAgIHdhcm5JZlN0eWxlTm90VHJ1c3RlZCh2YWx1ZSk7XG5cbiAgICAgIHN1cGVyLnVwZGF0ZSh2YWx1ZSwgZW52KTtcbiAgICB9XG4gIH07XG59XG4iLCJpbXBvcnQge1xuICBCb3VuZHMsXG4gIEN1cnNvcixcbiAgQ3Vyc29yU3RhY2tTeW1ib2wsXG4gIEVsZW1lbnRCdWlsZGVyLFxuICBFbGVtZW50T3BlcmF0aW9ucyxcbiAgRW52aXJvbm1lbnQsXG4gIEdsaW1tZXJUcmVlQ2hhbmdlcyxcbiAgR2xpbW1lclRyZWVDb25zdHJ1Y3Rpb24sXG4gIExpdmVCbG9jayxcbiAgTWF5YmUsXG4gIE9wdGlvbixcbiAgVXBkYXRhYmxlQmxvY2ssXG4gIE1vZGlmaWVySW5zdGFuY2UsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgYXNzZXJ0LCBleHBlY3QsIFN0YWNrLCBzeW1ib2wgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7XG4gIEF0dHJOYW1lc3BhY2UsXG4gIFNpbXBsZUNvbW1lbnQsXG4gIFNpbXBsZURvY3VtZW50RnJhZ21lbnQsXG4gIFNpbXBsZUVsZW1lbnQsXG4gIFNpbXBsZU5vZGUsXG4gIFNpbXBsZVRleHQsXG59IGZyb20gJ0BzaW1wbGUtZG9tL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBjbGVhciwgQ29uY3JldGVCb3VuZHMsIEN1cnNvckltcGwsIFNpbmdsZU5vZGVCb3VuZHMgfSBmcm9tICcuLi9ib3VuZHMnO1xuaW1wb3J0IHsgZGVzdHJveSwgcmVnaXN0ZXJEZXN0cnVjdG9yIH0gZnJvbSAnQGdsaW1tZXIvZGVzdHJveWFibGUnO1xuaW1wb3J0IHsgRHluYW1pY0F0dHJpYnV0ZSwgZHluYW1pY0F0dHJpYnV0ZSB9IGZyb20gJy4vYXR0cmlidXRlcy9keW5hbWljJztcblxuZXhwb3J0IGludGVyZmFjZSBGaXJzdE5vZGUge1xuICBmaXJzdE5vZGUoKTogU2ltcGxlTm9kZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMYXN0Tm9kZSB7XG4gIGxhc3ROb2RlKCk6IFNpbXBsZU5vZGU7XG59XG5cbmNsYXNzIEZpcnN0IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBub2RlOiBTaW1wbGVOb2RlKSB7fVxuXG4gIGZpcnN0Tm9kZSgpOiBTaW1wbGVOb2RlIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlO1xuICB9XG59XG5cbmNsYXNzIExhc3Qge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIG5vZGU6IFNpbXBsZU5vZGUpIHt9XG5cbiAgbGFzdE5vZGUoKTogU2ltcGxlTm9kZSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRnJhZ21lbnQgaW1wbGVtZW50cyBCb3VuZHMge1xuICBwcml2YXRlIGJvdW5kczogQm91bmRzO1xuXG4gIGNvbnN0cnVjdG9yKGJvdW5kczogQm91bmRzKSB7XG4gICAgdGhpcy5ib3VuZHMgPSBib3VuZHM7XG4gIH1cblxuICBwYXJlbnRFbGVtZW50KCk6IFNpbXBsZUVsZW1lbnQge1xuICAgIHJldHVybiB0aGlzLmJvdW5kcy5wYXJlbnRFbGVtZW50KCk7XG4gIH1cblxuICBmaXJzdE5vZGUoKTogU2ltcGxlTm9kZSB7XG4gICAgcmV0dXJuIHRoaXMuYm91bmRzLmZpcnN0Tm9kZSgpO1xuICB9XG5cbiAgbGFzdE5vZGUoKTogU2ltcGxlTm9kZSB7XG4gICAgcmV0dXJuIHRoaXMuYm91bmRzLmxhc3ROb2RlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IENVUlNPUl9TVEFDSzogQ3Vyc29yU3RhY2tTeW1ib2wgPSBzeW1ib2woJ0NVUlNPUl9TVEFDSycpO1xuXG5leHBvcnQgY2xhc3MgTmV3RWxlbWVudEJ1aWxkZXIgaW1wbGVtZW50cyBFbGVtZW50QnVpbGRlciB7XG4gIHB1YmxpYyBkb206IEdsaW1tZXJUcmVlQ29uc3RydWN0aW9uO1xuICBwdWJsaWMgdXBkYXRlT3BlcmF0aW9uczogR2xpbW1lclRyZWVDaGFuZ2VzO1xuICBwdWJsaWMgY29uc3RydWN0aW5nOiBPcHRpb248U2ltcGxlRWxlbWVudD4gPSBudWxsO1xuICBwdWJsaWMgb3BlcmF0aW9uczogT3B0aW9uPEVsZW1lbnRPcGVyYXRpb25zPiA9IG51bGw7XG4gIHByaXZhdGUgZW52OiBFbnZpcm9ubWVudDtcblxuICBbQ1VSU09SX1NUQUNLXSA9IG5ldyBTdGFjazxDdXJzb3I+KCk7XG4gIHByaXZhdGUgbW9kaWZpZXJTdGFjayA9IG5ldyBTdGFjazxPcHRpb248TW9kaWZpZXJJbnN0YW5jZVtdPj4oKTtcbiAgcHJpdmF0ZSBibG9ja1N0YWNrID0gbmV3IFN0YWNrPExpdmVCbG9jaz4oKTtcblxuICBzdGF0aWMgZm9ySW5pdGlhbFJlbmRlcihlbnY6IEVudmlyb25tZW50LCBjdXJzb3I6IEN1cnNvckltcGwpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMoZW52LCBjdXJzb3IuZWxlbWVudCwgY3Vyc29yLm5leHRTaWJsaW5nKS5pbml0aWFsaXplKCk7XG4gIH1cblxuICBzdGF0aWMgcmVzdW1lKGVudjogRW52aXJvbm1lbnQsIGJsb2NrOiBVcGRhdGFibGVCbG9jayk6IE5ld0VsZW1lbnRCdWlsZGVyIHtcbiAgICBsZXQgcGFyZW50Tm9kZSA9IGJsb2NrLnBhcmVudEVsZW1lbnQoKTtcbiAgICBsZXQgbmV4dFNpYmxpbmcgPSBibG9jay5yZXNldChlbnYpO1xuXG4gICAgbGV0IHN0YWNrID0gbmV3IHRoaXMoZW52LCBwYXJlbnROb2RlLCBuZXh0U2libGluZykuaW5pdGlhbGl6ZSgpO1xuICAgIHN0YWNrLnB1c2hMaXZlQmxvY2soYmxvY2spO1xuXG4gICAgcmV0dXJuIHN0YWNrO1xuICB9XG5cbiAgY29uc3RydWN0b3IoZW52OiBFbnZpcm9ubWVudCwgcGFyZW50Tm9kZTogU2ltcGxlRWxlbWVudCwgbmV4dFNpYmxpbmc6IE9wdGlvbjxTaW1wbGVOb2RlPikge1xuICAgIHRoaXMucHVzaEVsZW1lbnQocGFyZW50Tm9kZSwgbmV4dFNpYmxpbmcpO1xuXG4gICAgdGhpcy5lbnYgPSBlbnY7XG4gICAgdGhpcy5kb20gPSBlbnYuZ2V0QXBwZW5kT3BlcmF0aW9ucygpO1xuICAgIHRoaXMudXBkYXRlT3BlcmF0aW9ucyA9IGVudi5nZXRET00oKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBpbml0aWFsaXplKCk6IHRoaXMge1xuICAgIHRoaXMucHVzaFNpbXBsZUJsb2NrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkZWJ1Z0Jsb2NrcygpOiBMaXZlQmxvY2tbXSB7XG4gICAgcmV0dXJuIHRoaXMuYmxvY2tTdGFjay50b0FycmF5KCk7XG4gIH1cblxuICBnZXQgZWxlbWVudCgpOiBTaW1wbGVFbGVtZW50IHtcbiAgICByZXR1cm4gdGhpc1tDVVJTT1JfU1RBQ0tdLmN1cnJlbnQhLmVsZW1lbnQ7XG4gIH1cblxuICBnZXQgbmV4dFNpYmxpbmcoKTogT3B0aW9uPFNpbXBsZU5vZGU+IHtcbiAgICByZXR1cm4gdGhpc1tDVVJTT1JfU1RBQ0tdLmN1cnJlbnQhLm5leHRTaWJsaW5nO1xuICB9XG5cbiAgZ2V0IGhhc0Jsb2NrcygpIHtcbiAgICByZXR1cm4gdGhpcy5ibG9ja1N0YWNrLnNpemUgPiAwO1xuICB9XG5cbiAgcHJvdGVjdGVkIGJsb2NrKCk6IExpdmVCbG9jayB7XG4gICAgcmV0dXJuIGV4cGVjdCh0aGlzLmJsb2NrU3RhY2suY3VycmVudCwgJ0V4cGVjdGVkIGEgY3VycmVudCBsaXZlIGJsb2NrJyk7XG4gIH1cblxuICBwb3BFbGVtZW50KCkge1xuICAgIHRoaXNbQ1VSU09SX1NUQUNLXS5wb3AoKTtcbiAgICBleHBlY3QodGhpc1tDVVJTT1JfU1RBQ0tdLmN1cnJlbnQsIFwiY2FuJ3QgcG9wIHBhc3QgdGhlIGxhc3QgZWxlbWVudFwiKTtcbiAgfVxuXG4gIHB1c2hTaW1wbGVCbG9jaygpOiBMaXZlQmxvY2sge1xuICAgIHJldHVybiB0aGlzLnB1c2hMaXZlQmxvY2sobmV3IFNpbXBsZUxpdmVCbG9jayh0aGlzLmVsZW1lbnQpKTtcbiAgfVxuXG4gIHB1c2hVcGRhdGFibGVCbG9jaygpOiBVcGRhdGFibGVCbG9ja0ltcGwge1xuICAgIHJldHVybiB0aGlzLnB1c2hMaXZlQmxvY2sobmV3IFVwZGF0YWJsZUJsb2NrSW1wbCh0aGlzLmVsZW1lbnQpKTtcbiAgfVxuXG4gIHB1c2hCbG9ja0xpc3QobGlzdDogTGl2ZUJsb2NrW10pOiBMaXZlQmxvY2tMaXN0IHtcbiAgICByZXR1cm4gdGhpcy5wdXNoTGl2ZUJsb2NrKG5ldyBMaXZlQmxvY2tMaXN0KHRoaXMuZWxlbWVudCwgbGlzdCkpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHB1c2hMaXZlQmxvY2s8VCBleHRlbmRzIExpdmVCbG9jaz4oYmxvY2s6IFQsIGlzUmVtb3RlID0gZmFsc2UpOiBUIHtcbiAgICBsZXQgY3VycmVudCA9IHRoaXMuYmxvY2tTdGFjay5jdXJyZW50O1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIGlmICghaXNSZW1vdGUpIHtcbiAgICAgICAgY3VycmVudC5kaWRBcHBlbmRCb3VuZHMoYmxvY2spO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX19vcGVuQmxvY2soKTtcbiAgICB0aGlzLmJsb2NrU3RhY2sucHVzaChibG9jayk7XG4gICAgcmV0dXJuIGJsb2NrO1xuICB9XG5cbiAgcG9wQmxvY2soKTogTGl2ZUJsb2NrIHtcbiAgICB0aGlzLmJsb2NrKCkuZmluYWxpemUodGhpcyk7XG4gICAgdGhpcy5fX2Nsb3NlQmxvY2soKTtcbiAgICByZXR1cm4gZXhwZWN0KHRoaXMuYmxvY2tTdGFjay5wb3AoKSwgJ0V4cGVjdGVkIHBvcEJsb2NrIHRvIHJldHVybiBhIGJsb2NrJyk7XG4gIH1cblxuICBfX29wZW5CbG9jaygpOiB2b2lkIHt9XG4gIF9fY2xvc2VCbG9jaygpOiB2b2lkIHt9XG5cbiAgLy8gdG9kbyByZXR1cm4gc2VlbXMgdW51c2VkXG4gIG9wZW5FbGVtZW50KHRhZzogc3RyaW5nKTogU2ltcGxlRWxlbWVudCB7XG4gICAgbGV0IGVsZW1lbnQgPSB0aGlzLl9fb3BlbkVsZW1lbnQodGFnKTtcbiAgICB0aGlzLmNvbnN0cnVjdGluZyA9IGVsZW1lbnQ7XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIF9fb3BlbkVsZW1lbnQodGFnOiBzdHJpbmcpOiBTaW1wbGVFbGVtZW50IHtcbiAgICByZXR1cm4gdGhpcy5kb20uY3JlYXRlRWxlbWVudCh0YWcsIHRoaXMuZWxlbWVudCk7XG4gIH1cblxuICBmbHVzaEVsZW1lbnQobW9kaWZpZXJzOiBPcHRpb248TW9kaWZpZXJJbnN0YW5jZVtdPikge1xuICAgIGxldCBwYXJlbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgbGV0IGVsZW1lbnQgPSBleHBlY3QoXG4gICAgICB0aGlzLmNvbnN0cnVjdGluZyxcbiAgICAgIGBmbHVzaEVsZW1lbnQgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW4gY29uc3RydWN0aW5nIGFuIGVsZW1lbnRgXG4gICAgKTtcblxuICAgIHRoaXMuX19mbHVzaEVsZW1lbnQocGFyZW50LCBlbGVtZW50KTtcblxuICAgIHRoaXMuY29uc3RydWN0aW5nID0gbnVsbDtcbiAgICB0aGlzLm9wZXJhdGlvbnMgPSBudWxsO1xuXG4gICAgdGhpcy5wdXNoTW9kaWZpZXJzKG1vZGlmaWVycyk7XG4gICAgdGhpcy5wdXNoRWxlbWVudChlbGVtZW50LCBudWxsKTtcbiAgICB0aGlzLmRpZE9wZW5FbGVtZW50KGVsZW1lbnQpO1xuICB9XG5cbiAgX19mbHVzaEVsZW1lbnQocGFyZW50OiBTaW1wbGVFbGVtZW50LCBjb25zdHJ1Y3Rpbmc6IFNpbXBsZUVsZW1lbnQpIHtcbiAgICB0aGlzLmRvbS5pbnNlcnRCZWZvcmUocGFyZW50LCBjb25zdHJ1Y3RpbmcsIHRoaXMubmV4dFNpYmxpbmcpO1xuICB9XG5cbiAgY2xvc2VFbGVtZW50KCk6IE9wdGlvbjxNb2RpZmllckluc3RhbmNlW10+IHtcbiAgICB0aGlzLndpbGxDbG9zZUVsZW1lbnQoKTtcbiAgICB0aGlzLnBvcEVsZW1lbnQoKTtcbiAgICByZXR1cm4gdGhpcy5wb3BNb2RpZmllcnMoKTtcbiAgfVxuXG4gIHB1c2hSZW1vdGVFbGVtZW50KFxuICAgIGVsZW1lbnQ6IFNpbXBsZUVsZW1lbnQsXG4gICAgZ3VpZDogc3RyaW5nLFxuICAgIGluc2VydEJlZm9yZTogTWF5YmU8U2ltcGxlTm9kZT5cbiAgKTogT3B0aW9uPFJlbW90ZUxpdmVCbG9jaz4ge1xuICAgIHJldHVybiB0aGlzLl9fcHVzaFJlbW90ZUVsZW1lbnQoZWxlbWVudCwgZ3VpZCwgaW5zZXJ0QmVmb3JlKTtcbiAgfVxuXG4gIF9fcHVzaFJlbW90ZUVsZW1lbnQoXG4gICAgZWxlbWVudDogU2ltcGxlRWxlbWVudCxcbiAgICBfZ3VpZDogc3RyaW5nLFxuICAgIGluc2VydEJlZm9yZTogTWF5YmU8U2ltcGxlTm9kZT5cbiAgKTogT3B0aW9uPFJlbW90ZUxpdmVCbG9jaz4ge1xuICAgIHRoaXMucHVzaEVsZW1lbnQoZWxlbWVudCwgaW5zZXJ0QmVmb3JlKTtcblxuICAgIGlmIChpbnNlcnRCZWZvcmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgd2hpbGUgKGVsZW1lbnQubGFzdENoaWxkKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoZWxlbWVudC5sYXN0Q2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBibG9jayA9IG5ldyBSZW1vdGVMaXZlQmxvY2soZWxlbWVudCk7XG5cbiAgICByZXR1cm4gdGhpcy5wdXNoTGl2ZUJsb2NrKGJsb2NrLCB0cnVlKTtcbiAgfVxuXG4gIHBvcFJlbW90ZUVsZW1lbnQoKSB7XG4gICAgdGhpcy5wb3BCbG9jaygpO1xuICAgIHRoaXMucG9wRWxlbWVudCgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHB1c2hFbGVtZW50KGVsZW1lbnQ6IFNpbXBsZUVsZW1lbnQsIG5leHRTaWJsaW5nOiBNYXliZTxTaW1wbGVOb2RlPiA9IG51bGwpIHtcbiAgICB0aGlzW0NVUlNPUl9TVEFDS10ucHVzaChuZXcgQ3Vyc29ySW1wbChlbGVtZW50LCBuZXh0U2libGluZykpO1xuICB9XG5cbiAgcHJpdmF0ZSBwdXNoTW9kaWZpZXJzKG1vZGlmaWVyczogT3B0aW9uPE1vZGlmaWVySW5zdGFuY2VbXT4pOiB2b2lkIHtcbiAgICB0aGlzLm1vZGlmaWVyU3RhY2sucHVzaChtb2RpZmllcnMpO1xuICB9XG5cbiAgcHJpdmF0ZSBwb3BNb2RpZmllcnMoKTogT3B0aW9uPE1vZGlmaWVySW5zdGFuY2VbXT4ge1xuICAgIHJldHVybiB0aGlzLm1vZGlmaWVyU3RhY2sucG9wKCk7XG4gIH1cblxuICBkaWRBcHBlbmRCb3VuZHMoYm91bmRzOiBCb3VuZHMpOiBCb3VuZHMge1xuICAgIHRoaXMuYmxvY2soKS5kaWRBcHBlbmRCb3VuZHMoYm91bmRzKTtcbiAgICByZXR1cm4gYm91bmRzO1xuICB9XG5cbiAgZGlkQXBwZW5kTm9kZTxUIGV4dGVuZHMgU2ltcGxlTm9kZT4obm9kZTogVCk6IFQge1xuICAgIHRoaXMuYmxvY2soKS5kaWRBcHBlbmROb2RlKG5vZGUpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZGlkT3BlbkVsZW1lbnQoZWxlbWVudDogU2ltcGxlRWxlbWVudCk6IFNpbXBsZUVsZW1lbnQge1xuICAgIHRoaXMuYmxvY2soKS5vcGVuRWxlbWVudChlbGVtZW50KTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHdpbGxDbG9zZUVsZW1lbnQoKSB7XG4gICAgdGhpcy5ibG9jaygpLmNsb3NlRWxlbWVudCgpO1xuICB9XG5cbiAgYXBwZW5kVGV4dChzdHJpbmc6IHN0cmluZyk6IFNpbXBsZVRleHQge1xuICAgIHJldHVybiB0aGlzLmRpZEFwcGVuZE5vZGUodGhpcy5fX2FwcGVuZFRleHQoc3RyaW5nKSk7XG4gIH1cblxuICBfX2FwcGVuZFRleHQodGV4dDogc3RyaW5nKTogU2ltcGxlVGV4dCB7XG4gICAgbGV0IHsgZG9tLCBlbGVtZW50LCBuZXh0U2libGluZyB9ID0gdGhpcztcbiAgICBsZXQgbm9kZSA9IGRvbS5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbiAgICBkb20uaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIG5vZGUsIG5leHRTaWJsaW5nKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIF9fYXBwZW5kTm9kZShub2RlOiBTaW1wbGVOb2RlKTogU2ltcGxlTm9kZSB7XG4gICAgdGhpcy5kb20uaW5zZXJ0QmVmb3JlKHRoaXMuZWxlbWVudCwgbm9kZSwgdGhpcy5uZXh0U2libGluZyk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBfX2FwcGVuZEZyYWdtZW50KGZyYWdtZW50OiBTaW1wbGVEb2N1bWVudEZyYWdtZW50KTogQm91bmRzIHtcbiAgICBsZXQgZmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICBsZXQgcmV0ID0gbmV3IENvbmNyZXRlQm91bmRzKHRoaXMuZWxlbWVudCwgZmlyc3QsIGZyYWdtZW50Lmxhc3RDaGlsZCEpO1xuICAgICAgdGhpcy5kb20uaW5zZXJ0QmVmb3JlKHRoaXMuZWxlbWVudCwgZnJhZ21lbnQsIHRoaXMubmV4dFNpYmxpbmcpO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBTaW5nbGVOb2RlQm91bmRzKHRoaXMuZWxlbWVudCwgdGhpcy5fX2FwcGVuZENvbW1lbnQoJycpKTtcbiAgICB9XG4gIH1cblxuICBfX2FwcGVuZEhUTUwoaHRtbDogc3RyaW5nKTogQm91bmRzIHtcbiAgICByZXR1cm4gdGhpcy5kb20uaW5zZXJ0SFRNTEJlZm9yZSh0aGlzLmVsZW1lbnQsIHRoaXMubmV4dFNpYmxpbmcsIGh0bWwpO1xuICB9XG5cbiAgYXBwZW5kRHluYW1pY0hUTUwodmFsdWU6IHN0cmluZyk6IHZvaWQge1xuICAgIGxldCBib3VuZHMgPSB0aGlzLnRydXN0ZWRDb250ZW50KHZhbHVlKTtcbiAgICB0aGlzLmRpZEFwcGVuZEJvdW5kcyhib3VuZHMpO1xuICB9XG5cbiAgYXBwZW5kRHluYW1pY1RleHQodmFsdWU6IHN0cmluZyk6IFNpbXBsZVRleHQge1xuICAgIGxldCBub2RlID0gdGhpcy51bnRydXN0ZWRDb250ZW50KHZhbHVlKTtcbiAgICB0aGlzLmRpZEFwcGVuZE5vZGUobm9kZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBhcHBlbmREeW5hbWljRnJhZ21lbnQodmFsdWU6IFNpbXBsZURvY3VtZW50RnJhZ21lbnQpOiB2b2lkIHtcbiAgICBsZXQgYm91bmRzID0gdGhpcy5fX2FwcGVuZEZyYWdtZW50KHZhbHVlKTtcbiAgICB0aGlzLmRpZEFwcGVuZEJvdW5kcyhib3VuZHMpO1xuICB9XG5cbiAgYXBwZW5kRHluYW1pY05vZGUodmFsdWU6IFNpbXBsZU5vZGUpOiB2b2lkIHtcbiAgICBsZXQgbm9kZSA9IHRoaXMuX19hcHBlbmROb2RlKHZhbHVlKTtcbiAgICBsZXQgYm91bmRzID0gbmV3IFNpbmdsZU5vZGVCb3VuZHModGhpcy5lbGVtZW50LCBub2RlKTtcbiAgICB0aGlzLmRpZEFwcGVuZEJvdW5kcyhib3VuZHMpO1xuICB9XG5cbiAgcHJpdmF0ZSB0cnVzdGVkQ29udGVudCh2YWx1ZTogc3RyaW5nKTogQm91bmRzIHtcbiAgICByZXR1cm4gdGhpcy5fX2FwcGVuZEhUTUwodmFsdWUpO1xuICB9XG5cbiAgcHJpdmF0ZSB1bnRydXN0ZWRDb250ZW50KHZhbHVlOiBzdHJpbmcpOiBTaW1wbGVUZXh0IHtcbiAgICByZXR1cm4gdGhpcy5fX2FwcGVuZFRleHQodmFsdWUpO1xuICB9XG5cbiAgYXBwZW5kQ29tbWVudChzdHJpbmc6IHN0cmluZyk6IFNpbXBsZUNvbW1lbnQge1xuICAgIHJldHVybiB0aGlzLmRpZEFwcGVuZE5vZGUodGhpcy5fX2FwcGVuZENvbW1lbnQoc3RyaW5nKSk7XG4gIH1cblxuICBfX2FwcGVuZENvbW1lbnQoc3RyaW5nOiBzdHJpbmcpOiBTaW1wbGVDb21tZW50IHtcbiAgICBsZXQgeyBkb20sIGVsZW1lbnQsIG5leHRTaWJsaW5nIH0gPSB0aGlzO1xuICAgIGxldCBub2RlID0gZG9tLmNyZWF0ZUNvbW1lbnQoc3RyaW5nKTtcbiAgICBkb20uaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIG5vZGUsIG5leHRTaWJsaW5nKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIF9fc2V0QXR0cmlidXRlKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZywgbmFtZXNwYWNlOiBPcHRpb248QXR0ck5hbWVzcGFjZT4pOiB2b2lkIHtcbiAgICB0aGlzLmRvbS5zZXRBdHRyaWJ1dGUodGhpcy5jb25zdHJ1Y3RpbmchLCBuYW1lLCB2YWx1ZSwgbmFtZXNwYWNlKTtcbiAgfVxuXG4gIF9fc2V0UHJvcGVydHkobmFtZTogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IHZvaWQge1xuICAgICh0aGlzLmNvbnN0cnVjdGluZyEgYXMgYW55KVtuYW1lXSA9IHZhbHVlO1xuICB9XG5cbiAgc2V0U3RhdGljQXR0cmlidXRlKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZywgbmFtZXNwYWNlOiBPcHRpb248QXR0ck5hbWVzcGFjZT4pOiB2b2lkIHtcbiAgICB0aGlzLl9fc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlLCBuYW1lc3BhY2UpO1xuICB9XG5cbiAgc2V0RHluYW1pY0F0dHJpYnV0ZShcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgdmFsdWU6IHVua25vd24sXG4gICAgdHJ1c3Rpbmc6IGJvb2xlYW4sXG4gICAgbmFtZXNwYWNlOiBPcHRpb248QXR0ck5hbWVzcGFjZT5cbiAgKTogRHluYW1pY0F0dHJpYnV0ZSB7XG4gICAgbGV0IGVsZW1lbnQgPSB0aGlzLmNvbnN0cnVjdGluZyE7XG4gICAgbGV0IGF0dHJpYnV0ZSA9IGR5bmFtaWNBdHRyaWJ1dGUoZWxlbWVudCwgbmFtZSwgbmFtZXNwYWNlLCB0cnVzdGluZyk7XG4gICAgYXR0cmlidXRlLnNldCh0aGlzLCB2YWx1ZSwgdGhpcy5lbnYpO1xuICAgIHJldHVybiBhdHRyaWJ1dGU7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNpbXBsZUxpdmVCbG9jayBpbXBsZW1lbnRzIExpdmVCbG9jayB7XG4gIHByb3RlY3RlZCBmaXJzdDogT3B0aW9uPEZpcnN0Tm9kZT4gPSBudWxsO1xuICBwcm90ZWN0ZWQgbGFzdDogT3B0aW9uPExhc3ROb2RlPiA9IG51bGw7XG4gIHByb3RlY3RlZCBuZXN0aW5nID0gMDtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHBhcmVudDogU2ltcGxlRWxlbWVudCkge31cblxuICBwYXJlbnRFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnBhcmVudDtcbiAgfVxuXG4gIGZpcnN0Tm9kZSgpOiBTaW1wbGVOb2RlIHtcbiAgICBsZXQgZmlyc3QgPSBleHBlY3QoXG4gICAgICB0aGlzLmZpcnN0LFxuICAgICAgJ2Nhbm5vdCBjYWxsIGBmaXJzdE5vZGUoKWAgd2hpbGUgYFNpbXBsZUxpdmVCbG9ja2AgaXMgc3RpbGwgaW5pdGlhbGl6aW5nJ1xuICAgICk7XG5cbiAgICByZXR1cm4gZmlyc3QuZmlyc3ROb2RlKCk7XG4gIH1cblxuICBsYXN0Tm9kZSgpOiBTaW1wbGVOb2RlIHtcbiAgICBsZXQgbGFzdCA9IGV4cGVjdChcbiAgICAgIHRoaXMubGFzdCxcbiAgICAgICdjYW5ub3QgY2FsbCBgbGFzdE5vZGUoKWAgd2hpbGUgYFNpbXBsZUxpdmVCbG9ja2AgaXMgc3RpbGwgaW5pdGlhbGl6aW5nJ1xuICAgICk7XG5cbiAgICByZXR1cm4gbGFzdC5sYXN0Tm9kZSgpO1xuICB9XG5cbiAgb3BlbkVsZW1lbnQoZWxlbWVudDogU2ltcGxlRWxlbWVudCkge1xuICAgIHRoaXMuZGlkQXBwZW5kTm9kZShlbGVtZW50KTtcbiAgICB0aGlzLm5lc3RpbmcrKztcbiAgfVxuXG4gIGNsb3NlRWxlbWVudCgpIHtcbiAgICB0aGlzLm5lc3RpbmctLTtcbiAgfVxuXG4gIGRpZEFwcGVuZE5vZGUobm9kZTogU2ltcGxlTm9kZSkge1xuICAgIGlmICh0aGlzLm5lc3RpbmcgIT09IDApIHJldHVybjtcblxuICAgIGlmICghdGhpcy5maXJzdCkge1xuICAgICAgdGhpcy5maXJzdCA9IG5ldyBGaXJzdChub2RlKTtcbiAgICB9XG5cbiAgICB0aGlzLmxhc3QgPSBuZXcgTGFzdChub2RlKTtcbiAgfVxuXG4gIGRpZEFwcGVuZEJvdW5kcyhib3VuZHM6IEJvdW5kcykge1xuICAgIGlmICh0aGlzLm5lc3RpbmcgIT09IDApIHJldHVybjtcblxuICAgIGlmICghdGhpcy5maXJzdCkge1xuICAgICAgdGhpcy5maXJzdCA9IGJvdW5kcztcbiAgICB9XG5cbiAgICB0aGlzLmxhc3QgPSBib3VuZHM7XG4gIH1cblxuICBmaW5hbGl6ZShzdGFjazogRWxlbWVudEJ1aWxkZXIpIHtcbiAgICBpZiAodGhpcy5maXJzdCA9PT0gbnVsbCkge1xuICAgICAgc3RhY2suYXBwZW5kQ29tbWVudCgnJyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBSZW1vdGVMaXZlQmxvY2sgZXh0ZW5kcyBTaW1wbGVMaXZlQmxvY2sge1xuICBjb25zdHJ1Y3RvcihwYXJlbnQ6IFNpbXBsZUVsZW1lbnQpIHtcbiAgICBzdXBlcihwYXJlbnQpO1xuXG4gICAgcmVnaXN0ZXJEZXN0cnVjdG9yKHRoaXMsICgpID0+IHtcbiAgICAgIC8vIEluIGdlbmVyYWwsIHlvdSBvbmx5IG5lZWQgdG8gY2xlYXIgdGhlIHJvb3Qgb2YgYSBoaWVyYXJjaHksIGFuZCBzaG91bGQgbmV2ZXJcbiAgICAgIC8vIG5lZWQgdG8gY2xlYXIgYW55IGNoaWxkIG5vZGVzLiBUaGlzIGlzIGFuIGltcG9ydGFudCBjb25zdHJhaW50IHRoYXQgZ2l2ZXMgdXNcbiAgICAgIC8vIGEgc3Ryb25nIGd1YXJhbnRlZSB0aGF0IGNsZWFyaW5nIGEgc3VidHJlZSBpcyBhIHNpbmdsZSBET00gb3BlcmF0aW9uLlxuICAgICAgLy9cbiAgICAgIC8vIEJlY2F1c2UgcmVtb3RlIGJsb2NrcyBhcmUgbm90IG5vcm1hbGx5IHBoeXNpY2FsbHkgbmVzdGVkIGluc2lkZSBvZiB0aGUgdHJlZVxuICAgICAgLy8gdGhhdCB0aGV5IGFyZSBsb2dpY2FsbHkgbmVzdGVkIGluc2lkZSwgd2UgbWFudWFsbHkgY2xlYXIgcmVtb3RlIGJsb2NrcyB3aGVuXG4gICAgICAvLyBhIGxvZ2ljYWwgcGFyZW50IGlzIGNsZWFyZWQuXG4gICAgICAvL1xuICAgICAgLy8gSE9XRVZFUiwgaXQgaXMgY3VycmVudGx5IHBvc3NpYmxlIGZvciBhIHJlbW90ZSBibG9jayB0byBiZSBwaHlzaWNhbGx5IG5lc3RlZFxuICAgICAgLy8gaW5zaWRlIG9mIHRoZSBibG9jayBpdCBpcyBsb2dpY2FsbHkgY29udGFpbmVkIGluc2lkZSBvZi4gVGhpcyBoYXBwZW5zIHdoZW5cbiAgICAgIC8vIHRoZSByZW1vdGUgYmxvY2sgaXMgYXBwZW5kZWQgdG8gdGhlIGVuZCBvZiB0aGUgYXBwbGljYXRpb24ncyBlbnRpcmUgZWxlbWVudC5cbiAgICAgIC8vXG4gICAgICAvLyBUaGUgcHJvYmxlbSB3aXRoIHRoYXQgc2NlbmFyaW8gaXMgdGhhdCBHbGltbWVyIGJlbGlldmVzIHRoYXQgaXQgb3ducyBtb3JlIG9mXG4gICAgICAvLyB0aGUgRE9NIHRoYW4gaXQgYWN0dWFsbHkgZG9lcy4gVGhlIGNvZGUgaXMgYXR0ZW1wdGluZyB0byB3cml0ZSBwYXN0IHRoZSBlbmRcbiAgICAgIC8vIG9mIHRoZSBHbGltbWVyLW1hbmFnZWQgcm9vdCwgYnV0IEdsaW1tZXIgaXNuJ3QgYXdhcmUgb2YgdGhhdC5cbiAgICAgIC8vXG4gICAgICAvLyBUaGUgY29ycmVjdCBzb2x1dGlvbiB0byB0aGF0IHByb2JsZW0gaXMgZm9yIEdsaW1tZXIgdG8gYmUgYXdhcmUgb2YgdGhlIGVuZFxuICAgICAgLy8gb2YgdGhlIGJvdW5kcyB0aGF0IGl0IG93bnMsIGFuZCBvbmNlIHdlIG1ha2UgdGhhdCBjaGFuZ2UsIHRoaXMgY2hlY2sgY291bGRcbiAgICAgIC8vIGJlIHJlbW92ZWQuXG4gICAgICAvL1xuICAgICAgLy8gRm9yIG5vdywgYSBtb3JlIHRhcmdldGVkIGZpeCBpcyB0byBjaGVjayB3aGV0aGVyIHRoZSBub2RlIHdhcyBhbHJlYWR5IHJlbW92ZWRcbiAgICAgIC8vIGFuZCBhdm9pZCBjbGVhcmluZyB0aGUgbm9kZSBpZiBpdCB3YXMuIEluIG1vc3QgY2FzZXMgdGhpcyBzaG91bGRuJ3QgaGFwcGVuLFxuICAgICAgLy8gc28gdGhpcyBtaWdodCBoaWRlIGJ1Z3Mgd2hlcmUgdGhlIGNvZGUgY2xlYXJzIG5lc3RlZCBub2RlcyB1bm5lY2Vzc2FyaWx5LFxuICAgICAgLy8gc28gd2Ugc2hvdWxkIGV2ZW50dWFsbHkgdHJ5IHRvIGRvIHRoZSBjb3JyZWN0IGZpeC5cbiAgICAgIGlmICh0aGlzLnBhcmVudEVsZW1lbnQoKSA9PT0gdGhpcy5maXJzdE5vZGUoKS5wYXJlbnROb2RlKSB7XG4gICAgICAgIGNsZWFyKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBVcGRhdGFibGVCbG9ja0ltcGwgZXh0ZW5kcyBTaW1wbGVMaXZlQmxvY2sgaW1wbGVtZW50cyBVcGRhdGFibGVCbG9jayB7XG4gIHJlc2V0KCk6IE9wdGlvbjxTaW1wbGVOb2RlPiB7XG4gICAgZGVzdHJveSh0aGlzKTtcbiAgICBsZXQgbmV4dFNpYmxpbmcgPSBjbGVhcih0aGlzKTtcblxuICAgIHRoaXMuZmlyc3QgPSBudWxsO1xuICAgIHRoaXMubGFzdCA9IG51bGw7XG4gICAgdGhpcy5uZXN0aW5nID0gMDtcblxuICAgIHJldHVybiBuZXh0U2libGluZztcbiAgfVxufVxuXG4vLyBGSVhNRTogQWxsIHRoZSBub29wcyBpbiBoZXJlIGluZGljYXRlIGEgbW9kZWxsaW5nIHByb2JsZW1cbmV4cG9ydCBjbGFzcyBMaXZlQmxvY2tMaXN0IGltcGxlbWVudHMgTGl2ZUJsb2NrIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBwYXJlbnQ6IFNpbXBsZUVsZW1lbnQsIHB1YmxpYyBib3VuZExpc3Q6IExpdmVCbG9ja1tdKSB7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5ib3VuZExpc3QgPSBib3VuZExpc3Q7XG4gIH1cblxuICBwYXJlbnRFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnBhcmVudDtcbiAgfVxuXG4gIGZpcnN0Tm9kZSgpOiBTaW1wbGVOb2RlIHtcbiAgICBsZXQgaGVhZCA9IGV4cGVjdChcbiAgICAgIHRoaXMuYm91bmRMaXN0WzBdLFxuICAgICAgJ2Nhbm5vdCBjYWxsIGBmaXJzdE5vZGUoKWAgd2hpbGUgYExpdmVCbG9ja0xpc3RgIGlzIHN0aWxsIGluaXRpYWxpemluZydcbiAgICApO1xuXG4gICAgcmV0dXJuIGhlYWQuZmlyc3ROb2RlKCk7XG4gIH1cblxuICBsYXN0Tm9kZSgpOiBTaW1wbGVOb2RlIHtcbiAgICBsZXQgYm91bmRMaXN0ID0gdGhpcy5ib3VuZExpc3Q7XG5cbiAgICBsZXQgdGFpbCA9IGV4cGVjdChcbiAgICAgIGJvdW5kTGlzdFtib3VuZExpc3QubGVuZ3RoIC0gMV0sXG4gICAgICAnY2Fubm90IGNhbGwgYGxhc3ROb2RlKClgIHdoaWxlIGBMaXZlQmxvY2tMaXN0YCBpcyBzdGlsbCBpbml0aWFsaXppbmcnXG4gICAgKTtcblxuICAgIHJldHVybiB0YWlsLmxhc3ROb2RlKCk7XG4gIH1cblxuICBvcGVuRWxlbWVudChfZWxlbWVudDogU2ltcGxlRWxlbWVudCkge1xuICAgIGFzc2VydChmYWxzZSwgJ0Nhbm5vdCBvcGVuRWxlbWVudCBkaXJlY3RseSBpbnNpZGUgYSBibG9jayBsaXN0Jyk7XG4gIH1cblxuICBjbG9zZUVsZW1lbnQoKSB7XG4gICAgYXNzZXJ0KGZhbHNlLCAnQ2Fubm90IGNsb3NlRWxlbWVudCBkaXJlY3RseSBpbnNpZGUgYSBibG9jayBsaXN0Jyk7XG4gIH1cblxuICBkaWRBcHBlbmROb2RlKF9ub2RlOiBTaW1wbGVOb2RlKSB7XG4gICAgYXNzZXJ0KGZhbHNlLCAnQ2Fubm90IGNyZWF0ZSBhIG5ldyBub2RlIGRpcmVjdGx5IGluc2lkZSBhIGJsb2NrIGxpc3QnKTtcbiAgfVxuXG4gIGRpZEFwcGVuZEJvdW5kcyhfYm91bmRzOiBCb3VuZHMpIHt9XG5cbiAgZmluYWxpemUoX3N0YWNrOiBFbGVtZW50QnVpbGRlcikge1xuICAgIGFzc2VydCh0aGlzLmJvdW5kTGlzdC5sZW5ndGggPiAwLCAnYm91bmRzTGlzdCBjYW5ub3QgYmUgZW1wdHknKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xpZW50QnVpbGRlcihlbnY6IEVudmlyb25tZW50LCBjdXJzb3I6IEN1cnNvckltcGwpOiBFbGVtZW50QnVpbGRlciB7XG4gIHJldHVybiBOZXdFbGVtZW50QnVpbGRlci5mb3JJbml0aWFsUmVuZGVyKGVudiwgY3Vyc29yKTtcbn1cbiIsImltcG9ydCB7IGRlYnVnLCBsb2dPcGNvZGUsIG9wY29kZU1ldGFkYXRhLCByZWNvcmRTdGFja1NpemUgfSBmcm9tICdAZ2xpbW1lci9kZWJ1Zyc7XG5pbXBvcnQgeyBEaWN0LCBNYXliZSwgT3AsIE9wdGlvbiwgUnVudGltZU9wIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBMT0NBTF9ERUJVRywgTE9DQUxfU0hPVUxEX0xPRyB9IGZyb20gJ0BnbGltbWVyL2xvY2FsLWRlYnVnLWZsYWdzJztcbmltcG9ydCB7IHZhbHVlRm9yUmVmIH0gZnJvbSAnQGdsaW1tZXIvcmVmZXJlbmNlJztcbmltcG9ydCB7IGFzc2VydCwgZmlsbE51bGxzLCBMT0NBTF9MT0dHRVIgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7ICRmcCwgJHBjLCAkcmEsICRzcCB9IGZyb20gJ0BnbGltbWVyL3ZtJztcbmltcG9ydCB7IGlzU2NvcGVSZWZlcmVuY2UgfSBmcm9tICcuL3Njb3BlJztcbmltcG9ydCB7IENPTlNUQU5UUywgREVTVFJPWUFCTEVfU1RBQ0ssIElOTkVSX1ZNLCBTVEFDS1MgfSBmcm9tICcuL3N5bWJvbHMnO1xuaW1wb3J0IHsgTG93TGV2ZWxWTSwgVk0gfSBmcm9tICcuL3ZtJztcbmltcG9ydCB7IEludGVybmFsVk0gfSBmcm9tICcuL3ZtL2FwcGVuZCc7XG5pbXBvcnQgeyBDVVJTT1JfU1RBQ0sgfSBmcm9tICcuL3ZtL2VsZW1lbnQtYnVpbGRlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3Bjb2RlSlNPTiB7XG4gIHR5cGU6IG51bWJlciB8IHN0cmluZztcbiAgZ3VpZD86IE9wdGlvbjxudW1iZXI+O1xuICBkZW9wdGVkPzogYm9vbGVhbjtcbiAgYXJncz86IHN0cmluZ1tdO1xuICBkZXRhaWxzPzogRGljdDxPcHRpb248c3RyaW5nPj47XG4gIGNoaWxkcmVuPzogT3Bjb2RlSlNPTltdO1xufVxuXG5leHBvcnQgdHlwZSBPcGVyYW5kMSA9IG51bWJlcjtcbmV4cG9ydCB0eXBlIE9wZXJhbmQyID0gbnVtYmVyO1xuZXhwb3J0IHR5cGUgT3BlcmFuZDMgPSBudW1iZXI7XG5cbmV4cG9ydCB0eXBlIFN5c2NhbGwgPSAodm06IEludGVybmFsVk0sIG9wY29kZTogUnVudGltZU9wKSA9PiB2b2lkO1xuZXhwb3J0IHR5cGUgTWFjaGluZU9wY29kZSA9ICh2bTogTG93TGV2ZWxWTSwgb3Bjb2RlOiBSdW50aW1lT3ApID0+IHZvaWQ7XG5cbmV4cG9ydCB0eXBlIEV2YWx1YXRlID1cbiAgfCB7IHN5c2NhbGw6IHRydWU7IGV2YWx1YXRlOiBTeXNjYWxsIH1cbiAgfCB7IHN5c2NhbGw6IGZhbHNlOyBldmFsdWF0ZTogTWFjaGluZU9wY29kZSB9O1xuXG5leHBvcnQgdHlwZSBEZWJ1Z1N0YXRlID0ge1xuICBwYzogbnVtYmVyO1xuICBzcDogbnVtYmVyO1xuICB0eXBlOiBudW1iZXI7XG4gIGlzTWFjaGluZTogMCB8IDE7XG4gIHNpemU6IG51bWJlcjtcbiAgcGFyYW1zPzogTWF5YmU8RGljdD47XG4gIG5hbWU/OiBzdHJpbmc7XG4gIHN0YXRlOiB1bmtub3duO1xufTtcblxuZXhwb3J0IGNsYXNzIEFwcGVuZE9wY29kZXMge1xuICBwcml2YXRlIGV2YWx1YXRlT3Bjb2RlOiBFdmFsdWF0ZVtdID0gZmlsbE51bGxzPEV2YWx1YXRlPihPcC5TaXplKS5zbGljZSgpO1xuXG4gIGFkZDxOYW1lIGV4dGVuZHMgT3A+KG5hbWU6IE5hbWUsIGV2YWx1YXRlOiBTeXNjYWxsKTogdm9pZDtcbiAgYWRkPE5hbWUgZXh0ZW5kcyBPcD4obmFtZTogTmFtZSwgZXZhbHVhdGU6IE1hY2hpbmVPcGNvZGUsIGtpbmQ6ICdtYWNoaW5lJyk6IHZvaWQ7XG4gIGFkZDxOYW1lIGV4dGVuZHMgT3A+KG5hbWU6IE5hbWUsIGV2YWx1YXRlOiBTeXNjYWxsIHwgTWFjaGluZU9wY29kZSwga2luZCA9ICdzeXNjYWxsJyk6IHZvaWQge1xuICAgIHRoaXMuZXZhbHVhdGVPcGNvZGVbbmFtZSBhcyBudW1iZXJdID0ge1xuICAgICAgc3lzY2FsbDoga2luZCAhPT0gJ21hY2hpbmUnLFxuICAgICAgZXZhbHVhdGUsXG4gICAgfSBhcyBFdmFsdWF0ZTtcbiAgfVxuXG4gIGRlYnVnQmVmb3JlKHZtOiBWTSwgb3Bjb2RlOiBSdW50aW1lT3ApOiBEZWJ1Z1N0YXRlIHtcbiAgICBsZXQgcGFyYW1zOiBNYXliZTxEaWN0PiA9IHVuZGVmaW5lZDtcbiAgICBsZXQgb3BOYW1lOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoTE9DQUxfU0hPVUxEX0xPRykge1xuICAgICAgbGV0IHBvcyA9IHZtW0lOTkVSX1ZNXS5mZXRjaFJlZ2lzdGVyKCRwYykgLSBvcGNvZGUuc2l6ZTtcblxuICAgICAgW29wTmFtZSwgcGFyYW1zXSA9IGRlYnVnKHZtW0NPTlNUQU5UU10sIG9wY29kZSwgb3Bjb2RlLmlzTWFjaGluZSkhO1xuXG4gICAgICAvLyBjb25zb2xlLmxvZyhgJHt0eXBlUG9zKHZtWydwYyddKX0uYCk7XG4gICAgICBMT0NBTF9MT0dHRVIubG9nKGAke3Bvc30uICR7bG9nT3Bjb2RlKG9wTmFtZSwgcGFyYW1zKX1gKTtcblxuICAgICAgbGV0IGRlYnVnUGFyYW1zID0gW107XG4gICAgICBmb3IgKGxldCBwcm9wIGluIHBhcmFtcykge1xuICAgICAgICBkZWJ1Z1BhcmFtcy5wdXNoKHByb3AsICc9JywgcGFyYW1zW3Byb3BdKTtcbiAgICAgIH1cblxuICAgICAgTE9DQUxfTE9HR0VSLmxvZyguLi5kZWJ1Z1BhcmFtcyk7XG4gICAgfVxuXG4gICAgbGV0IHNwOiBudW1iZXI7XG5cbiAgICBpZiAoTE9DQUxfREVCVUcpIHtcbiAgICAgIHNwID0gdm0uZmV0Y2hWYWx1ZSgkc3ApO1xuICAgIH1cblxuICAgIHJlY29yZFN0YWNrU2l6ZSh2bS5mZXRjaFZhbHVlKCRzcCkpO1xuICAgIHJldHVybiB7XG4gICAgICBzcDogc3AhLFxuICAgICAgcGM6IHZtLmZldGNoVmFsdWUoJHBjKSxcbiAgICAgIG5hbWU6IG9wTmFtZSxcbiAgICAgIHBhcmFtcyxcbiAgICAgIHR5cGU6IG9wY29kZS50eXBlLFxuICAgICAgaXNNYWNoaW5lOiBvcGNvZGUuaXNNYWNoaW5lLFxuICAgICAgc2l6ZTogb3Bjb2RlLnNpemUsXG4gICAgICBzdGF0ZTogdW5kZWZpbmVkLFxuICAgIH07XG4gIH1cblxuICBkZWJ1Z0FmdGVyKHZtOiBWTSwgcHJlOiBEZWJ1Z1N0YXRlKSB7XG4gICAgbGV0IHsgc3AsIHR5cGUsIGlzTWFjaGluZSwgcGMgfSA9IHByZTtcblxuICAgIGlmIChMT0NBTF9ERUJVRykge1xuICAgICAgbGV0IG1ldGEgPSBvcGNvZGVNZXRhZGF0YSh0eXBlLCBpc01hY2hpbmUpO1xuICAgICAgbGV0IGFjdHVhbENoYW5nZSA9IHZtLmZldGNoVmFsdWUoJHNwKSAtIHNwITtcbiAgICAgIGlmIChcbiAgICAgICAgbWV0YSAmJlxuICAgICAgICBtZXRhLmNoZWNrICYmXG4gICAgICAgIHR5cGVvZiBtZXRhLnN0YWNrQ2hhbmdlISA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgbWV0YS5zdGFja0NoYW5nZSEgIT09IGFjdHVhbENoYW5nZVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRXJyb3IgaW4gJHtwcmUubmFtZX06XFxuXFxuJHtwY30uICR7bG9nT3Bjb2RlKFxuICAgICAgICAgICAgcHJlLm5hbWUhLFxuICAgICAgICAgICAgcHJlLnBhcmFtcyFcbiAgICAgICAgICApfVxcblxcblN0YWNrIGNoYW5nZWQgYnkgJHthY3R1YWxDaGFuZ2V9LCBleHBlY3RlZCAke21ldGEuc3RhY2tDaGFuZ2UhfWBcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKExPQ0FMX1NIT1VMRF9MT0cpIHtcbiAgICAgICAgTE9DQUxfTE9HR0VSLmxvZyhcbiAgICAgICAgICAnJWMgLT4gcGM6ICVkLCByYTogJWQsIGZwOiAlZCwgc3A6ICVkLCBzMDogJU8sIHMxOiAlTywgdDA6ICVPLCB0MTogJU8sIHYwOiAlTycsXG4gICAgICAgICAgJ2NvbG9yOiBvcmFuZ2UnLFxuICAgICAgICAgIHZtW0lOTkVSX1ZNXS5yZWdpc3RlcnNbJHBjXSxcbiAgICAgICAgICB2bVtJTk5FUl9WTV0ucmVnaXN0ZXJzWyRyYV0sXG4gICAgICAgICAgdm1bSU5ORVJfVk1dLnJlZ2lzdGVyc1skZnBdLFxuICAgICAgICAgIHZtW0lOTkVSX1ZNXS5yZWdpc3RlcnNbJHNwXSxcbiAgICAgICAgICB2bVsnczAnXSxcbiAgICAgICAgICB2bVsnczEnXSxcbiAgICAgICAgICB2bVsndDAnXSxcbiAgICAgICAgICB2bVsndDEnXSxcbiAgICAgICAgICB2bVsndjAnXVxuICAgICAgICApO1xuICAgICAgICBMT0NBTF9MT0dHRVIubG9nKCclYyAtPiBldmFsIHN0YWNrJywgJ2NvbG9yOiByZWQnLCB2bS5zdGFjay50b0FycmF5KCkpO1xuICAgICAgICBMT0NBTF9MT0dHRVIubG9nKCclYyAtPiBibG9jayBzdGFjaycsICdjb2xvcjogbWFnZW50YScsIHZtLmVsZW1lbnRzKCkuZGVidWdCbG9ja3MoKSk7XG4gICAgICAgIExPQ0FMX0xPR0dFUi5sb2coXG4gICAgICAgICAgJyVjIC0+IGRlc3RydWN0b3Igc3RhY2snLFxuICAgICAgICAgICdjb2xvcjogdmlvbGV0JyxcbiAgICAgICAgICB2bVtERVNUUk9ZQUJMRV9TVEFDS10udG9BcnJheSgpXG4gICAgICAgICk7XG4gICAgICAgIGlmICh2bVtTVEFDS1NdLnNjb3BlLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICBMT0NBTF9MT0dHRVIubG9nKCclYyAtPiBzY29wZScsICdjb2xvcjogZ3JlZW4nLCAnbnVsbCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIExPQ0FMX0xPR0dFUi5sb2coXG4gICAgICAgICAgICAnJWMgLT4gc2NvcGUnLFxuICAgICAgICAgICAgJ2NvbG9yOiBncmVlbicsXG4gICAgICAgICAgICB2bS5zY29wZSgpLnNsb3RzLm1hcCgocykgPT4gKGlzU2NvcGVSZWZlcmVuY2UocykgPyB2YWx1ZUZvclJlZihzKSA6IHMpKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBMT0NBTF9MT0dHRVIubG9nKFxuICAgICAgICAgICclYyAtPiBlbGVtZW50cycsXG4gICAgICAgICAgJ2NvbG9yOiBibHVlJyxcbiAgICAgICAgICB2bS5lbGVtZW50cygpW0NVUlNPUl9TVEFDS10uY3VycmVudCEuZWxlbWVudFxuICAgICAgICApO1xuXG4gICAgICAgIExPQ0FMX0xPR0dFUi5sb2coJyVjIC0+IGNvbnN0cnVjdGluZycsICdjb2xvcjogYXF1YScsIHZtLmVsZW1lbnRzKClbJ2NvbnN0cnVjdGluZyddKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBldmFsdWF0ZSh2bTogVk0sIG9wY29kZTogUnVudGltZU9wLCB0eXBlOiBudW1iZXIpIHtcbiAgICBsZXQgb3BlcmF0aW9uID0gdGhpcy5ldmFsdWF0ZU9wY29kZVt0eXBlXTtcblxuICAgIGlmIChvcGVyYXRpb24uc3lzY2FsbCkge1xuICAgICAgYXNzZXJ0KFxuICAgICAgICAhb3Bjb2RlLmlzTWFjaGluZSxcbiAgICAgICAgYEJVRzogTWlzbWF0Y2ggYmV0d2VlbiBvcGVyYXRpb24uc3lzY2FsbCAoJHtvcGVyYXRpb24uc3lzY2FsbH0pIGFuZCBvcGNvZGUuaXNNYWNoaW5lICgke29wY29kZS5pc01hY2hpbmV9KSBmb3IgJHtvcGNvZGUudHlwZX1gXG4gICAgICApO1xuICAgICAgb3BlcmF0aW9uLmV2YWx1YXRlKHZtLCBvcGNvZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoXG4gICAgICAgIG9wY29kZS5pc01hY2hpbmUsXG4gICAgICAgIGBCVUc6IE1pc21hdGNoIGJldHdlZW4gb3BlcmF0aW9uLnN5c2NhbGwgKCR7b3BlcmF0aW9uLnN5c2NhbGx9KSBhbmQgb3Bjb2RlLmlzTWFjaGluZSAoJHtvcGNvZGUuaXNNYWNoaW5lfSkgZm9yICR7b3Bjb2RlLnR5cGV9YFxuICAgICAgKTtcbiAgICAgIG9wZXJhdGlvbi5ldmFsdWF0ZSh2bVtJTk5FUl9WTV0sIG9wY29kZSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBBUFBFTkRfT1BDT0RFUyA9IG5ldyBBcHBlbmRPcGNvZGVzKCk7XG4iLCJpbXBvcnQgeyBEaWN0LCBNYXliZSB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgUmVmZXJlbmNlLCB2YWx1ZUZvclJlZiwgY3JlYXRlQ29tcHV0ZVJlZiB9IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb25jYXRSZWYocGFydHNSZWZzOiBSZWZlcmVuY2VbXSkge1xuICByZXR1cm4gY3JlYXRlQ29tcHV0ZVJlZigoKSA9PiB7XG4gICAgbGV0IHBhcnRzID0gbmV3IEFycmF5PHN0cmluZz4oKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHNSZWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgdmFsdWUgPSB2YWx1ZUZvclJlZihwYXJ0c1JlZnNbaV0pIGFzIE1heWJlPERpY3Q+O1xuXG4gICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJ0c1tpXSA9IGNhc3RUb1N0cmluZyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBwYXJ0cy5qb2luKCcnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNhc3RUb1N0cmluZyh2YWx1ZTogRGljdCkge1xuICBpZiAodHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG59XG4iLCJpbXBvcnQgeyBDYXB0dXJlZEFyZ3VtZW50cywgQ3VycmllZFR5cGUsIE93bmVyIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBzeW1ib2wsIF9XZWFrU2V0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyBSZWZlcmVuY2UgfSBmcm9tICdAZ2xpbW1lci9yZWZlcmVuY2UnO1xuXG5jb25zdCBUWVBFOiB1bmlxdWUgc3ltYm9sID0gc3ltYm9sKCdUWVBFJyk7XG5jb25zdCBJTk5FUjogdW5pcXVlIHN5bWJvbCA9IHN5bWJvbCgnSU5ORVInKTtcbmNvbnN0IE9XTkVSOiB1bmlxdWUgc3ltYm9sID0gc3ltYm9sKCdPV05FUicpO1xuY29uc3QgQVJHUzogdW5pcXVlIHN5bWJvbCA9IHN5bWJvbCgnQVJHUycpO1xuY29uc3QgUkVTT0xWRUQ6IHVuaXF1ZSBzeW1ib2wgPSBzeW1ib2woJ1JFU09MVkVEJyk7XG5cbmNvbnN0IENVUlJJRURfVkFMVUVTID0gbmV3IF9XZWFrU2V0KCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0N1cnJpZWRWYWx1ZSh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIEN1cnJpZWRWYWx1ZTxDdXJyaWVkVHlwZT4ge1xuICByZXR1cm4gQ1VSUklFRF9WQUxVRVMuaGFzKHZhbHVlIGFzIG9iamVjdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0N1cnJpZWRUeXBlPFQgZXh0ZW5kcyBDdXJyaWVkVHlwZT4oXG4gIHZhbHVlOiB1bmtub3duLFxuICB0eXBlOiBUXG4pOiB2YWx1ZSBpcyBDdXJyaWVkVmFsdWU8VD4ge1xuICByZXR1cm4gaXNDdXJyaWVkVmFsdWUodmFsdWUpICYmIHZhbHVlW1RZUEVdID09PSB0eXBlO1xufVxuXG5leHBvcnQgY2xhc3MgQ3VycmllZFZhbHVlPFQgZXh0ZW5kcyBDdXJyaWVkVHlwZSA9IEN1cnJpZWRUeXBlPiB7XG4gIFtUWVBFXTogVDtcbiAgW0lOTkVSXTogb2JqZWN0IHwgc3RyaW5nIHwgQ3VycmllZFZhbHVlPFQ+O1xuICBbT1dORVJdOiBPd25lcjtcbiAgW0FSR1NdOiBDYXB0dXJlZEFyZ3VtZW50cyB8IG51bGw7XG4gIFtSRVNPTFZFRF06IGJvb2xlYW47XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICB0eXBlOiBULFxuICAgIGlubmVyOiBvYmplY3QgfCBzdHJpbmcgfCBDdXJyaWVkVmFsdWU8VD4sXG4gICAgb3duZXI6IE93bmVyLFxuICAgIGFyZ3M6IENhcHR1cmVkQXJndW1lbnRzIHwgbnVsbCxcbiAgICByZXNvbHZlZCA9IGZhbHNlXG4gICkge1xuICAgIENVUlJJRURfVkFMVUVTLmFkZCh0aGlzKTtcbiAgICB0aGlzW1RZUEVdID0gdHlwZTtcbiAgICB0aGlzW0lOTkVSXSA9IGlubmVyO1xuICAgIHRoaXNbT1dORVJdID0gb3duZXI7XG4gICAgdGhpc1tBUkdTXSA9IGFyZ3M7XG4gICAgdGhpc1tSRVNPTFZFRF0gPSByZXNvbHZlZDtcbiAgfVxufVxuXG5pbnRlcmZhY2UgUmVzb2x2ZWRDdXJyaWVkVmFsdWU8VD4ge1xuICBkZWZpbml0aW9uOiBUO1xuICBvd25lcjogT3duZXI7XG4gIHJlc29sdmVkOiBib29sZWFuO1xuICBwb3NpdGlvbmFsOiBSZWZlcmVuY2VbXSB8IHVuZGVmaW5lZDtcbiAgbmFtZWQ6IFJlY29yZDxzdHJpbmcsIFJlZmVyZW5jZT5bXSB8IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVDdXJyaWVkVmFsdWUoXG4gIGN1cnJpZWRWYWx1ZTogQ3VycmllZFZhbHVlPEN1cnJpZWRUeXBlLkNvbXBvbmVudD5cbik6IFJlc29sdmVkQ3VycmllZFZhbHVlPG9iamVjdCB8IHN0cmluZz47XG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUN1cnJpZWRWYWx1ZShcbiAgY3VycmllZFZhbHVlOiBDdXJyaWVkVmFsdWU8Q3VycmllZFR5cGUuSGVscGVyPiB8IEN1cnJpZWRWYWx1ZTxDdXJyaWVkVHlwZS5Nb2RpZmllcj5cbik6IFJlc29sdmVkQ3VycmllZFZhbHVlPG9iamVjdD47XG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUN1cnJpZWRWYWx1ZShcbiAgY3VycmllZFZhbHVlOiBDdXJyaWVkVmFsdWU8Q3VycmllZFR5cGU+XG4pOiBSZXNvbHZlZEN1cnJpZWRWYWx1ZTxvYmplY3QgfCBzdHJpbmc+IHtcbiAgbGV0IGN1cnJlbnRXcmFwcGVyID0gY3VycmllZFZhbHVlO1xuICBsZXQgcG9zaXRpb25hbDogUmVmZXJlbmNlW10gfCB1bmRlZmluZWQ7XG4gIGxldCBuYW1lZDogUmVjb3JkPHN0cmluZywgUmVmZXJlbmNlPltdIHwgdW5kZWZpbmVkO1xuICBsZXQgZGVmaW5pdGlvbiwgb3duZXIsIHJlc29sdmVkO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgbGV0IHsgW0FSR1NdOiBjdXJyaWVkQXJncywgW0lOTkVSXTogaW5uZXIgfSA9IGN1cnJlbnRXcmFwcGVyO1xuXG4gICAgaWYgKGN1cnJpZWRBcmdzICE9PSBudWxsKSB7XG4gICAgICBsZXQgeyBuYW1lZDogY3VycmllZE5hbWVkLCBwb3NpdGlvbmFsOiBjdXJyaWVkUG9zaXRpb25hbCB9ID0gY3VycmllZEFyZ3M7XG5cbiAgICAgIGlmIChjdXJyaWVkUG9zaXRpb25hbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHBvc2l0aW9uYWwgPVxuICAgICAgICAgIHBvc2l0aW9uYWwgPT09IHVuZGVmaW5lZCA/IGN1cnJpZWRQb3NpdGlvbmFsIDogY3VycmllZFBvc2l0aW9uYWwuY29uY2F0KHBvc2l0aW9uYWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuYW1lZCA9IFtdO1xuICAgICAgfVxuXG4gICAgICBuYW1lZC51bnNoaWZ0KGN1cnJpZWROYW1lZCk7XG4gICAgfVxuXG4gICAgaWYgKCFpc0N1cnJpZWRWYWx1ZShpbm5lcikpIHtcbiAgICAgIC8vIFNhdmUgb2ZmIHRoZSBvd25lciB0aGF0IHRoaXMgaGVscGVyIHdhcyBjdXJyaWVkIHdpdGguIExhdGVyIG9uLFxuICAgICAgLy8gd2UnbGwgZmV0Y2ggdGhlIHZhbHVlIG9mIHRoaXMgcmVnaXN0ZXIgYW5kIHNldCBpdCBhcyB0aGUgb3duZXIgb24gdGhlXG4gICAgICAvLyBuZXcgcm9vdCBzY29wZS5cbiAgICAgIGRlZmluaXRpb24gPSBpbm5lcjtcbiAgICAgIG93bmVyID0gY3VycmVudFdyYXBwZXJbT1dORVJdO1xuICAgICAgcmVzb2x2ZWQgPSBjdXJyZW50V3JhcHBlcltSRVNPTFZFRF07XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjdXJyZW50V3JhcHBlciA9IGlubmVyO1xuICB9XG5cbiAgcmV0dXJuIHsgZGVmaW5pdGlvbiwgb3duZXIsIHJlc29sdmVkLCBwb3NpdGlvbmFsLCBuYW1lZCB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3Vycnk8VCBleHRlbmRzIEN1cnJpZWRUeXBlPihcbiAgdHlwZTogVCxcbiAgc3BlYzogb2JqZWN0IHwgc3RyaW5nIHwgQ3VycmllZFZhbHVlPFQ+LFxuICBvd25lcjogT3duZXIsXG4gIGFyZ3M6IENhcHR1cmVkQXJndW1lbnRzIHwgbnVsbCxcbiAgcmVzb2x2ZWQgPSBmYWxzZVxuKTogQ3VycmllZFZhbHVlPFQ+IHtcbiAgcmV0dXJuIG5ldyBDdXJyaWVkVmFsdWUodHlwZSwgc3BlYywgb3duZXIsIGFyZ3MsIHJlc29sdmVkKTtcbn1cbiIsImltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7XG4gIENhcHR1cmVkQXJndW1lbnRzLFxuICBDdXJyaWVkVHlwZSxcbiAgRGljdCxcbiAgTWF5YmUsXG4gIE9wdGlvbixcbiAgT3duZXIsXG4gIFJ1bnRpbWVSZXNvbHZlcixcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBjcmVhdGVDb21wdXRlUmVmLCBSZWZlcmVuY2UsIHZhbHVlRm9yUmVmIH0gZnJvbSAnQGdsaW1tZXIvcmVmZXJlbmNlJztcbmltcG9ydCB7IGV4cGVjdCwgaXNPYmplY3QgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IGN1cnJ5LCBpc0N1cnJpZWRUeXBlIH0gZnJvbSAnLi4vY3VycmllZC12YWx1ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZUN1cnJ5UmVmKFxuICB0eXBlOiBDdXJyaWVkVHlwZSxcbiAgaW5uZXI6IFJlZmVyZW5jZSxcbiAgb3duZXI6IE93bmVyLFxuICBhcmdzOiBPcHRpb248Q2FwdHVyZWRBcmd1bWVudHM+LFxuICByZXNvbHZlcjogUnVudGltZVJlc29sdmVyLFxuICBpc1N0cmljdDogYm9vbGVhblxuKSB7XG4gIGxldCBsYXN0VmFsdWU6IE1heWJlPERpY3Q+IHwgc3RyaW5nLCBjdXJyaWVkRGVmaW5pdGlvbjogb2JqZWN0IHwgc3RyaW5nIHwgbnVsbDtcblxuICByZXR1cm4gY3JlYXRlQ29tcHV0ZVJlZigoKSA9PiB7XG4gICAgbGV0IHZhbHVlID0gdmFsdWVGb3JSZWYoaW5uZXIpIGFzIE1heWJlPERpY3Q+IHwgc3RyaW5nO1xuXG4gICAgaWYgKHZhbHVlID09PSBsYXN0VmFsdWUpIHtcbiAgICAgIHJldHVybiBjdXJyaWVkRGVmaW5pdGlvbjtcbiAgICB9XG5cbiAgICBpZiAoaXNDdXJyaWVkVHlwZSh2YWx1ZSwgdHlwZSkpIHtcbiAgICAgIGN1cnJpZWREZWZpbml0aW9uID0gYXJncyA/IGN1cnJ5KHR5cGUsIHZhbHVlLCBvd25lciwgYXJncykgOiBhcmdzO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gQ3VycmllZFR5cGUuQ29tcG9uZW50ICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUpIHtcbiAgICAgIC8vIE9ubHkgY29tcG9uZW50cyBzaG91bGQgZW50ZXIgdGhpcyBwYXRoLCBhcyBoZWxwZXJzIGFuZCBtb2RpZmllcnMgZG8gbm90XG4gICAgICAvLyBzdXBwb3J0IHN0cmluZyBiYXNlZCByZXNvbHV0aW9uXG5cbiAgICAgIGlmIChERUJVRykge1xuICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQXR0ZW1wdGVkIHRvIHJlc29sdmUgYSBkeW5hbWljIGNvbXBvbmVudCB3aXRoIGEgc3RyaW5nIGRlZmluaXRpb24sIFxcYCR7dmFsdWV9XFxgIGluIGEgc3RyaWN0IG1vZGUgdGVtcGxhdGUuIEluIHN0cmljdCBtb2RlLCB1c2luZyBzdHJpbmdzIHRvIHJlc29sdmUgY29tcG9uZW50IGRlZmluaXRpb25zIGlzIHByb2hpYml0ZWQuIFlvdSBjYW4gaW5zdGVhZCBpbXBvcnQgdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uIGFuZCB1c2UgaXQgZGlyZWN0bHkuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzb2x2ZWREZWZpbml0aW9uID0gZXhwZWN0KFxuICAgICAgICAgIHJlc29sdmVyLFxuICAgICAgICAgICdCVUc6IGV4cGVjdGVkIHJlc29sdmVyIGZvciBjdXJyaWVkIGNvbXBvbmVudCBkZWZpbml0aW9ucydcbiAgICAgICAgKS5sb29rdXBDb21wb25lbnQodmFsdWUsIG93bmVyKTtcblxuICAgICAgICBpZiAoIXJlc29sdmVkRGVmaW5pdGlvbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBBdHRlbXB0ZWQgdG8gcmVzb2x2ZSBcXGAke3ZhbHVlfVxcYCwgd2hpY2ggd2FzIGV4cGVjdGVkIHRvIGJlIGEgY29tcG9uZW50LCBidXQgbm90aGluZyB3YXMgZm91bmQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3VycmllZERlZmluaXRpb24gPSBjdXJyeSh0eXBlLCB2YWx1ZSwgb3duZXIsIGFyZ3MpO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBjdXJyaWVkRGVmaW5pdGlvbiA9IGN1cnJ5KHR5cGUsIHZhbHVlLCBvd25lciwgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJpZWREZWZpbml0aW9uID0gbnVsbDtcbiAgICB9XG5cbiAgICBsYXN0VmFsdWUgPSB2YWx1ZTtcblxuICAgIHJldHVybiBjdXJyaWVkRGVmaW5pdGlvbjtcbiAgfSk7XG59XG4iLCJpbXBvcnQgeyBjaGVjaywgQ2hlY2tCbG9ja1N5bWJvbFRhYmxlLCBDaGVja0hhbmRsZSwgQ2hlY2tPcHRpb24sIENoZWNrT3IgfSBmcm9tICdAZ2xpbW1lci9kZWJ1Zyc7XG5pbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5pbXBvcnQge1xuICBCbG9ja0FyZ3VtZW50cyxcbiAgQmxvY2tTeW1ib2xUYWJsZSxcbiAgQmxvY2tWYWx1ZSxcbiAgQ2FwdHVyZWRBcmd1bWVudHMsXG4gIENhcHR1cmVkQmxvY2tBcmd1bWVudHMsXG4gIENhcHR1cmVkTmFtZWRBcmd1bWVudHMsXG4gIENhcHR1cmVkUG9zaXRpb25hbEFyZ3VtZW50cyxcbiAgQ29tcGlsYWJsZUJsb2NrLFxuICBEaWN0LFxuICBOYW1lZEFyZ3VtZW50cyxcbiAgT3B0aW9uLFxuICBQb3NpdGlvbmFsQXJndW1lbnRzLFxuICBTY29wZSxcbiAgU2NvcGVCbG9jayxcbiAgVk1Bcmd1bWVudHMsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHtcbiAgY3JlYXRlRGVidWdBbGlhc1JlZixcbiAgUmVmZXJlbmNlLFxuICBVTkRFRklORURfUkVGRVJFTkNFLFxuICB2YWx1ZUZvclJlZixcbn0gZnJvbSAnQGdsaW1tZXIvcmVmZXJlbmNlJztcbmltcG9ydCB7IGRpY3QsIGVtcHR5QXJyYXksIEVNUFRZX1NUUklOR19BUlJBWSB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgQ09OU1RBTlRfVEFHLCBUYWcgfSBmcm9tICdAZ2xpbW1lci92YWxpZGF0b3InO1xuaW1wb3J0IHsgJHNwIH0gZnJvbSAnQGdsaW1tZXIvdm0nO1xuaW1wb3J0IHsgQ2hlY2tDb21waWxhYmxlQmxvY2ssIENoZWNrUmVmZXJlbmNlLCBDaGVja1Njb3BlIH0gZnJvbSAnLi4vY29tcGlsZWQvb3Bjb2Rlcy8tZGVidWctc3RyaXAnO1xuaW1wb3J0IHsgUkVHSVNURVJTIH0gZnJvbSAnLi4vc3ltYm9scyc7XG5pbXBvcnQgeyBFdmFsdWF0aW9uU3RhY2sgfSBmcm9tICcuL3N0YWNrJztcblxuLypcbiAgVGhlIGNhbGxpbmcgY29udmVudGlvbiBpczpcblxuICAqIDAtTiBibG9jayBhcmd1bWVudHMgYXQgdGhlIGJvdHRvbVxuICAqIDAtTiBwb3NpdGlvbmFsIGFyZ3VtZW50cyBuZXh0IChsZWZ0LXRvLXJpZ2h0KVxuICAqIDAtTiBuYW1lZCBhcmd1bWVudHMgbmV4dFxuKi9cblxuZXhwb3J0IGNsYXNzIFZNQXJndW1lbnRzSW1wbCBpbXBsZW1lbnRzIFZNQXJndW1lbnRzIHtcbiAgcHJpdmF0ZSBzdGFjazogT3B0aW9uPEV2YWx1YXRpb25TdGFjaz4gPSBudWxsO1xuICBwdWJsaWMgcG9zaXRpb25hbCA9IG5ldyBQb3NpdGlvbmFsQXJndW1lbnRzSW1wbCgpO1xuICBwdWJsaWMgbmFtZWQgPSBuZXcgTmFtZWRBcmd1bWVudHNJbXBsKCk7XG4gIHB1YmxpYyBibG9ja3MgPSBuZXcgQmxvY2tBcmd1bWVudHNJbXBsKCk7XG5cbiAgZW1wdHkoc3RhY2s6IEV2YWx1YXRpb25TdGFjayk6IHRoaXMge1xuICAgIGxldCBiYXNlID0gc3RhY2tbUkVHSVNURVJTXVskc3BdICsgMTtcblxuICAgIHRoaXMubmFtZWQuZW1wdHkoc3RhY2ssIGJhc2UpO1xuICAgIHRoaXMucG9zaXRpb25hbC5lbXB0eShzdGFjaywgYmFzZSk7XG4gICAgdGhpcy5ibG9ja3MuZW1wdHkoc3RhY2ssIGJhc2UpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXR1cChcbiAgICBzdGFjazogRXZhbHVhdGlvblN0YWNrLFxuICAgIG5hbWVzOiByZWFkb25seSBzdHJpbmdbXSxcbiAgICBibG9ja05hbWVzOiByZWFkb25seSBzdHJpbmdbXSxcbiAgICBwb3NpdGlvbmFsQ291bnQ6IG51bWJlcixcbiAgICBhdE5hbWVzOiBib29sZWFuXG4gICkge1xuICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcblxuICAgIC8qXG4gICAgICAgICAgIHwgLi4uIHwgYmxvY2tzICAgICAgfCBwb3NpdGlvbmFsICB8IG5hbWVkIHxcbiAgICAgICAgICAgfCAuLi4gfCBiMCAgICBiMSAgICB8IHAwIHAxIHAyIHAzIHwgbjAgbjEgfFxuICAgICBpbmRleCB8IC4uLiB8IDQvNS82IDcvOC85IHwgMTAgMTEgMTIgMTMgfCAxNCAxNSB8XG4gICAgICAgICAgICAgICAgICAgXiAgICAgICAgICAgICBeICAgICAgICAgICAgIF4gIF5cbiAgICAgICAgICAgICAgICAgYmJhc2UgICAgICAgICBwYmFzZSAgICAgICBuYmFzZSAgc3BcbiAgICAqL1xuXG4gICAgbGV0IG5hbWVkID0gdGhpcy5uYW1lZDtcbiAgICBsZXQgbmFtZWRDb3VudCA9IG5hbWVzLmxlbmd0aDtcbiAgICBsZXQgbmFtZWRCYXNlID0gc3RhY2tbUkVHSVNURVJTXVskc3BdIC0gbmFtZWRDb3VudCArIDE7XG5cbiAgICBuYW1lZC5zZXR1cChzdGFjaywgbmFtZWRCYXNlLCBuYW1lZENvdW50LCBuYW1lcywgYXROYW1lcyk7XG5cbiAgICBsZXQgcG9zaXRpb25hbCA9IHRoaXMucG9zaXRpb25hbDtcbiAgICBsZXQgcG9zaXRpb25hbEJhc2UgPSBuYW1lZEJhc2UgLSBwb3NpdGlvbmFsQ291bnQ7XG5cbiAgICBwb3NpdGlvbmFsLnNldHVwKHN0YWNrLCBwb3NpdGlvbmFsQmFzZSwgcG9zaXRpb25hbENvdW50KTtcblxuICAgIGxldCBibG9ja3MgPSB0aGlzLmJsb2NrcztcbiAgICBsZXQgYmxvY2tzQ291bnQgPSBibG9ja05hbWVzLmxlbmd0aDtcbiAgICBsZXQgYmxvY2tzQmFzZSA9IHBvc2l0aW9uYWxCYXNlIC0gYmxvY2tzQ291bnQgKiAzO1xuXG4gICAgYmxvY2tzLnNldHVwKHN0YWNrLCBibG9ja3NCYXNlLCBibG9ja3NDb3VudCwgYmxvY2tOYW1lcyk7XG4gIH1cblxuICBnZXQgYmFzZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmJsb2Nrcy5iYXNlO1xuICB9XG5cbiAgZ2V0IGxlbmd0aCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uYWwubGVuZ3RoICsgdGhpcy5uYW1lZC5sZW5ndGggKyB0aGlzLmJsb2Nrcy5sZW5ndGggKiAzO1xuICB9XG5cbiAgYXQocG9zOiBudW1iZXIpOiBSZWZlcmVuY2Uge1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uYWwuYXQocG9zKTtcbiAgfVxuXG4gIHJlYWxsb2Mob2Zmc2V0OiBudW1iZXIpIHtcbiAgICBsZXQgeyBzdGFjayB9ID0gdGhpcztcbiAgICBpZiAob2Zmc2V0ID4gMCAmJiBzdGFjayAhPT0gbnVsbCkge1xuICAgICAgbGV0IHsgcG9zaXRpb25hbCwgbmFtZWQgfSA9IHRoaXM7XG4gICAgICBsZXQgbmV3QmFzZSA9IHBvc2l0aW9uYWwuYmFzZSArIG9mZnNldDtcbiAgICAgIGxldCBsZW5ndGggPSBwb3NpdGlvbmFsLmxlbmd0aCArIG5hbWVkLmxlbmd0aDtcblxuICAgICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHN0YWNrLmNvcHkoaSArIHBvc2l0aW9uYWwuYmFzZSwgaSArIG5ld0Jhc2UpO1xuICAgICAgfVxuXG4gICAgICBwb3NpdGlvbmFsLmJhc2UgKz0gb2Zmc2V0O1xuICAgICAgbmFtZWQuYmFzZSArPSBvZmZzZXQ7XG4gICAgICBzdGFja1tSRUdJU1RFUlNdWyRzcF0gKz0gb2Zmc2V0O1xuICAgIH1cbiAgfVxuXG4gIGNhcHR1cmUoKTogQ2FwdHVyZWRBcmd1bWVudHMge1xuICAgIGxldCBwb3NpdGlvbmFsID0gdGhpcy5wb3NpdGlvbmFsLmxlbmd0aCA9PT0gMCA/IEVNUFRZX1BPU0lUSU9OQUwgOiB0aGlzLnBvc2l0aW9uYWwuY2FwdHVyZSgpO1xuICAgIGxldCBuYW1lZCA9IHRoaXMubmFtZWQubGVuZ3RoID09PSAwID8gRU1QVFlfTkFNRUQgOiB0aGlzLm5hbWVkLmNhcHR1cmUoKTtcblxuICAgIHJldHVybiB7IG5hbWVkLCBwb3NpdGlvbmFsIH0gYXMgQ2FwdHVyZWRBcmd1bWVudHM7XG4gIH1cblxuICBjbGVhcigpOiB2b2lkIHtcbiAgICBsZXQgeyBzdGFjaywgbGVuZ3RoIH0gPSB0aGlzO1xuICAgIGlmIChsZW5ndGggPiAwICYmIHN0YWNrICE9PSBudWxsKSBzdGFjay5wb3AobGVuZ3RoKTtcbiAgfVxufVxuXG5jb25zdCBFTVBUWV9SRUZFUkVOQ0VTID0gZW1wdHlBcnJheTxSZWZlcmVuY2U+KCk7XG5cbmV4cG9ydCBjbGFzcyBQb3NpdGlvbmFsQXJndW1lbnRzSW1wbCBpbXBsZW1lbnRzIFBvc2l0aW9uYWxBcmd1bWVudHMge1xuICBwdWJsaWMgYmFzZSA9IDA7XG4gIHB1YmxpYyBsZW5ndGggPSAwO1xuXG4gIHByaXZhdGUgc3RhY2s6IEV2YWx1YXRpb25TdGFjayA9IG51bGwgYXMgYW55O1xuXG4gIHByaXZhdGUgX3JlZmVyZW5jZXM6IE9wdGlvbjxyZWFkb25seSBSZWZlcmVuY2VbXT4gPSBudWxsO1xuXG4gIGVtcHR5KHN0YWNrOiBFdmFsdWF0aW9uU3RhY2ssIGJhc2U6IG51bWJlcikge1xuICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgIHRoaXMuX3JlZmVyZW5jZXMgPSBFTVBUWV9SRUZFUkVOQ0VTO1xuICB9XG5cbiAgc2V0dXAoc3RhY2s6IEV2YWx1YXRpb25TdGFjaywgYmFzZTogbnVtYmVyLCBsZW5ndGg6IG51bWJlcikge1xuICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuXG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5fcmVmZXJlbmNlcyA9IEVNUFRZX1JFRkVSRU5DRVM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlZmVyZW5jZXMgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGF0KHBvc2l0aW9uOiBudW1iZXIpOiBSZWZlcmVuY2Uge1xuICAgIGxldCB7IGJhc2UsIGxlbmd0aCwgc3RhY2sgfSA9IHRoaXM7XG5cbiAgICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IGxlbmd0aCkge1xuICAgICAgcmV0dXJuIFVOREVGSU5FRF9SRUZFUkVOQ0U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoZWNrKHN0YWNrLmdldChwb3NpdGlvbiwgYmFzZSksIENoZWNrUmVmZXJlbmNlKTtcbiAgfVxuXG4gIGNhcHR1cmUoKTogQ2FwdHVyZWRQb3NpdGlvbmFsQXJndW1lbnRzIHtcbiAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2VzIGFzIENhcHR1cmVkUG9zaXRpb25hbEFyZ3VtZW50cztcbiAgfVxuXG4gIHByZXBlbmQob3RoZXI6IFJlZmVyZW5jZVtdKSB7XG4gICAgbGV0IGFkZGl0aW9ucyA9IG90aGVyLmxlbmd0aDtcblxuICAgIGlmIChhZGRpdGlvbnMgPiAwKSB7XG4gICAgICBsZXQgeyBiYXNlLCBsZW5ndGgsIHN0YWNrIH0gPSB0aGlzO1xuXG4gICAgICB0aGlzLmJhc2UgPSBiYXNlID0gYmFzZSAtIGFkZGl0aW9ucztcbiAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoICsgYWRkaXRpb25zO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFkZGl0aW9uczsgaSsrKSB7XG4gICAgICAgIHN0YWNrLnNldChvdGhlcltpXSwgaSwgYmFzZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlZmVyZW5jZXMgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0IHJlZmVyZW5jZXMoKTogcmVhZG9ubHkgUmVmZXJlbmNlW10ge1xuICAgIGxldCByZWZlcmVuY2VzID0gdGhpcy5fcmVmZXJlbmNlcztcblxuICAgIGlmICghcmVmZXJlbmNlcykge1xuICAgICAgbGV0IHsgc3RhY2ssIGJhc2UsIGxlbmd0aCB9ID0gdGhpcztcbiAgICAgIHJlZmVyZW5jZXMgPSB0aGlzLl9yZWZlcmVuY2VzID0gc3RhY2suc2xpY2U8UmVmZXJlbmNlPihiYXNlLCBiYXNlICsgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVmZXJlbmNlcztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTmFtZWRBcmd1bWVudHNJbXBsIGltcGxlbWVudHMgTmFtZWRBcmd1bWVudHMge1xuICBwdWJsaWMgYmFzZSA9IDA7XG4gIHB1YmxpYyBsZW5ndGggPSAwO1xuXG4gIHByaXZhdGUgc3RhY2shOiBFdmFsdWF0aW9uU3RhY2s7XG5cbiAgcHJpdmF0ZSBfcmVmZXJlbmNlczogT3B0aW9uPHJlYWRvbmx5IFJlZmVyZW5jZVtdPiA9IG51bGw7XG5cbiAgcHJpdmF0ZSBfbmFtZXM6IE9wdGlvbjxyZWFkb25seSBzdHJpbmdbXT4gPSBFTVBUWV9TVFJJTkdfQVJSQVk7XG4gIHByaXZhdGUgX2F0TmFtZXM6IE9wdGlvbjxyZWFkb25seSBzdHJpbmdbXT4gPSBFTVBUWV9TVFJJTkdfQVJSQVk7XG5cbiAgZW1wdHkoc3RhY2s6IEV2YWx1YXRpb25TdGFjaywgYmFzZTogbnVtYmVyKSB7XG4gICAgdGhpcy5zdGFjayA9IHN0YWNrO1xuICAgIHRoaXMuYmFzZSA9IGJhc2U7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgdGhpcy5fcmVmZXJlbmNlcyA9IEVNUFRZX1JFRkVSRU5DRVM7XG4gICAgdGhpcy5fbmFtZXMgPSBFTVBUWV9TVFJJTkdfQVJSQVk7XG4gICAgdGhpcy5fYXROYW1lcyA9IEVNUFRZX1NUUklOR19BUlJBWTtcbiAgfVxuXG4gIHNldHVwKFxuICAgIHN0YWNrOiBFdmFsdWF0aW9uU3RhY2ssXG4gICAgYmFzZTogbnVtYmVyLFxuICAgIGxlbmd0aDogbnVtYmVyLFxuICAgIG5hbWVzOiByZWFkb25seSBzdHJpbmdbXSxcbiAgICBhdE5hbWVzOiBib29sZWFuXG4gICkge1xuICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuXG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5fcmVmZXJlbmNlcyA9IEVNUFRZX1JFRkVSRU5DRVM7XG4gICAgICB0aGlzLl9uYW1lcyA9IEVNUFRZX1NUUklOR19BUlJBWTtcbiAgICAgIHRoaXMuX2F0TmFtZXMgPSBFTVBUWV9TVFJJTkdfQVJSQVk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlZmVyZW5jZXMgPSBudWxsO1xuXG4gICAgICBpZiAoYXROYW1lcykge1xuICAgICAgICB0aGlzLl9uYW1lcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2F0TmFtZXMgPSBuYW1lcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX25hbWVzID0gbmFtZXM7XG4gICAgICAgIHRoaXMuX2F0TmFtZXMgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBuYW1lcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgbGV0IG5hbWVzID0gdGhpcy5fbmFtZXM7XG5cbiAgICBpZiAoIW5hbWVzKSB7XG4gICAgICBuYW1lcyA9IHRoaXMuX25hbWVzID0gdGhpcy5fYXROYW1lcyEubWFwKHRoaXMudG9TeW50aGV0aWNOYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZXMhO1xuICB9XG5cbiAgZ2V0IGF0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIGxldCBhdE5hbWVzID0gdGhpcy5fYXROYW1lcztcblxuICAgIGlmICghYXROYW1lcykge1xuICAgICAgYXROYW1lcyA9IHRoaXMuX2F0TmFtZXMgPSB0aGlzLl9uYW1lcyEubWFwKHRoaXMudG9BdE5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBhdE5hbWVzITtcbiAgfVxuXG4gIGhhcyhuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lcy5pbmRleE9mKG5hbWUpICE9PSAtMTtcbiAgfVxuXG4gIGdldChuYW1lOiBzdHJpbmcsIGF0TmFtZXMgPSBmYWxzZSk6IFJlZmVyZW5jZSB7XG4gICAgbGV0IHsgYmFzZSwgc3RhY2sgfSA9IHRoaXM7XG5cbiAgICBsZXQgbmFtZXMgPSBhdE5hbWVzID8gdGhpcy5hdE5hbWVzIDogdGhpcy5uYW1lcztcblxuICAgIGxldCBpZHggPSBuYW1lcy5pbmRleE9mKG5hbWUpO1xuXG4gICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBVTkRFRklORURfUkVGRVJFTkNFO1xuICAgIH1cblxuICAgIGxldCByZWYgPSBzdGFjay5nZXQ8UmVmZXJlbmNlPihpZHgsIGJhc2UpO1xuXG4gICAgaWYgKERFQlVHKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRGVidWdBbGlhc1JlZiEoYXROYW1lcyA/IG5hbWUgOiBgQCR7bmFtZX1gLCByZWYpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVmO1xuICAgIH1cbiAgfVxuXG4gIGNhcHR1cmUoKTogQ2FwdHVyZWROYW1lZEFyZ3VtZW50cyB7XG4gICAgbGV0IHsgbmFtZXMsIHJlZmVyZW5jZXMgfSA9IHRoaXM7XG4gICAgbGV0IG1hcCA9IGRpY3Q8UmVmZXJlbmNlPigpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG5hbWUgPSBuYW1lc1tpXTtcblxuICAgICAgaWYgKERFQlVHKSB7XG4gICAgICAgIG1hcFtuYW1lXSA9IGNyZWF0ZURlYnVnQWxpYXNSZWYhKGBAJHtuYW1lfWAsIHJlZmVyZW5jZXNbaV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFwW25hbWVdID0gcmVmZXJlbmNlc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFwIGFzIENhcHR1cmVkTmFtZWRBcmd1bWVudHM7XG4gIH1cblxuICBtZXJnZShvdGhlcjogUmVjb3JkPHN0cmluZywgUmVmZXJlbmNlPikge1xuICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMob3RoZXIpO1xuXG4gICAgaWYgKGtleXMubGVuZ3RoID4gMCkge1xuICAgICAgbGV0IHsgbmFtZXMsIGxlbmd0aCwgc3RhY2sgfSA9IHRoaXM7XG4gICAgICBsZXQgbmV3TmFtZXMgPSBuYW1lcy5zbGljZSgpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG5hbWUgPSBrZXlzW2ldO1xuICAgICAgICBsZXQgaWR4ID0gbmV3TmFtZXMuaW5kZXhPZihuYW1lKTtcblxuICAgICAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgICAgIGxlbmd0aCA9IG5ld05hbWVzLnB1c2gobmFtZSk7XG4gICAgICAgICAgc3RhY2sucHVzaChvdGhlcltuYW1lXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICB0aGlzLl9yZWZlcmVuY2VzID0gbnVsbDtcbiAgICAgIHRoaXMuX25hbWVzID0gbmV3TmFtZXM7XG4gICAgICB0aGlzLl9hdE5hbWVzID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldCByZWZlcmVuY2VzKCk6IHJlYWRvbmx5IFJlZmVyZW5jZVtdIHtcbiAgICBsZXQgcmVmZXJlbmNlcyA9IHRoaXMuX3JlZmVyZW5jZXM7XG5cbiAgICBpZiAoIXJlZmVyZW5jZXMpIHtcbiAgICAgIGxldCB7IGJhc2UsIGxlbmd0aCwgc3RhY2sgfSA9IHRoaXM7XG4gICAgICByZWZlcmVuY2VzID0gdGhpcy5fcmVmZXJlbmNlcyA9IHN0YWNrLnNsaWNlPFJlZmVyZW5jZT4oYmFzZSwgYmFzZSArIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZmVyZW5jZXM7XG4gIH1cblxuICBwcml2YXRlIHRvU3ludGhldGljTmFtZSh0aGlzOiB2b2lkLCBuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBuYW1lLnNsaWNlKDEpO1xuICB9XG5cbiAgcHJpdmF0ZSB0b0F0TmFtZSh0aGlzOiB2b2lkLCBuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBgQCR7bmFtZX1gO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRvU3ltYm9sTmFtZShuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gYCYke25hbWV9YDtcbn1cblxuY29uc3QgRU1QVFlfQkxPQ0tfVkFMVUVTID0gZW1wdHlBcnJheTxCbG9ja1ZhbHVlPigpO1xuXG5leHBvcnQgY2xhc3MgQmxvY2tBcmd1bWVudHNJbXBsIGltcGxlbWVudHMgQmxvY2tBcmd1bWVudHMge1xuICBwcml2YXRlIHN0YWNrITogRXZhbHVhdGlvblN0YWNrO1xuICBwcml2YXRlIGludGVybmFsVmFsdWVzOiBPcHRpb248cmVhZG9ubHkgQmxvY2tWYWx1ZVtdPiA9IG51bGw7XG4gIHByaXZhdGUgX3N5bWJvbE5hbWVzOiBPcHRpb248cmVhZG9ubHkgc3RyaW5nW10+ID0gbnVsbDtcblxuICBwdWJsaWMgaW50ZXJuYWxUYWc6IE9wdGlvbjxUYWc+ID0gbnVsbDtcbiAgcHVibGljIG5hbWVzOiByZWFkb25seSBzdHJpbmdbXSA9IEVNUFRZX1NUUklOR19BUlJBWTtcblxuICBwdWJsaWMgbGVuZ3RoID0gMDtcbiAgcHVibGljIGJhc2UgPSAwO1xuXG4gIGVtcHR5KHN0YWNrOiBFdmFsdWF0aW9uU3RhY2ssIGJhc2U6IG51bWJlcikge1xuICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICB0aGlzLm5hbWVzID0gRU1QVFlfU1RSSU5HX0FSUkFZO1xuICAgIHRoaXMuYmFzZSA9IGJhc2U7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3N5bWJvbE5hbWVzID0gbnVsbDtcblxuICAgIHRoaXMuaW50ZXJuYWxUYWcgPSBDT05TVEFOVF9UQUc7XG4gICAgdGhpcy5pbnRlcm5hbFZhbHVlcyA9IEVNUFRZX0JMT0NLX1ZBTFVFUztcbiAgfVxuXG4gIHNldHVwKHN0YWNrOiBFdmFsdWF0aW9uU3RhY2ssIGJhc2U6IG51bWJlciwgbGVuZ3RoOiBudW1iZXIsIG5hbWVzOiByZWFkb25seSBzdHJpbmdbXSkge1xuICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICB0aGlzLm5hbWVzID0gbmFtZXM7XG4gICAgdGhpcy5iYXNlID0gYmFzZTtcbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB0aGlzLl9zeW1ib2xOYW1lcyA9IG51bGw7XG5cbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmludGVybmFsVGFnID0gQ09OU1RBTlRfVEFHO1xuICAgICAgdGhpcy5pbnRlcm5hbFZhbHVlcyA9IEVNUFRZX0JMT0NLX1ZBTFVFUztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbnRlcm5hbFRhZyA9IG51bGw7XG4gICAgICB0aGlzLmludGVybmFsVmFsdWVzID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBnZXQgdmFsdWVzKCk6IHJlYWRvbmx5IEJsb2NrVmFsdWVbXSB7XG4gICAgbGV0IHZhbHVlcyA9IHRoaXMuaW50ZXJuYWxWYWx1ZXM7XG5cbiAgICBpZiAoIXZhbHVlcykge1xuICAgICAgbGV0IHsgYmFzZSwgbGVuZ3RoLCBzdGFjayB9ID0gdGhpcztcbiAgICAgIHZhbHVlcyA9IHRoaXMuaW50ZXJuYWxWYWx1ZXMgPSBzdGFjay5zbGljZTxCbG9ja1ZhbHVlPihiYXNlLCBiYXNlICsgbGVuZ3RoICogMyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuXG4gIGhhcyhuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lcyEuaW5kZXhPZihuYW1lKSAhPT0gLTE7XG4gIH1cblxuICBnZXQobmFtZTogc3RyaW5nKTogT3B0aW9uPFNjb3BlQmxvY2s+IHtcbiAgICBsZXQgaWR4ID0gdGhpcy5uYW1lcyEuaW5kZXhPZihuYW1lKTtcblxuICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgeyBiYXNlLCBzdGFjayB9ID0gdGhpcztcblxuICAgIGxldCB0YWJsZSA9IGNoZWNrKHN0YWNrLmdldChpZHggKiAzLCBiYXNlKSwgQ2hlY2tPcHRpb24oQ2hlY2tCbG9ja1N5bWJvbFRhYmxlKSk7XG4gICAgbGV0IHNjb3BlID0gY2hlY2soc3RhY2suZ2V0KGlkeCAqIDMgKyAxLCBiYXNlKSwgQ2hlY2tPcHRpb24oQ2hlY2tTY29wZSkpO1xuICAgIGxldCBoYW5kbGUgPSBjaGVjayhcbiAgICAgIHN0YWNrLmdldChpZHggKiAzICsgMiwgYmFzZSksXG4gICAgICBDaGVja09wdGlvbihDaGVja09yKENoZWNrSGFuZGxlLCBDaGVja0NvbXBpbGFibGVCbG9jaykpXG4gICAgKTtcblxuICAgIHJldHVybiBoYW5kbGUgPT09IG51bGwgPyBudWxsIDogKFtoYW5kbGUsIHNjb3BlISwgdGFibGUhXSBhcyBTY29wZUJsb2NrKTtcbiAgfVxuXG4gIGNhcHR1cmUoKTogQ2FwdHVyZWRCbG9ja0FyZ3VtZW50cyB7XG4gICAgcmV0dXJuIG5ldyBDYXB0dXJlZEJsb2NrQXJndW1lbnRzSW1wbCh0aGlzLm5hbWVzLCB0aGlzLnZhbHVlcyk7XG4gIH1cblxuICBnZXQgc3ltYm9sTmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIGxldCBzeW1ib2xOYW1lcyA9IHRoaXMuX3N5bWJvbE5hbWVzO1xuXG4gICAgaWYgKHN5bWJvbE5hbWVzID09PSBudWxsKSB7XG4gICAgICBzeW1ib2xOYW1lcyA9IHRoaXMuX3N5bWJvbE5hbWVzID0gdGhpcy5uYW1lcy5tYXAodG9TeW1ib2xOYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3ltYm9sTmFtZXM7XG4gIH1cbn1cblxuY2xhc3MgQ2FwdHVyZWRCbG9ja0FyZ3VtZW50c0ltcGwgaW1wbGVtZW50cyBDYXB0dXJlZEJsb2NrQXJndW1lbnRzIHtcbiAgcHVibGljIGxlbmd0aDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBuYW1lczogcmVhZG9ubHkgc3RyaW5nW10sIHB1YmxpYyB2YWx1ZXM6IHJlYWRvbmx5IE9wdGlvbjxCbG9ja1ZhbHVlPltdKSB7XG4gICAgdGhpcy5sZW5ndGggPSBuYW1lcy5sZW5ndGg7XG4gIH1cblxuICBoYXMobmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMubmFtZXMuaW5kZXhPZihuYW1lKSAhPT0gLTE7XG4gIH1cblxuICBnZXQobmFtZTogc3RyaW5nKTogT3B0aW9uPFNjb3BlQmxvY2s+IHtcbiAgICBsZXQgaWR4ID0gdGhpcy5uYW1lcy5pbmRleE9mKG5hbWUpO1xuXG4gICAgaWYgKGlkeCA9PT0gLTEpIHJldHVybiBudWxsO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIHRoaXMudmFsdWVzW2lkeCAqIDMgKyAyXSBhcyBDb21waWxhYmxlQmxvY2ssXG4gICAgICB0aGlzLnZhbHVlc1tpZHggKiAzICsgMV0gYXMgU2NvcGUsXG4gICAgICB0aGlzLnZhbHVlc1tpZHggKiAzXSBhcyBCbG9ja1N5bWJvbFRhYmxlLFxuICAgIF07XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNhcHR1cmVkQXJncyhuYW1lZDogRGljdDxSZWZlcmVuY2U+LCBwb3NpdGlvbmFsOiBSZWZlcmVuY2VbXSkge1xuICByZXR1cm4ge1xuICAgIG5hbWVkLFxuICAgIHBvc2l0aW9uYWwsXG4gIH0gYXMgQ2FwdHVyZWRBcmd1bWVudHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWlmeU5hbWVkKG5hbWVkOiBDYXB0dXJlZE5hbWVkQXJndW1lbnRzKSB7XG4gIGxldCByZWlmaWVkID0gZGljdCgpO1xuXG4gIGZvciAobGV0IGtleSBpbiBuYW1lZCkge1xuICAgIHJlaWZpZWRba2V5XSA9IHZhbHVlRm9yUmVmKG5hbWVkW2tleV0pO1xuICB9XG5cbiAgcmV0dXJuIHJlaWZpZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWlmeVBvc2l0aW9uYWwocG9zaXRpb25hbDogQ2FwdHVyZWRQb3NpdGlvbmFsQXJndW1lbnRzKSB7XG4gIHJldHVybiBwb3NpdGlvbmFsLm1hcCh2YWx1ZUZvclJlZik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWlmeUFyZ3MoYXJnczogQ2FwdHVyZWRBcmd1bWVudHMpIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lZDogcmVpZnlOYW1lZChhcmdzLm5hbWVkKSxcbiAgICBwb3NpdGlvbmFsOiByZWlmeVBvc2l0aW9uYWwoYXJncy5wb3NpdGlvbmFsKSxcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEVNUFRZX05BTUVEID0gT2JqZWN0LmZyZWV6ZShPYmplY3QuY3JlYXRlKG51bGwpKSBhcyBDYXB0dXJlZE5hbWVkQXJndW1lbnRzO1xuZXhwb3J0IGNvbnN0IEVNUFRZX1BPU0lUSU9OQUwgPSBFTVBUWV9SRUZFUkVOQ0VTIGFzIENhcHR1cmVkUG9zaXRpb25hbEFyZ3VtZW50cztcbmV4cG9ydCBjb25zdCBFTVBUWV9BUkdTID0gY3JlYXRlQ2FwdHVyZWRBcmdzKEVNUFRZX05BTUVELCBFTVBUWV9QT1NJVElPTkFMKTtcbiIsImltcG9ydCB7XG4gIENhcHR1cmVkUG9zaXRpb25hbEFyZ3VtZW50cyxcbiAgQ3VycmllZFR5cGUsXG4gIEhlbHBlcixcbiAgSGVscGVyRGVmaW5pdGlvblN0YXRlLFxuICBPcCxcbiAgT3duZXIsXG4gIFJlc29sdXRpb25UaW1lQ29uc3RhbnRzLFxuICBSdW50aW1lQ29uc3RhbnRzLFxuICBTY29wZUJsb2NrLFxuICBWTSBhcyBQdWJsaWNWTSxcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQge1xuICBSZWZlcmVuY2UsXG4gIGNoaWxkUmVmRm9yLFxuICBVTkRFRklORURfUkVGRVJFTkNFLFxuICBUUlVFX1JFRkVSRU5DRSxcbiAgRkFMU0VfUkVGRVJFTkNFLFxuICB2YWx1ZUZvclJlZixcbiAgY3JlYXRlQ29tcHV0ZVJlZixcbn0gZnJvbSAnQGdsaW1tZXIvcmVmZXJlbmNlJztcbmltcG9ydCB7ICR2MCB9IGZyb20gJ0BnbGltbWVyL3ZtJztcbmltcG9ydCB7IEFQUEVORF9PUENPREVTIH0gZnJvbSAnLi4vLi4vb3Bjb2Rlcyc7XG5pbXBvcnQgeyBjcmVhdGVDb25jYXRSZWYgfSBmcm9tICcuLi9leHByZXNzaW9ucy9jb25jYXQnO1xuaW1wb3J0IHsgYXNzb2NpYXRlRGVzdHJveWFibGVDaGlsZCwgZGVzdHJveSwgX2hhc0Rlc3Ryb3lhYmxlQ2hpbGRyZW4gfSBmcm9tICdAZ2xpbW1lci9kZXN0cm95YWJsZSc7XG5pbXBvcnQgeyBhc3NlcnQsIGFzc2lnbiwgZGVidWdUb1N0cmluZywgZGVjb2RlSGFuZGxlLCBpc09iamVjdCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgdG9Cb29sIH0gZnJvbSAnQGdsaW1tZXIvZ2xvYmFsLWNvbnRleHQnO1xuaW1wb3J0IHtcbiAgY2hlY2ssXG4gIENoZWNrT3B0aW9uLFxuICBDaGVja0hhbmRsZSxcbiAgQ2hlY2tCbG9ja1N5bWJvbFRhYmxlLFxuICBDaGVja09yLFxuICBDaGVja01heWJlLFxufSBmcm9tICdAZ2xpbW1lci9kZWJ1Zyc7XG5pbXBvcnQge1xuICBDaGVja0FyZ3VtZW50cyxcbiAgQ2hlY2tSZWZlcmVuY2UsXG4gIENoZWNrQ29tcGlsYWJsZUJsb2NrLFxuICBDaGVja1Njb3BlLFxuICBDaGVja0hlbHBlcixcbiAgQ2hlY2tVbmRlZmluZWRSZWZlcmVuY2UsXG4gIENoZWNrU2NvcGVCbG9jayxcbiAgQ2hlY2tDYXB0dXJlZEFyZ3VtZW50cyxcbn0gZnJvbSAnLi8tZGVidWctc3RyaXAnO1xuaW1wb3J0IHsgQ09OU1RBTlRTIH0gZnJvbSAnLi4vLi4vc3ltYm9scyc7XG5pbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5pbXBvcnQgY3JlYXRlQ3VycnlSZWYgZnJvbSAnLi4vLi4vcmVmZXJlbmNlcy9jdXJyeS12YWx1ZSc7XG5pbXBvcnQgeyBpc0N1cnJpZWRUeXBlLCByZXNvbHZlQ3VycmllZFZhbHVlIH0gZnJvbSAnLi4vLi4vY3VycmllZC12YWx1ZSc7XG5pbXBvcnQgeyByZWlmeVBvc2l0aW9uYWwgfSBmcm9tICcuLi8uLi92bS9hcmd1bWVudHMnO1xuXG5leHBvcnQgdHlwZSBGdW5jdGlvbkV4cHJlc3Npb248VD4gPSAodm06IFB1YmxpY1ZNKSA9PiBSZWZlcmVuY2U8VD47XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5DdXJyeSwgKHZtLCB7IG9wMTogdHlwZSwgb3AyOiBfaXNTdHJpY3QgfSkgPT4ge1xuICBsZXQgc3RhY2sgPSB2bS5zdGFjaztcblxuICBsZXQgZGVmaW5pdGlvbiA9IGNoZWNrKHN0YWNrLnBvcCgpLCBDaGVja1JlZmVyZW5jZSk7XG4gIGxldCBjYXB0dXJlZEFyZ3MgPSBjaGVjayhzdGFjay5wb3AoKSwgQ2hlY2tDYXB0dXJlZEFyZ3VtZW50cyk7XG5cbiAgbGV0IG93bmVyID0gdm0uZ2V0T3duZXIoKTtcbiAgbGV0IHJlc29sdmVyID0gdm0ucnVudGltZS5yZXNvbHZlcjtcblxuICBsZXQgaXNTdHJpY3QgPSBmYWxzZTtcblxuICBpZiAoREVCVUcpIHtcbiAgICAvLyBzdHJpY3QgY2hlY2sgb25seSBoYXBwZW5zIGluIERFQlVHIGJ1aWxkcywgbm8gcmVhc29uIHRvIGxvYWQgaXQgb3RoZXJ3aXNlXG4gICAgaXNTdHJpY3QgPSB2bVtDT05TVEFOVFNdLmdldFZhbHVlPGJvb2xlYW4+KGRlY29kZUhhbmRsZShfaXNTdHJpY3QpKTtcbiAgfVxuXG4gIHZtLmxvYWRWYWx1ZShcbiAgICAkdjAsXG4gICAgY3JlYXRlQ3VycnlSZWYodHlwZSBhcyBDdXJyaWVkVHlwZSwgZGVmaW5pdGlvbiwgb3duZXIsIGNhcHR1cmVkQXJncywgcmVzb2x2ZXIsIGlzU3RyaWN0KVxuICApO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5EeW5hbWljSGVscGVyLCAodm0pID0+IHtcbiAgbGV0IHN0YWNrID0gdm0uc3RhY2s7XG4gIGxldCByZWYgPSBjaGVjayhzdGFjay5wb3AoKSwgQ2hlY2tSZWZlcmVuY2UpO1xuICBsZXQgYXJncyA9IGNoZWNrKHN0YWNrLnBvcCgpLCBDaGVja0FyZ3VtZW50cykuY2FwdHVyZSgpO1xuXG4gIGxldCBoZWxwZXJSZWY6IFJlZmVyZW5jZTtcbiAgbGV0IGluaXRpYWxPd25lcjogT3duZXIgPSB2bS5nZXRPd25lcigpO1xuXG4gIGxldCBoZWxwZXJJbnN0YW5jZVJlZiA9IGNyZWF0ZUNvbXB1dGVSZWYoKCkgPT4ge1xuICAgIGlmIChoZWxwZXJSZWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVzdHJveShoZWxwZXJSZWYpO1xuICAgIH1cblxuICAgIGxldCBkZWZpbml0aW9uID0gdmFsdWVGb3JSZWYocmVmKTtcblxuICAgIGlmIChpc0N1cnJpZWRUeXBlKGRlZmluaXRpb24sIEN1cnJpZWRUeXBlLkhlbHBlcikpIHtcbiAgICAgIGxldCB7IGRlZmluaXRpb246IHJlc29sdmVkRGVmLCBvd25lciwgcG9zaXRpb25hbCwgbmFtZWQgfSA9IHJlc29sdmVDdXJyaWVkVmFsdWUoZGVmaW5pdGlvbik7XG5cbiAgICAgIGxldCBoZWxwZXIgPSByZXNvbHZlSGVscGVyKHZtW0NPTlNUQU5UU10sIHJlc29sdmVkRGVmLCByZWYpO1xuXG4gICAgICBpZiAobmFtZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhcmdzLm5hbWVkID0gYXNzaWduKHt9LCAuLi5uYW1lZCwgYXJncy5uYW1lZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3NpdGlvbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXJncy5wb3NpdGlvbmFsID0gcG9zaXRpb25hbC5jb25jYXQoYXJncy5wb3NpdGlvbmFsKSBhcyBDYXB0dXJlZFBvc2l0aW9uYWxBcmd1bWVudHM7XG4gICAgICB9XG5cbiAgICAgIGhlbHBlclJlZiA9IGhlbHBlcihhcmdzLCBvd25lcik7XG5cbiAgICAgIGFzc29jaWF0ZURlc3Ryb3lhYmxlQ2hpbGQoaGVscGVySW5zdGFuY2VSZWYsIGhlbHBlclJlZik7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgbGV0IGhlbHBlciA9IHJlc29sdmVIZWxwZXIodm1bQ09OU1RBTlRTXSwgZGVmaW5pdGlvbiwgcmVmKTtcbiAgICAgIGhlbHBlclJlZiA9IGhlbHBlcihhcmdzLCBpbml0aWFsT3duZXIpO1xuXG4gICAgICBpZiAoX2hhc0Rlc3Ryb3lhYmxlQ2hpbGRyZW4oaGVscGVyUmVmKSkge1xuICAgICAgICBhc3NvY2lhdGVEZXN0cm95YWJsZUNoaWxkKGhlbHBlckluc3RhbmNlUmVmLCBoZWxwZXJSZWYpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBoZWxwZXJSZWYgPSBVTkRFRklORURfUkVGRVJFTkNFO1xuICAgIH1cbiAgfSk7XG5cbiAgbGV0IGhlbHBlclZhbHVlUmVmID0gY3JlYXRlQ29tcHV0ZVJlZigoKSA9PiB7XG4gICAgdmFsdWVGb3JSZWYoaGVscGVySW5zdGFuY2VSZWYpO1xuICAgIHJldHVybiB2YWx1ZUZvclJlZihoZWxwZXJSZWYpO1xuICB9KTtcblxuICB2bS5hc3NvY2lhdGVEZXN0cm95YWJsZShoZWxwZXJJbnN0YW5jZVJlZik7XG4gIHZtLmxvYWRWYWx1ZSgkdjAsIGhlbHBlclZhbHVlUmVmKTtcbn0pO1xuXG5mdW5jdGlvbiByZXNvbHZlSGVscGVyKFxuICBjb25zdGFudHM6IFJ1bnRpbWVDb25zdGFudHMgJiBSZXNvbHV0aW9uVGltZUNvbnN0YW50cyxcbiAgZGVmaW5pdGlvbjogSGVscGVyRGVmaW5pdGlvblN0YXRlLFxuICByZWY6IFJlZmVyZW5jZVxuKTogSGVscGVyIHtcbiAgbGV0IGhhbmRsZSA9IGNvbnN0YW50cy5oZWxwZXIoZGVmaW5pdGlvbiwgbnVsbCwgdHJ1ZSkhO1xuXG4gIGlmIChERUJVRyAmJiBoYW5kbGUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgYSBkeW5hbWljIGhlbHBlciBkZWZpbml0aW9uLCBidXQgcmVjZWl2ZWQgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHRoYXQgZGlkIG5vdCBoYXZlIGEgaGVscGVyIG1hbmFnZXIgYXNzb2NpYXRlZCB3aXRoIGl0LiBUaGUgZHluYW1pYyBpbnZvY2F0aW9uIHdhcyBcXGB7eyR7XG4gICAgICAgIHJlZi5kZWJ1Z0xhYmVsXG4gICAgICB9fX1cXGAgb3IgXFxgKCR7cmVmLmRlYnVnTGFiZWx9KVxcYCwgYW5kIHRoZSBpbmNvcnJlY3QgZGVmaW5pdGlvbiBpcyB0aGUgdmFsdWUgYXQgdGhlIHBhdGggXFxgJHtcbiAgICAgICAgcmVmLmRlYnVnTGFiZWxcbiAgICAgIH1cXGAsIHdoaWNoIHdhczogJHtkZWJ1Z1RvU3RyaW5nIShkZWZpbml0aW9uKX1gXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBjb25zdGFudHMuZ2V0VmFsdWUoaGFuZGxlKTtcbn1cblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkhlbHBlciwgKHZtLCB7IG9wMTogaGFuZGxlIH0pID0+IHtcbiAgbGV0IHN0YWNrID0gdm0uc3RhY2s7XG4gIGxldCBoZWxwZXIgPSBjaGVjayh2bVtDT05TVEFOVFNdLmdldFZhbHVlKGhhbmRsZSksIENoZWNrSGVscGVyKTtcbiAgbGV0IGFyZ3MgPSBjaGVjayhzdGFjay5wb3AoKSwgQ2hlY2tBcmd1bWVudHMpO1xuICBsZXQgdmFsdWUgPSBoZWxwZXIoYXJncy5jYXB0dXJlKCksIHZtLmdldE93bmVyKCksIHZtLmR5bmFtaWNTY29wZSgpKTtcblxuICBpZiAoX2hhc0Rlc3Ryb3lhYmxlQ2hpbGRyZW4odmFsdWUpKSB7XG4gICAgdm0uYXNzb2NpYXRlRGVzdHJveWFibGUodmFsdWUpO1xuICB9XG5cbiAgdm0ubG9hZFZhbHVlKCR2MCwgdmFsdWUpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5HZXRWYXJpYWJsZSwgKHZtLCB7IG9wMTogc3ltYm9sIH0pID0+IHtcbiAgbGV0IGV4cHIgPSB2bS5yZWZlcmVuY2VGb3JTeW1ib2woc3ltYm9sKTtcblxuICB2bS5zdGFjay5wdXNoKGV4cHIpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5TZXRWYXJpYWJsZSwgKHZtLCB7IG9wMTogc3ltYm9sIH0pID0+IHtcbiAgbGV0IGV4cHIgPSBjaGVjayh2bS5zdGFjay5wb3AoKSwgQ2hlY2tSZWZlcmVuY2UpO1xuICB2bS5zY29wZSgpLmJpbmRTeW1ib2woc3ltYm9sLCBleHByKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuU2V0QmxvY2ssICh2bSwgeyBvcDE6IHN5bWJvbCB9KSA9PiB7XG4gIGxldCBoYW5kbGUgPSBjaGVjayh2bS5zdGFjay5wb3AoKSwgQ2hlY2tDb21waWxhYmxlQmxvY2spO1xuICBsZXQgc2NvcGUgPSBjaGVjayh2bS5zdGFjay5wb3AoKSwgQ2hlY2tTY29wZSk7XG4gIGxldCB0YWJsZSA9IGNoZWNrKHZtLnN0YWNrLnBvcCgpLCBDaGVja0Jsb2NrU3ltYm9sVGFibGUpO1xuXG4gIHZtLnNjb3BlKCkuYmluZEJsb2NrKHN5bWJvbCwgW2hhbmRsZSwgc2NvcGUsIHRhYmxlXSk7XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLlJlc29sdmVNYXliZUxvY2FsLCAodm0sIHsgb3AxOiBfbmFtZSB9KSA9PiB7XG4gIGxldCBuYW1lID0gdm1bQ09OU1RBTlRTXS5nZXRWYWx1ZTxzdHJpbmc+KF9uYW1lKTtcbiAgbGV0IGxvY2FscyA9IHZtLnNjb3BlKCkuZ2V0UGFydGlhbE1hcCgpITtcblxuICBsZXQgcmVmID0gbG9jYWxzW25hbWVdO1xuICBpZiAocmVmID09PSB1bmRlZmluZWQpIHtcbiAgICByZWYgPSBjaGlsZFJlZkZvcih2bS5nZXRTZWxmKCksIG5hbWUpO1xuICB9XG5cbiAgdm0uc3RhY2sucHVzaChyZWYpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5Sb290U2NvcGUsICh2bSwgeyBvcDE6IHN5bWJvbHMgfSkgPT4ge1xuICB2bS5wdXNoUm9vdFNjb3BlKHN5bWJvbHMsIHZtLmdldE93bmVyKCkpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5HZXRQcm9wZXJ0eSwgKHZtLCB7IG9wMTogX2tleSB9KSA9PiB7XG4gIGxldCBrZXkgPSB2bVtDT05TVEFOVFNdLmdldFZhbHVlPHN0cmluZz4oX2tleSk7XG4gIGxldCBleHByID0gY2hlY2sodm0uc3RhY2sucG9wKCksIENoZWNrUmVmZXJlbmNlKTtcbiAgdm0uc3RhY2sucHVzaChjaGlsZFJlZkZvcihleHByLCBrZXkpKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuR2V0QmxvY2ssICh2bSwgeyBvcDE6IF9ibG9jayB9KSA9PiB7XG4gIGxldCB7IHN0YWNrIH0gPSB2bTtcbiAgbGV0IGJsb2NrID0gdm0uc2NvcGUoKS5nZXRCbG9jayhfYmxvY2spO1xuXG4gIHN0YWNrLnB1c2goYmxvY2spO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5TcHJlYWRCbG9jaywgKHZtKSA9PiB7XG4gIGxldCB7IHN0YWNrIH0gPSB2bTtcbiAgbGV0IGJsb2NrID0gY2hlY2soc3RhY2sucG9wKCksIENoZWNrT3B0aW9uKENoZWNrT3IoQ2hlY2tTY29wZUJsb2NrLCBDaGVja1VuZGVmaW5lZFJlZmVyZW5jZSkpKTtcblxuICBpZiAoYmxvY2sgJiYgIWlzVW5kZWZpbmVkUmVmZXJlbmNlKGJsb2NrKSkge1xuICAgIGxldCBbaGFuZGxlT3JDb21waWxhYmxlLCBzY29wZSwgdGFibGVdID0gYmxvY2s7XG5cbiAgICBzdGFjay5wdXNoKHRhYmxlKTtcbiAgICBzdGFjay5wdXNoKHNjb3BlKTtcbiAgICBzdGFjay5wdXNoKGhhbmRsZU9yQ29tcGlsYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgc3RhY2sucHVzaChudWxsKTtcbiAgICBzdGFjay5wdXNoKG51bGwpO1xuICAgIHN0YWNrLnB1c2gobnVsbCk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZFJlZmVyZW5jZShpbnB1dDogU2NvcGVCbG9jayB8IFJlZmVyZW5jZSk6IGlucHV0IGlzIFJlZmVyZW5jZSB7XG4gIGFzc2VydChcbiAgICBBcnJheS5pc0FycmF5KGlucHV0KSB8fCBpbnB1dCA9PT0gVU5ERUZJTkVEX1JFRkVSRU5DRSxcbiAgICAnYSByZWZlcmVuY2Ugb3RoZXIgdGhhbiBVTkRFRklORURfUkVGRVJFTkNFIGlzIGlsbGVnYWwgaGVyZSdcbiAgKTtcbiAgcmV0dXJuIGlucHV0ID09PSBVTkRFRklORURfUkVGRVJFTkNFO1xufVxuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuSGFzQmxvY2ssICh2bSkgPT4ge1xuICBsZXQgeyBzdGFjayB9ID0gdm07XG4gIGxldCBibG9jayA9IGNoZWNrKHN0YWNrLnBvcCgpLCBDaGVja09wdGlvbihDaGVja09yKENoZWNrU2NvcGVCbG9jaywgQ2hlY2tVbmRlZmluZWRSZWZlcmVuY2UpKSk7XG5cbiAgaWYgKGJsb2NrICYmICFpc1VuZGVmaW5lZFJlZmVyZW5jZShibG9jaykpIHtcbiAgICBzdGFjay5wdXNoKFRSVUVfUkVGRVJFTkNFKTtcbiAgfSBlbHNlIHtcbiAgICBzdGFjay5wdXNoKEZBTFNFX1JFRkVSRU5DRSk7XG4gIH1cbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuSGFzQmxvY2tQYXJhbXMsICh2bSkgPT4ge1xuICAvLyBGSVhNRShtbXVuKTogc2hvdWxkIG9ubHkgbmVlZCB0byBwdXNoIHRoZSBzeW1ib2wgdGFibGVcbiAgbGV0IGJsb2NrID0gdm0uc3RhY2sucG9wKCk7XG4gIGxldCBzY29wZSA9IHZtLnN0YWNrLnBvcCgpO1xuXG4gIGNoZWNrKGJsb2NrLCBDaGVja01heWJlKENoZWNrT3IoQ2hlY2tIYW5kbGUsIENoZWNrQ29tcGlsYWJsZUJsb2NrKSkpO1xuICBjaGVjayhzY29wZSwgQ2hlY2tNYXliZShDaGVja1Njb3BlKSk7XG4gIGxldCB0YWJsZSA9IGNoZWNrKHZtLnN0YWNrLnBvcCgpLCBDaGVja01heWJlKENoZWNrQmxvY2tTeW1ib2xUYWJsZSkpO1xuXG4gIGxldCBoYXNCbG9ja1BhcmFtcyA9IHRhYmxlICYmIHRhYmxlLnBhcmFtZXRlcnMubGVuZ3RoO1xuICB2bS5zdGFjay5wdXNoKGhhc0Jsb2NrUGFyYW1zID8gVFJVRV9SRUZFUkVOQ0UgOiBGQUxTRV9SRUZFUkVOQ0UpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5Db25jYXQsICh2bSwgeyBvcDE6IGNvdW50IH0pID0+IHtcbiAgbGV0IG91dDogQXJyYXk8UmVmZXJlbmNlPHVua25vd24+PiA9IG5ldyBBcnJheShjb3VudCk7XG5cbiAgZm9yIChsZXQgaSA9IGNvdW50OyBpID4gMDsgaS0tKSB7XG4gICAgbGV0IG9mZnNldCA9IGkgLSAxO1xuICAgIG91dFtvZmZzZXRdID0gY2hlY2sodm0uc3RhY2sucG9wKCksIENoZWNrUmVmZXJlbmNlKTtcbiAgfVxuXG4gIHZtLnN0YWNrLnB1c2goY3JlYXRlQ29uY2F0UmVmKG91dCkpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5JZklubGluZSwgKHZtKSA9PiB7XG4gIGxldCBjb25kaXRpb24gPSBjaGVjayh2bS5zdGFjay5wb3AoKSwgQ2hlY2tSZWZlcmVuY2UpO1xuICBsZXQgdHJ1dGh5ID0gY2hlY2sodm0uc3RhY2sucG9wKCksIENoZWNrUmVmZXJlbmNlKTtcbiAgbGV0IGZhbHN5ID0gY2hlY2sodm0uc3RhY2sucG9wKCksIENoZWNrUmVmZXJlbmNlKTtcblxuICB2bS5zdGFjay5wdXNoKFxuICAgIGNyZWF0ZUNvbXB1dGVSZWYoKCkgPT4ge1xuICAgICAgaWYgKHRvQm9vbCh2YWx1ZUZvclJlZihjb25kaXRpb24pKSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWVGb3JSZWYodHJ1dGh5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZUZvclJlZihmYWxzeSk7XG4gICAgICB9XG4gICAgfSlcbiAgKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuTm90LCAodm0pID0+IHtcbiAgbGV0IHJlZiA9IGNoZWNrKHZtLnN0YWNrLnBvcCgpLCBDaGVja1JlZmVyZW5jZSk7XG5cbiAgdm0uc3RhY2sucHVzaChcbiAgICBjcmVhdGVDb21wdXRlUmVmKCgpID0+IHtcbiAgICAgIHJldHVybiAhdG9Cb29sKHZhbHVlRm9yUmVmKHJlZikpO1xuICAgIH0pXG4gICk7XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkdldER5bmFtaWNWYXIsICh2bSkgPT4ge1xuICBsZXQgc2NvcGUgPSB2bS5keW5hbWljU2NvcGUoKTtcbiAgbGV0IHN0YWNrID0gdm0uc3RhY2s7XG4gIGxldCBuYW1lUmVmID0gY2hlY2soc3RhY2sucG9wKCksIENoZWNrUmVmZXJlbmNlKTtcblxuICBzdGFjay5wdXNoKFxuICAgIGNyZWF0ZUNvbXB1dGVSZWYoKCkgPT4ge1xuICAgICAgbGV0IG5hbWUgPSBTdHJpbmcodmFsdWVGb3JSZWYobmFtZVJlZikpO1xuICAgICAgcmV0dXJuIHZhbHVlRm9yUmVmKHNjb3BlLmdldChuYW1lKSk7XG4gICAgfSlcbiAgKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuTG9nLCAodm0pID0+IHtcbiAgbGV0IHsgcG9zaXRpb25hbCB9ID0gY2hlY2sodm0uc3RhY2sucG9wKCksIENoZWNrQXJndW1lbnRzKS5jYXB0dXJlKCk7XG5cbiAgdm0ubG9hZFZhbHVlKFxuICAgICR2MCxcbiAgICBjcmVhdGVDb21wdXRlUmVmKCgpID0+IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmxvZyguLi5yZWlmeVBvc2l0aW9uYWwocG9zaXRpb25hbCkpO1xuICAgIH0pXG4gICk7XG59KTtcbiIsImltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7XG4gIENvbXBvbmVudERlZmluaXRpb24sXG4gIE9wdGlvbixcbiAgT3duZXIsXG4gIFJ1bnRpbWVSZXNvbHZlcixcbiAgUmVzb2x1dGlvblRpbWVDb25zdGFudHMsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgZXhwZWN0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50KFxuICByZXNvbHZlcjogUnVudGltZVJlc29sdmVyLFxuICBjb25zdGFudHM6IFJlc29sdXRpb25UaW1lQ29uc3RhbnRzLFxuICBuYW1lOiBzdHJpbmcsXG4gIG93bmVyOiBPd25lciB8IG51bGxcbik6IE9wdGlvbjxDb21wb25lbnREZWZpbml0aW9uPiB7XG4gIGxldCBkZWZpbml0aW9uID0gcmVzb2x2ZXIubG9va3VwQ29tcG9uZW50KFxuICAgIG5hbWUsXG4gICAgZXhwZWN0KG93bmVyLCAnQlVHOiBleHBlY3RlZCBvd25lciB3aGVuIGxvb2tpbmcgdXAgY29tcG9uZW50JylcbiAgKTtcblxuICBpZiAoREVCVUcgJiYgIWRlZmluaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQXR0ZW1wdGVkIHRvIHJlc29sdmUgXFxgJHtuYW1lfVxcYCwgd2hpY2ggd2FzIGV4cGVjdGVkIHRvIGJlIGEgY29tcG9uZW50LCBidXQgbm90aGluZyB3YXMgZm91bmQuYFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gY29uc3RhbnRzLnJlc29sdmVkQ29tcG9uZW50KGRlZmluaXRpb24hLCBuYW1lKTtcbn1cbiIsImltcG9ydCB7XG4gIENvbXBvbmVudERlZmluaXRpb25TdGF0ZSxcbiAgQ29tcG9uZW50SW5zdGFuY2VTdGF0ZSxcbiAgSW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyLFxuICBXaXRoQ3VzdG9tRGVidWdSZW5kZXJUcmVlLFxufSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc0N1c3RvbURlYnVnUmVuZGVyVHJlZUxpZmVjeWNsZTxcbiAgRCBleHRlbmRzIENvbXBvbmVudERlZmluaXRpb25TdGF0ZSxcbiAgSSBleHRlbmRzIENvbXBvbmVudEluc3RhbmNlU3RhdGVcbj4obWFuYWdlcjogSW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyPEksIEQ+KTogbWFuYWdlciBpcyBXaXRoQ3VzdG9tRGVidWdSZW5kZXJUcmVlPEksIEQ+IHtcbiAgcmV0dXJuICdnZXREZWJ1Z0N1c3RvbVJlbmRlclRyZWUnIGluIG1hbmFnZXI7XG59XG4iLCJpbXBvcnQgeyBSZWZlcmVuY2UsIGNyZWF0ZUNvbXB1dGVSZWYsIHZhbHVlRm9yUmVmIH0gZnJvbSAnQGdsaW1tZXIvcmVmZXJlbmNlJztcblxuaW1wb3J0IHsgbm9ybWFsaXplU3RyaW5nVmFsdWUgfSBmcm9tICcuLi9kb20vbm9ybWFsaXplJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlQ2xhc3NMaXN0UmVmKGxpc3Q6IFJlZmVyZW5jZVtdKSB7XG4gIHJldHVybiBjcmVhdGVDb21wdXRlUmVmKCgpID0+IHtcbiAgICBsZXQgcmV0OiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgcmVmID0gbGlzdFtpXTtcbiAgICAgIGxldCB2YWx1ZSA9IG5vcm1hbGl6ZVN0cmluZ1ZhbHVlKHR5cGVvZiByZWYgPT09ICdzdHJpbmcnID8gcmVmIDogdmFsdWVGb3JSZWYobGlzdFtpXSkpO1xuICAgICAgaWYgKHZhbHVlKSByZXQucHVzaCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBudWxsIDogcmV0LmpvaW4oJyAnKTtcbiAgfSk7XG59XG4iLCJpbXBvcnQgeyB0b0Jvb2wgfSBmcm9tICdAZ2xpbW1lci9nbG9iYWwtY29udGV4dCc7XG5pbXBvcnQgeyBDb21waWxhYmxlVGVtcGxhdGUsIE9wdGlvbiwgT3AsIFVwZGF0aW5nT3Bjb2RlIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQge1xuICBSZWZlcmVuY2UsXG4gIHZhbHVlRm9yUmVmLFxuICBpc0NvbnN0UmVmLFxuICBjcmVhdGVQcmltaXRpdmVSZWYsXG4gIFVOREVGSU5FRF9SRUZFUkVOQ0UsXG4gIE5VTExfUkVGRVJFTkNFLFxuICBUUlVFX1JFRkVSRU5DRSxcbiAgRkFMU0VfUkVGRVJFTkNFLFxuICBjcmVhdGVDb21wdXRlUmVmLFxuICBjcmVhdGVDb25zdFJlZixcbn0gZnJvbSAnQGdsaW1tZXIvcmVmZXJlbmNlJztcbmltcG9ydCB7XG4gIENPTlNUQU5UX1RBRyxcbiAgUmV2aXNpb24sXG4gIFRhZyxcbiAgdmFsdWVGb3JUYWcsXG4gIHZhbGlkYXRlVGFnLFxuICBJTklUSUFMLFxuICBiZWdpblRyYWNrRnJhbWUsXG4gIGVuZFRyYWNrRnJhbWUsXG4gIGNvbnN1bWVUYWcsXG59IGZyb20gJ0BnbGltbWVyL3ZhbGlkYXRvcic7XG5pbXBvcnQgeyBhc3NlcnQsIGRlY29kZUhhbmRsZSwgZGVjb2RlSW1tZWRpYXRlLCBleHBlY3QsIGlzSGFuZGxlIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQge1xuICBDaGVja051bWJlcixcbiAgY2hlY2ssXG4gIENoZWNrSW5zdGFuY2VvZixcbiAgQ2hlY2tPcHRpb24sXG4gIENoZWNrQmxvY2tTeW1ib2xUYWJsZSxcbiAgQ2hlY2tIYW5kbGUsXG4gIENoZWNrUHJpbWl0aXZlLFxufSBmcm9tICdAZ2xpbW1lci9kZWJ1Zyc7XG5pbXBvcnQgeyBzdGFja0Fzc2VydCB9IGZyb20gJy4vYXNzZXJ0JztcbmltcG9ydCB7IEFQUEVORF9PUENPREVTIH0gZnJvbSAnLi4vLi4vb3Bjb2Rlcyc7XG5pbXBvcnQgeyBVcGRhdGluZ1ZNIH0gZnJvbSAnLi4vLi4vdm0nO1xuaW1wb3J0IHsgVk1Bcmd1bWVudHNJbXBsIH0gZnJvbSAnLi4vLi4vdm0vYXJndW1lbnRzJztcbmltcG9ydCB7IENoZWNrUmVmZXJlbmNlLCBDaGVja1Njb3BlIH0gZnJvbSAnLi8tZGVidWctc3RyaXAnO1xuaW1wb3J0IHsgQ09OU1RBTlRTIH0gZnJvbSAnLi4vLi4vc3ltYm9scyc7XG5pbXBvcnQgeyBJbnRlcm5hbFZNIH0gZnJvbSAnLi4vLi4vdm0vYXBwZW5kJztcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkNoaWxkU2NvcGUsICh2bSkgPT4gdm0ucHVzaENoaWxkU2NvcGUoKSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5Qb3BTY29wZSwgKHZtKSA9PiB2bS5wb3BTY29wZSgpKTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLlB1c2hEeW5hbWljU2NvcGUsICh2bSkgPT4gdm0ucHVzaER5bmFtaWNTY29wZSgpKTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLlBvcER5bmFtaWNTY29wZSwgKHZtKSA9PiB2bS5wb3BEeW5hbWljU2NvcGUoKSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5Db25zdGFudCwgKHZtLCB7IG9wMTogb3RoZXIgfSkgPT4ge1xuICB2bS5zdGFjay5wdXNoKHZtW0NPTlNUQU5UU10uZ2V0VmFsdWUoZGVjb2RlSGFuZGxlKG90aGVyKSkpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5Db25zdGFudFJlZmVyZW5jZSwgKHZtLCB7IG9wMTogb3RoZXIgfSkgPT4ge1xuICB2bS5zdGFjay5wdXNoKGNyZWF0ZUNvbnN0UmVmKHZtW0NPTlNUQU5UU10uZ2V0VmFsdWUoZGVjb2RlSGFuZGxlKG90aGVyKSksIGZhbHNlKSk7XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLlByaW1pdGl2ZSwgKHZtLCB7IG9wMTogcHJpbWl0aXZlIH0pID0+IHtcbiAgbGV0IHN0YWNrID0gdm0uc3RhY2s7XG5cbiAgaWYgKGlzSGFuZGxlKHByaW1pdGl2ZSkpIHtcbiAgICAvLyBpdCBpcyBhIGhhbmRsZSB3aGljaCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0IG9uIHRoZSBzdGFja1xuICAgIGxldCB2YWx1ZSA9IHZtW0NPTlNUQU5UU10uZ2V0VmFsdWUoZGVjb2RlSGFuZGxlKHByaW1pdGl2ZSkpO1xuICAgIHN0YWNrLnB1c2godmFsdWUgYXMgb2JqZWN0KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpcyBhbHJlYWR5IGFuIGVuY29kZWQgaW1tZWRpYXRlIG9yIHByaW1pdGl2ZSBoYW5kbGVcbiAgICBzdGFjay5wdXNoKGRlY29kZUltbWVkaWF0ZShwcmltaXRpdmUpKTtcbiAgfVxufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5QcmltaXRpdmVSZWZlcmVuY2UsICh2bSkgPT4ge1xuICBsZXQgc3RhY2sgPSB2bS5zdGFjaztcbiAgbGV0IHZhbHVlID0gY2hlY2soc3RhY2sucG9wKCksIENoZWNrUHJpbWl0aXZlKTtcbiAgbGV0IHJlZjtcblxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJlZiA9IFVOREVGSU5FRF9SRUZFUkVOQ0U7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZWYgPSBOVUxMX1JFRkVSRU5DRTtcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgIHJlZiA9IFRSVUVfUkVGRVJFTkNFO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgIHJlZiA9IEZBTFNFX1JFRkVSRU5DRTtcbiAgfSBlbHNlIHtcbiAgICByZWYgPSBjcmVhdGVQcmltaXRpdmVSZWYodmFsdWUpO1xuICB9XG5cbiAgc3RhY2sucHVzaChyZWYpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5EdXAsICh2bSwgeyBvcDE6IHJlZ2lzdGVyLCBvcDI6IG9mZnNldCB9KSA9PiB7XG4gIGxldCBwb3NpdGlvbiA9IGNoZWNrKHZtLmZldGNoVmFsdWUocmVnaXN0ZXIpLCBDaGVja051bWJlcikgLSBvZmZzZXQ7XG4gIHZtLnN0YWNrLmR1cChwb3NpdGlvbik7XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLlBvcCwgKHZtLCB7IG9wMTogY291bnQgfSkgPT4ge1xuICB2bS5zdGFjay5wb3AoY291bnQpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5Mb2FkLCAodm0sIHsgb3AxOiByZWdpc3RlciB9KSA9PiB7XG4gIHZtLmxvYWQocmVnaXN0ZXIpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5GZXRjaCwgKHZtLCB7IG9wMTogcmVnaXN0ZXIgfSkgPT4ge1xuICB2bS5mZXRjaChyZWdpc3Rlcik7XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkJpbmREeW5hbWljU2NvcGUsICh2bSwgeyBvcDE6IF9uYW1lcyB9KSA9PiB7XG4gIGxldCBuYW1lcyA9IHZtW0NPTlNUQU5UU10uZ2V0QXJyYXk8c3RyaW5nPihfbmFtZXMpO1xuICB2bS5iaW5kRHluYW1pY1Njb3BlKG5hbWVzKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuRW50ZXIsICh2bSwgeyBvcDE6IGFyZ3MgfSkgPT4ge1xuICB2bS5lbnRlcihhcmdzKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuRXhpdCwgKHZtKSA9PiB7XG4gIHZtLmV4aXQoKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuUHVzaFN5bWJvbFRhYmxlLCAodm0sIHsgb3AxOiBfdGFibGUgfSkgPT4ge1xuICBsZXQgc3RhY2sgPSB2bS5zdGFjaztcbiAgc3RhY2sucHVzaCh2bVtDT05TVEFOVFNdLmdldFZhbHVlKF90YWJsZSkpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5QdXNoQmxvY2tTY29wZSwgKHZtKSA9PiB7XG4gIGxldCBzdGFjayA9IHZtLnN0YWNrO1xuICBzdGFjay5wdXNoKHZtLnNjb3BlKCkpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5Db21waWxlQmxvY2ssICh2bTogSW50ZXJuYWxWTSkgPT4ge1xuICBsZXQgc3RhY2sgPSB2bS5zdGFjaztcbiAgbGV0IGJsb2NrID0gc3RhY2sucG9wPE9wdGlvbjxDb21waWxhYmxlVGVtcGxhdGU+IHwgMD4oKTtcblxuICBpZiAoYmxvY2spIHtcbiAgICBzdGFjay5wdXNoKHZtLmNvbXBpbGUoYmxvY2spKTtcbiAgfSBlbHNlIHtcbiAgICBzdGFjay5wdXNoKG51bGwpO1xuICB9XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkludm9rZVlpZWxkLCAodm0pID0+IHtcbiAgbGV0IHsgc3RhY2sgfSA9IHZtO1xuXG4gIGxldCBoYW5kbGUgPSBjaGVjayhzdGFjay5wb3AoKSwgQ2hlY2tPcHRpb24oQ2hlY2tIYW5kbGUpKTtcbiAgbGV0IHNjb3BlID0gY2hlY2soc3RhY2sucG9wKCksIENoZWNrT3B0aW9uKENoZWNrU2NvcGUpKTtcbiAgbGV0IHRhYmxlID0gY2hlY2soc3RhY2sucG9wKCksIENoZWNrT3B0aW9uKENoZWNrQmxvY2tTeW1ib2xUYWJsZSkpO1xuXG4gIGFzc2VydChcbiAgICB0YWJsZSA9PT0gbnVsbCB8fCAodGFibGUgJiYgdHlwZW9mIHRhYmxlID09PSAnb2JqZWN0JyAmJiBBcnJheS5pc0FycmF5KHRhYmxlLnBhcmFtZXRlcnMpKSxcbiAgICBzdGFja0Fzc2VydCgnT3B0aW9uPEJsb2NrU3ltYm9sVGFibGU+JywgdGFibGUpXG4gICk7XG5cbiAgbGV0IGFyZ3MgPSBjaGVjayhzdGFjay5wb3AoKSwgQ2hlY2tJbnN0YW5jZW9mKFZNQXJndW1lbnRzSW1wbCkpO1xuXG4gIGlmICh0YWJsZSA9PT0gbnVsbCkge1xuICAgIC8vIFRvIGJhbGFuY2UgdGhlIHBvcHtGcmFtZSxTY29wZX1cbiAgICB2bS5wdXNoRnJhbWUoKTtcbiAgICB2bS5wdXNoU2NvcGUoc2NvcGUgPz8gdm0uc2NvcGUoKSk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgaW52b2tpbmdTY29wZSA9IGV4cGVjdChzY29wZSwgJ0JVRzogZXhwZWN0ZWQgc2NvcGUnKTtcblxuICAvLyBJZiBuZWNlc3NhcnksIGNyZWF0ZSBhIGNoaWxkIHNjb3BlXG4gIHtcbiAgICBsZXQgbG9jYWxzID0gdGFibGUucGFyYW1ldGVycztcbiAgICBsZXQgbG9jYWxzQ291bnQgPSBsb2NhbHMubGVuZ3RoO1xuXG4gICAgaWYgKGxvY2Fsc0NvdW50ID4gMCkge1xuICAgICAgaW52b2tpbmdTY29wZSA9IGludm9raW5nU2NvcGUuY2hpbGQoKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbHNDb3VudDsgaSsrKSB7XG4gICAgICAgIGludm9raW5nU2NvcGUuYmluZFN5bWJvbChsb2NhbHMhW2ldLCBhcmdzLmF0KGkpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2bS5wdXNoRnJhbWUoKTtcbiAgdm0ucHVzaFNjb3BlKGludm9raW5nU2NvcGUpO1xuICB2bS5jYWxsKGhhbmRsZSEpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5KdW1wSWYsICh2bSwgeyBvcDE6IHRhcmdldCB9KSA9PiB7XG4gIGxldCByZWZlcmVuY2UgPSBjaGVjayh2bS5zdGFjay5wb3AoKSwgQ2hlY2tSZWZlcmVuY2UpO1xuICBsZXQgdmFsdWUgPSBCb29sZWFuKHZhbHVlRm9yUmVmKHJlZmVyZW5jZSkpO1xuXG4gIGlmIChpc0NvbnN0UmVmKHJlZmVyZW5jZSkpIHtcbiAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgIHZtLmdvdG8odGFyZ2V0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICB2bS5nb3RvKHRhcmdldCk7XG4gICAgfVxuXG4gICAgdm0udXBkYXRlV2l0aChuZXcgQXNzZXJ0KHJlZmVyZW5jZSkpO1xuICB9XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkp1bXBVbmxlc3MsICh2bSwgeyBvcDE6IHRhcmdldCB9KSA9PiB7XG4gIGxldCByZWZlcmVuY2UgPSBjaGVjayh2bS5zdGFjay5wb3AoKSwgQ2hlY2tSZWZlcmVuY2UpO1xuICBsZXQgdmFsdWUgPSBCb29sZWFuKHZhbHVlRm9yUmVmKHJlZmVyZW5jZSkpO1xuXG4gIGlmIChpc0NvbnN0UmVmKHJlZmVyZW5jZSkpIHtcbiAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICB2bS5nb3RvKHRhcmdldCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgIHZtLmdvdG8odGFyZ2V0KTtcbiAgICB9XG5cbiAgICB2bS51cGRhdGVXaXRoKG5ldyBBc3NlcnQocmVmZXJlbmNlKSk7XG4gIH1cbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuSnVtcEVxLCAodm0sIHsgb3AxOiB0YXJnZXQsIG9wMjogY29tcGFyaXNvbiB9KSA9PiB7XG4gIGxldCBvdGhlciA9IGNoZWNrKHZtLnN0YWNrLnBlZWsoKSwgQ2hlY2tOdW1iZXIpO1xuXG4gIGlmIChvdGhlciA9PT0gY29tcGFyaXNvbikge1xuICAgIHZtLmdvdG8odGFyZ2V0KTtcbiAgfVxufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5Bc3NlcnRTYW1lLCAodm0pID0+IHtcbiAgbGV0IHJlZmVyZW5jZSA9IGNoZWNrKHZtLnN0YWNrLnBlZWsoKSwgQ2hlY2tSZWZlcmVuY2UpO1xuXG4gIGlmIChpc0NvbnN0UmVmKHJlZmVyZW5jZSkgPT09IGZhbHNlKSB7XG4gICAgdm0udXBkYXRlV2l0aChuZXcgQXNzZXJ0KHJlZmVyZW5jZSkpO1xuICB9XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLlRvQm9vbGVhbiwgKHZtKSA9PiB7XG4gIGxldCB7IHN0YWNrIH0gPSB2bTtcbiAgbGV0IHZhbHVlUmVmID0gY2hlY2soc3RhY2sucG9wKCksIENoZWNrUmVmZXJlbmNlKTtcblxuICBzdGFjay5wdXNoKGNyZWF0ZUNvbXB1dGVSZWYoKCkgPT4gdG9Cb29sKHZhbHVlRm9yUmVmKHZhbHVlUmVmKSkpKTtcbn0pO1xuXG5leHBvcnQgY2xhc3MgQXNzZXJ0IGltcGxlbWVudHMgVXBkYXRpbmdPcGNvZGUge1xuICBwcml2YXRlIGxhc3Q6IHVua25vd247XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWY6IFJlZmVyZW5jZSkge1xuICAgIHRoaXMubGFzdCA9IHZhbHVlRm9yUmVmKHJlZik7XG4gIH1cblxuICBldmFsdWF0ZSh2bTogVXBkYXRpbmdWTSkge1xuICAgIGxldCB7IGxhc3QsIHJlZiB9ID0gdGhpcztcbiAgICBsZXQgY3VycmVudCA9IHZhbHVlRm9yUmVmKHJlZik7XG5cbiAgICBpZiAobGFzdCAhPT0gY3VycmVudCkge1xuICAgICAgdm0udGhyb3coKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFzc2VydEZpbHRlcjxULCBVPiBpbXBsZW1lbnRzIFVwZGF0aW5nT3Bjb2RlIHtcbiAgcHJpdmF0ZSBsYXN0OiBVO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVmOiBSZWZlcmVuY2U8VD4sIHByaXZhdGUgZmlsdGVyOiAoZnJvbTogVCkgPT4gVSkge1xuICAgIHRoaXMubGFzdCA9IGZpbHRlcih2YWx1ZUZvclJlZihyZWYpKTtcbiAgfVxuXG4gIGV2YWx1YXRlKHZtOiBVcGRhdGluZ1ZNKSB7XG4gICAgbGV0IHsgbGFzdCwgcmVmLCBmaWx0ZXIgfSA9IHRoaXM7XG4gICAgbGV0IGN1cnJlbnQgPSBmaWx0ZXIodmFsdWVGb3JSZWYocmVmKSk7XG5cbiAgICBpZiAobGFzdCAhPT0gY3VycmVudCkge1xuICAgICAgdm0udGhyb3coKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEp1bXBJZk5vdE1vZGlmaWVkT3Bjb2RlIGltcGxlbWVudHMgVXBkYXRpbmdPcGNvZGUge1xuICBwcml2YXRlIHRhZzogVGFnID0gQ09OU1RBTlRfVEFHO1xuICBwcml2YXRlIGxhc3RSZXZpc2lvbjogUmV2aXNpb24gPSBJTklUSUFMO1xuICBwcml2YXRlIHRhcmdldD86IG51bWJlcjtcblxuICBmaW5hbGl6ZSh0YWc6IFRhZywgdGFyZ2V0OiBudW1iZXIpIHtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLmRpZE1vZGlmeSh0YWcpO1xuICB9XG5cbiAgZXZhbHVhdGUodm06IFVwZGF0aW5nVk0pIHtcbiAgICBsZXQgeyB0YWcsIHRhcmdldCwgbGFzdFJldmlzaW9uIH0gPSB0aGlzO1xuXG4gICAgaWYgKCF2bS5hbHdheXNSZXZhbGlkYXRlICYmIHZhbGlkYXRlVGFnKHRhZywgbGFzdFJldmlzaW9uKSkge1xuICAgICAgY29uc3VtZVRhZyh0YWcpO1xuICAgICAgdm0uZ290byhleHBlY3QodGFyZ2V0LCAnVk0gQlVHOiBUYXJnZXQgbXVzdCBiZSBzZXQgYmVmb3JlIGF0dGVtcHRpbmcgdG8ganVtcCcpKTtcbiAgICB9XG4gIH1cblxuICBkaWRNb2RpZnkodGFnOiBUYWcpIHtcbiAgICB0aGlzLnRhZyA9IHRhZztcbiAgICB0aGlzLmxhc3RSZXZpc2lvbiA9IHZhbHVlRm9yVGFnKHRoaXMudGFnKTtcbiAgICBjb25zdW1lVGFnKHRhZyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEJlZ2luVHJhY2tGcmFtZU9wY29kZSBpbXBsZW1lbnRzIFVwZGF0aW5nT3Bjb2RlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBkZWJ1Z0xhYmVsPzogc3RyaW5nKSB7fVxuXG4gIGV2YWx1YXRlKCkge1xuICAgIGJlZ2luVHJhY2tGcmFtZSh0aGlzLmRlYnVnTGFiZWwpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBFbmRUcmFja0ZyYW1lT3Bjb2RlIGltcGxlbWVudHMgVXBkYXRpbmdPcGNvZGUge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHRhcmdldDogSnVtcElmTm90TW9kaWZpZWRPcGNvZGUpIHt9XG5cbiAgZXZhbHVhdGUoKSB7XG4gICAgbGV0IHRhZyA9IGVuZFRyYWNrRnJhbWUoKTtcbiAgICB0aGlzLnRhcmdldC5kaWRNb2RpZnkodGFnKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgUmVmZXJlbmNlLCB2YWx1ZUZvclJlZiwgaXNDb25zdFJlZiwgY3JlYXRlQ29tcHV0ZVJlZiB9IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQge1xuICBSZXZpc2lvbixcbiAgVGFnLFxuICB2YWx1ZUZvclRhZyxcbiAgdmFsaWRhdGVUYWcsXG4gIGNvbnN1bWVUYWcsXG4gIENVUlJFTlRfVEFHLFxufSBmcm9tICdAZ2xpbW1lci92YWxpZGF0b3InO1xuaW1wb3J0IHtcbiAgY2hlY2ssXG4gIENoZWNrU3RyaW5nLFxuICBDaGVja0VsZW1lbnQsXG4gIENoZWNrT3B0aW9uLFxuICBDaGVja05vZGUsXG4gIENoZWNrTWF5YmUsXG59IGZyb20gJ0BnbGltbWVyL2RlYnVnJztcbmltcG9ydCB7XG4gIE9wLFxuICBPcHRpb24sXG4gIE1vZGlmaWVyRGVmaW5pdGlvbixcbiAgTW9kaWZpZXJJbnN0YW5jZSxcbiAgT3duZXIsXG4gIENhcHR1cmVkUG9zaXRpb25hbEFyZ3VtZW50cyxcbiAgQ3VycmllZFR5cGUsXG4gIE1vZGlmaWVyRGVmaW5pdGlvblN0YXRlLFxuICBFbnZpcm9ubWVudCxcbiAgVXBkYXRpbmdWTSxcbiAgVXBkYXRpbmdPcGNvZGUsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgJHQwIH0gZnJvbSAnQGdsaW1tZXIvdm0nO1xuaW1wb3J0IHsgQVBQRU5EX09QQ09ERVMgfSBmcm9tICcuLi8uLi9vcGNvZGVzJztcbmltcG9ydCB7IEFzc2VydCB9IGZyb20gJy4vdm0nO1xuaW1wb3J0IHsgRHluYW1pY0F0dHJpYnV0ZSB9IGZyb20gJy4uLy4uL3ZtL2F0dHJpYnV0ZXMvZHluYW1pYyc7XG5pbXBvcnQgeyBDaGVja1JlZmVyZW5jZSwgQ2hlY2tBcmd1bWVudHMsIENoZWNrT3BlcmF0aW9ucyB9IGZyb20gJy4vLWRlYnVnLXN0cmlwJztcbmltcG9ydCB7IENPTlNUQU5UUyB9IGZyb20gJy4uLy4uL3N5bWJvbHMnO1xuaW1wb3J0IHsgYXNzaWduLCBkZWJ1Z1RvU3RyaW5nLCBleHBlY3QsIGlzT2JqZWN0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyBDdXJyaWVkVmFsdWUsIGlzQ3VycmllZFR5cGUsIHJlc29sdmVDdXJyaWVkVmFsdWUgfSBmcm9tICcuLi8uLi9jdXJyaWVkLXZhbHVlJztcbmltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7IGFzc29jaWF0ZURlc3Ryb3lhYmxlQ2hpbGQsIGRlc3Ryb3kgfSBmcm9tICdAZ2xpbW1lci9kZXN0cm95YWJsZSc7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5UZXh0LCAodm0sIHsgb3AxOiB0ZXh0IH0pID0+IHtcbiAgdm0uZWxlbWVudHMoKS5hcHBlbmRUZXh0KHZtW0NPTlNUQU5UU10uZ2V0VmFsdWUodGV4dCkpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5Db21tZW50LCAodm0sIHsgb3AxOiB0ZXh0IH0pID0+IHtcbiAgdm0uZWxlbWVudHMoKS5hcHBlbmRDb21tZW50KHZtW0NPTlNUQU5UU10uZ2V0VmFsdWUodGV4dCkpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5PcGVuRWxlbWVudCwgKHZtLCB7IG9wMTogdGFnIH0pID0+IHtcbiAgdm0uZWxlbWVudHMoKS5vcGVuRWxlbWVudCh2bVtDT05TVEFOVFNdLmdldFZhbHVlKHRhZykpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5PcGVuRHluYW1pY0VsZW1lbnQsICh2bSkgPT4ge1xuICBsZXQgdGFnTmFtZSA9IGNoZWNrKHZhbHVlRm9yUmVmKGNoZWNrKHZtLnN0YWNrLnBvcCgpLCBDaGVja1JlZmVyZW5jZSkpLCBDaGVja1N0cmluZyk7XG4gIHZtLmVsZW1lbnRzKCkub3BlbkVsZW1lbnQodGFnTmFtZSk7XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLlB1c2hSZW1vdGVFbGVtZW50LCAodm0pID0+IHtcbiAgbGV0IGVsZW1lbnRSZWYgPSBjaGVjayh2bS5zdGFjay5wb3AoKSwgQ2hlY2tSZWZlcmVuY2UpO1xuICBsZXQgaW5zZXJ0QmVmb3JlUmVmID0gY2hlY2sodm0uc3RhY2sucG9wKCksIENoZWNrUmVmZXJlbmNlKTtcbiAgbGV0IGd1aWRSZWYgPSBjaGVjayh2bS5zdGFjay5wb3AoKSwgQ2hlY2tSZWZlcmVuY2UpO1xuXG4gIGxldCBlbGVtZW50ID0gY2hlY2sodmFsdWVGb3JSZWYoZWxlbWVudFJlZiksIENoZWNrRWxlbWVudCk7XG4gIGxldCBpbnNlcnRCZWZvcmUgPSBjaGVjayh2YWx1ZUZvclJlZihpbnNlcnRCZWZvcmVSZWYpLCBDaGVja01heWJlKENoZWNrT3B0aW9uKENoZWNrTm9kZSkpKTtcbiAgbGV0IGd1aWQgPSB2YWx1ZUZvclJlZihndWlkUmVmKSBhcyBzdHJpbmc7XG5cbiAgaWYgKCFpc0NvbnN0UmVmKGVsZW1lbnRSZWYpKSB7XG4gICAgdm0udXBkYXRlV2l0aChuZXcgQXNzZXJ0KGVsZW1lbnRSZWYpKTtcbiAgfVxuXG4gIGlmIChpbnNlcnRCZWZvcmUgIT09IHVuZGVmaW5lZCAmJiAhaXNDb25zdFJlZihpbnNlcnRCZWZvcmVSZWYpKSB7XG4gICAgdm0udXBkYXRlV2l0aChuZXcgQXNzZXJ0KGluc2VydEJlZm9yZVJlZikpO1xuICB9XG5cbiAgbGV0IGJsb2NrID0gdm0uZWxlbWVudHMoKS5wdXNoUmVtb3RlRWxlbWVudChlbGVtZW50LCBndWlkLCBpbnNlcnRCZWZvcmUpO1xuICBpZiAoYmxvY2spIHZtLmFzc29jaWF0ZURlc3Ryb3lhYmxlKGJsb2NrKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuUG9wUmVtb3RlRWxlbWVudCwgKHZtKSA9PiB7XG4gIHZtLmVsZW1lbnRzKCkucG9wUmVtb3RlRWxlbWVudCgpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5GbHVzaEVsZW1lbnQsICh2bSkgPT4ge1xuICBsZXQgb3BlcmF0aW9ucyA9IGNoZWNrKHZtLmZldGNoVmFsdWUoJHQwKSwgQ2hlY2tPcGVyYXRpb25zKTtcbiAgbGV0IG1vZGlmaWVyczogT3B0aW9uPE1vZGlmaWVySW5zdGFuY2VbXT4gPSBudWxsO1xuXG4gIGlmIChvcGVyYXRpb25zKSB7XG4gICAgbW9kaWZpZXJzID0gb3BlcmF0aW9ucy5mbHVzaCh2bSk7XG4gICAgdm0ubG9hZFZhbHVlKCR0MCwgbnVsbCk7XG4gIH1cblxuICB2bS5lbGVtZW50cygpLmZsdXNoRWxlbWVudChtb2RpZmllcnMpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5DbG9zZUVsZW1lbnQsICh2bSkgPT4ge1xuICBsZXQgbW9kaWZpZXJzID0gdm0uZWxlbWVudHMoKS5jbG9zZUVsZW1lbnQoKTtcblxuICBpZiAobW9kaWZpZXJzKSB7XG4gICAgbW9kaWZpZXJzLmZvckVhY2goKG1vZGlmaWVyKSA9PiB7XG4gICAgICB2bS5lbnYuc2NoZWR1bGVJbnN0YWxsTW9kaWZpZXIobW9kaWZpZXIpO1xuICAgICAgbGV0IHsgbWFuYWdlciwgc3RhdGUgfSA9IG1vZGlmaWVyO1xuICAgICAgbGV0IGQgPSBtYW5hZ2VyLmdldERlc3Ryb3lhYmxlKHN0YXRlKTtcblxuICAgICAgaWYgKGQpIHtcbiAgICAgICAgdm0uYXNzb2NpYXRlRGVzdHJveWFibGUoZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuTW9kaWZpZXIsICh2bSwgeyBvcDE6IGhhbmRsZSB9KSA9PiB7XG4gIGlmICh2bS5lbnYuaXNJbnRlcmFjdGl2ZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgb3duZXIgPSB2bS5nZXRPd25lcigpO1xuICBsZXQgYXJncyA9IGNoZWNrKHZtLnN0YWNrLnBvcCgpLCBDaGVja0FyZ3VtZW50cyk7XG4gIGxldCBkZWZpbml0aW9uID0gdm1bQ09OU1RBTlRTXS5nZXRWYWx1ZTxNb2RpZmllckRlZmluaXRpb24+KGhhbmRsZSk7XG5cbiAgbGV0IHsgbWFuYWdlciB9ID0gZGVmaW5pdGlvbjtcblxuICBsZXQgeyBjb25zdHJ1Y3RpbmcgfSA9IHZtLmVsZW1lbnRzKCk7XG5cbiAgbGV0IHN0YXRlID0gbWFuYWdlci5jcmVhdGUoXG4gICAgb3duZXIsXG4gICAgZXhwZWN0KGNvbnN0cnVjdGluZywgJ0JVRzogRWxlbWVudE1vZGlmaWVyIGNvdWxkIG5vdCBmaW5kIHRoZSBlbGVtZW50IGl0IGFwcGxpZXMgdG8nKSxcbiAgICBkZWZpbml0aW9uLnN0YXRlLFxuICAgIGFyZ3MuY2FwdHVyZSgpXG4gICk7XG5cbiAgbGV0IGluc3RhbmNlOiBNb2RpZmllckluc3RhbmNlID0ge1xuICAgIG1hbmFnZXIsXG4gICAgc3RhdGUsXG4gICAgZGVmaW5pdGlvbixcbiAgfTtcblxuICBsZXQgb3BlcmF0aW9ucyA9IGV4cGVjdChcbiAgICBjaGVjayh2bS5mZXRjaFZhbHVlKCR0MCksIENoZWNrT3BlcmF0aW9ucyksXG4gICAgJ0JVRzogRWxlbWVudE1vZGlmaWVyIGNvdWxkIG5vdCBmaW5kIG9wZXJhdGlvbnMgdG8gYXBwZW5kIHRvJ1xuICApO1xuXG4gIG9wZXJhdGlvbnMuYWRkTW9kaWZpZXIoaW5zdGFuY2UpO1xuXG4gIGxldCB0YWcgPSBtYW5hZ2VyLmdldFRhZyhzdGF0ZSk7XG5cbiAgaWYgKHRhZyAhPT0gbnVsbCkge1xuICAgIGNvbnN1bWVUYWcodGFnKTtcbiAgICByZXR1cm4gdm0udXBkYXRlV2l0aChuZXcgVXBkYXRlTW9kaWZpZXJPcGNvZGUodGFnLCBpbnN0YW5jZSkpO1xuICB9XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkR5bmFtaWNNb2RpZmllciwgKHZtKSA9PiB7XG4gIGlmICh2bS5lbnYuaXNJbnRlcmFjdGl2ZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgeyBzdGFjaywgW0NPTlNUQU5UU106IGNvbnN0YW50cyB9ID0gdm07XG4gIGxldCByZWYgPSBjaGVjayhzdGFjay5wb3AoKSwgQ2hlY2tSZWZlcmVuY2UpO1xuICBsZXQgYXJncyA9IGNoZWNrKHN0YWNrLnBvcCgpLCBDaGVja0FyZ3VtZW50cykuY2FwdHVyZSgpO1xuICBsZXQgeyBjb25zdHJ1Y3RpbmcgfSA9IHZtLmVsZW1lbnRzKCk7XG4gIGxldCBpbml0aWFsT3duZXIgPSB2bS5nZXRPd25lcigpO1xuXG4gIGxldCBpbnN0YW5jZVJlZiA9IGNyZWF0ZUNvbXB1dGVSZWYoKCkgPT4ge1xuICAgIGxldCB2YWx1ZSA9IHZhbHVlRm9yUmVmKHJlZik7XG4gICAgbGV0IG93bmVyOiBPd25lcjtcblxuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGhvc3REZWZpbml0aW9uOiBDdXJyaWVkVmFsdWUgfCBNb2RpZmllckRlZmluaXRpb25TdGF0ZTtcblxuICAgIGlmIChpc0N1cnJpZWRUeXBlKHZhbHVlLCBDdXJyaWVkVHlwZS5Nb2RpZmllcikpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIGRlZmluaXRpb246IHJlc29sdmVkRGVmaW5pdGlvbixcbiAgICAgICAgb3duZXI6IGN1cnJpZWRPd25lcixcbiAgICAgICAgcG9zaXRpb25hbCxcbiAgICAgICAgbmFtZWQsXG4gICAgICB9ID0gcmVzb2x2ZUN1cnJpZWRWYWx1ZSh2YWx1ZSk7XG5cbiAgICAgIGhvc3REZWZpbml0aW9uID0gcmVzb2x2ZWREZWZpbml0aW9uO1xuICAgICAgb3duZXIgPSBjdXJyaWVkT3duZXI7XG5cbiAgICAgIGlmIChwb3NpdGlvbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXJncy5wb3NpdGlvbmFsID0gcG9zaXRpb25hbC5jb25jYXQoYXJncy5wb3NpdGlvbmFsKSBhcyBDYXB0dXJlZFBvc2l0aW9uYWxBcmd1bWVudHM7XG4gICAgICB9XG5cbiAgICAgIGlmIChuYW1lZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFyZ3MubmFtZWQgPSBhc3NpZ24oe30sIC4uLm5hbWVkLCBhcmdzLm5hbWVkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaG9zdERlZmluaXRpb24gPSB2YWx1ZTtcbiAgICAgIG93bmVyID0gaW5pdGlhbE93bmVyO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGUgPSBjb25zdGFudHMubW9kaWZpZXIoaG9zdERlZmluaXRpb24sIG51bGwsIHRydWUpO1xuXG4gICAgaWYgKERFQlVHICYmIGhhbmRsZSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRXhwZWN0ZWQgYSBkeW5hbWljIG1vZGlmaWVyIGRlZmluaXRpb24sIGJ1dCByZWNlaXZlZCBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gdGhhdCBkaWQgbm90IGhhdmUgYSBtb2RpZmllciBtYW5hZ2VyIGFzc29jaWF0ZWQgd2l0aCBpdC4gVGhlIGR5bmFtaWMgaW52b2NhdGlvbiB3YXMgXFxge3ske1xuICAgICAgICAgIHJlZi5kZWJ1Z0xhYmVsXG4gICAgICAgIH19fVxcYCwgYW5kIHRoZSBpbmNvcnJlY3QgZGVmaW5pdGlvbiBpcyB0aGUgdmFsdWUgYXQgdGhlIHBhdGggXFxgJHtcbiAgICAgICAgICByZWYuZGVidWdMYWJlbFxuICAgICAgICB9XFxgLCB3aGljaCB3YXM6ICR7ZGVidWdUb1N0cmluZyEoaG9zdERlZmluaXRpb24pfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IGRlZmluaXRpb24gPSBjb25zdGFudHMuZ2V0VmFsdWU8TW9kaWZpZXJEZWZpbml0aW9uPihcbiAgICAgIGV4cGVjdChoYW5kbGUsICdCVUc6IG1vZGlmaWVyIGhhbmRsZSBleHBlY3RlZCcpXG4gICAgKTtcblxuICAgIGxldCB7IG1hbmFnZXIgfSA9IGRlZmluaXRpb247XG5cbiAgICBsZXQgc3RhdGUgPSBtYW5hZ2VyLmNyZWF0ZShcbiAgICAgIG93bmVyLFxuICAgICAgZXhwZWN0KGNvbnN0cnVjdGluZywgJ0JVRzogRWxlbWVudE1vZGlmaWVyIGNvdWxkIG5vdCBmaW5kIHRoZSBlbGVtZW50IGl0IGFwcGxpZXMgdG8nKSxcbiAgICAgIGRlZmluaXRpb24uc3RhdGUsXG4gICAgICBhcmdzXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICBtYW5hZ2VyLFxuICAgICAgc3RhdGUsXG4gICAgICBkZWZpbml0aW9uLFxuICAgIH07XG4gIH0pO1xuXG4gIGxldCBpbnN0YW5jZSA9IHZhbHVlRm9yUmVmKGluc3RhbmNlUmVmKTtcbiAgbGV0IHRhZyA9IG51bGw7XG5cbiAgaWYgKGluc3RhbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICBsZXQgb3BlcmF0aW9ucyA9IGV4cGVjdChcbiAgICAgIGNoZWNrKHZtLmZldGNoVmFsdWUoJHQwKSwgQ2hlY2tPcGVyYXRpb25zKSxcbiAgICAgICdCVUc6IEVsZW1lbnRNb2RpZmllciBjb3VsZCBub3QgZmluZCBvcGVyYXRpb25zIHRvIGFwcGVuZCB0bydcbiAgICApO1xuXG4gICAgb3BlcmF0aW9ucy5hZGRNb2RpZmllcihpbnN0YW5jZSk7XG5cbiAgICB0YWcgPSBpbnN0YW5jZS5tYW5hZ2VyLmdldFRhZyhpbnN0YW5jZS5zdGF0ZSk7XG5cbiAgICBpZiAodGFnICE9PSBudWxsKSB7XG4gICAgICBjb25zdW1lVGFnKHRhZyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFpc0NvbnN0UmVmKHJlZikgfHwgdGFnKSB7XG4gICAgcmV0dXJuIHZtLnVwZGF0ZVdpdGgobmV3IFVwZGF0ZUR5bmFtaWNNb2RpZmllck9wY29kZSh0YWcsIGluc3RhbmNlLCBpbnN0YW5jZVJlZikpO1xuICB9XG59KTtcblxuZXhwb3J0IGNsYXNzIFVwZGF0ZU1vZGlmaWVyT3Bjb2RlIGltcGxlbWVudHMgVXBkYXRpbmdPcGNvZGUge1xuICBwcml2YXRlIGxhc3RVcGRhdGVkOiBSZXZpc2lvbjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHRhZzogVGFnLCBwcml2YXRlIG1vZGlmaWVyOiBNb2RpZmllckluc3RhbmNlKSB7XG4gICAgdGhpcy5sYXN0VXBkYXRlZCA9IHZhbHVlRm9yVGFnKHRhZyk7XG4gIH1cblxuICBldmFsdWF0ZSh2bTogVXBkYXRpbmdWTSkge1xuICAgIGxldCB7IG1vZGlmaWVyLCB0YWcsIGxhc3RVcGRhdGVkIH0gPSB0aGlzO1xuXG4gICAgY29uc3VtZVRhZyh0YWcpO1xuXG4gICAgaWYgKCF2YWxpZGF0ZVRhZyh0YWcsIGxhc3RVcGRhdGVkKSkge1xuICAgICAgdm0uZW52LnNjaGVkdWxlVXBkYXRlTW9kaWZpZXIobW9kaWZpZXIpO1xuICAgICAgdGhpcy5sYXN0VXBkYXRlZCA9IHZhbHVlRm9yVGFnKHRhZyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBVcGRhdGVEeW5hbWljTW9kaWZpZXJPcGNvZGUgaW1wbGVtZW50cyBVcGRhdGluZ09wY29kZSB7XG4gIHByaXZhdGUgbGFzdFVwZGF0ZWQ6IFJldmlzaW9uO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgdGFnOiBUYWcgfCBudWxsLFxuICAgIHByaXZhdGUgaW5zdGFuY2U6IE1vZGlmaWVySW5zdGFuY2UgfCB1bmRlZmluZWQsXG4gICAgcHJpdmF0ZSBpbnN0YW5jZVJlZjogUmVmZXJlbmNlPE1vZGlmaWVySW5zdGFuY2UgfCB1bmRlZmluZWQ+XG4gICkge1xuICAgIHRoaXMubGFzdFVwZGF0ZWQgPSB2YWx1ZUZvclRhZyh0YWcgPz8gQ1VSUkVOVF9UQUcpO1xuICB9XG5cbiAgZXZhbHVhdGUodm06IFVwZGF0aW5nVk0pIHtcbiAgICBsZXQgeyB0YWcsIGxhc3RVcGRhdGVkLCBpbnN0YW5jZSwgaW5zdGFuY2VSZWYgfSA9IHRoaXM7XG5cbiAgICBsZXQgbmV3SW5zdGFuY2UgPSB2YWx1ZUZvclJlZihpbnN0YW5jZVJlZik7XG5cbiAgICBpZiAobmV3SW5zdGFuY2UgIT09IGluc3RhbmNlKSB7XG4gICAgICBpZiAoaW5zdGFuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgZGVzdHJveWFibGUgPSBpbnN0YW5jZS5tYW5hZ2VyLmdldERlc3Ryb3lhYmxlKGluc3RhbmNlLnN0YXRlKTtcblxuICAgICAgICBpZiAoZGVzdHJveWFibGUgIT09IG51bGwpIHtcbiAgICAgICAgICBkZXN0cm95KGRlc3Ryb3lhYmxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobmV3SW5zdGFuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgeyBtYW5hZ2VyLCBzdGF0ZSB9ID0gbmV3SW5zdGFuY2U7XG4gICAgICAgIGxldCBkZXN0cm95YWJsZSA9IG1hbmFnZXIuZ2V0RGVzdHJveWFibGUoc3RhdGUpO1xuXG4gICAgICAgIGlmIChkZXN0cm95YWJsZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGFzc29jaWF0ZURlc3Ryb3lhYmxlQ2hpbGQodGhpcywgZGVzdHJveWFibGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFnID0gbWFuYWdlci5nZXRUYWcoc3RhdGUpO1xuXG4gICAgICAgIGlmICh0YWcgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLmxhc3RVcGRhdGVkID0gdmFsdWVGb3JUYWcodGFnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgICB2bS5lbnYuc2NoZWR1bGVJbnN0YWxsTW9kaWZpZXIobmV3SW5zdGFuY2UhKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ld0luc3RhbmNlO1xuICAgIH0gZWxzZSBpZiAodGFnICE9PSBudWxsICYmICF2YWxpZGF0ZVRhZyh0YWcsIGxhc3RVcGRhdGVkKSkge1xuICAgICAgdm0uZW52LnNjaGVkdWxlVXBkYXRlTW9kaWZpZXIoaW5zdGFuY2UhKTtcbiAgICAgIHRoaXMubGFzdFVwZGF0ZWQgPSB2YWx1ZUZvclRhZyh0YWcpO1xuICAgIH1cblxuICAgIGlmICh0YWcgIT09IG51bGwpIHtcbiAgICAgIGNvbnN1bWVUYWcodGFnKTtcbiAgICB9XG4gIH1cbn1cblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLlN0YXRpY0F0dHIsICh2bSwgeyBvcDE6IF9uYW1lLCBvcDI6IF92YWx1ZSwgb3AzOiBfbmFtZXNwYWNlIH0pID0+IHtcbiAgbGV0IG5hbWUgPSB2bVtDT05TVEFOVFNdLmdldFZhbHVlPHN0cmluZz4oX25hbWUpO1xuICBsZXQgdmFsdWUgPSB2bVtDT05TVEFOVFNdLmdldFZhbHVlPHN0cmluZz4oX3ZhbHVlKTtcbiAgbGV0IG5hbWVzcGFjZSA9IF9uYW1lc3BhY2UgPyB2bVtDT05TVEFOVFNdLmdldFZhbHVlPHN0cmluZz4oX25hbWVzcGFjZSkgOiBudWxsO1xuXG4gIHZtLmVsZW1lbnRzKCkuc2V0U3RhdGljQXR0cmlidXRlKG5hbWUsIHZhbHVlLCBuYW1lc3BhY2UpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5EeW5hbWljQXR0ciwgKHZtLCB7IG9wMTogX25hbWUsIG9wMjogX3RydXN0aW5nLCBvcDM6IF9uYW1lc3BhY2UgfSkgPT4ge1xuICBsZXQgbmFtZSA9IHZtW0NPTlNUQU5UU10uZ2V0VmFsdWU8c3RyaW5nPihfbmFtZSk7XG4gIGxldCB0cnVzdGluZyA9IHZtW0NPTlNUQU5UU10uZ2V0VmFsdWU8Ym9vbGVhbj4oX3RydXN0aW5nKTtcbiAgbGV0IHJlZmVyZW5jZSA9IGNoZWNrKHZtLnN0YWNrLnBvcCgpLCBDaGVja1JlZmVyZW5jZSk7XG4gIGxldCB2YWx1ZSA9IHZhbHVlRm9yUmVmKHJlZmVyZW5jZSk7XG4gIGxldCBuYW1lc3BhY2UgPSBfbmFtZXNwYWNlID8gdm1bQ09OU1RBTlRTXS5nZXRWYWx1ZTxzdHJpbmc+KF9uYW1lc3BhY2UpIDogbnVsbDtcblxuICBsZXQgYXR0cmlidXRlID0gdm0uZWxlbWVudHMoKS5zZXREeW5hbWljQXR0cmlidXRlKG5hbWUsIHZhbHVlLCB0cnVzdGluZywgbmFtZXNwYWNlKTtcblxuICBpZiAoIWlzQ29uc3RSZWYocmVmZXJlbmNlKSkge1xuICAgIHZtLnVwZGF0ZVdpdGgobmV3IFVwZGF0ZUR5bmFtaWNBdHRyaWJ1dGVPcGNvZGUocmVmZXJlbmNlLCBhdHRyaWJ1dGUsIHZtLmVudikpO1xuICB9XG59KTtcblxuZXhwb3J0IGNsYXNzIFVwZGF0ZUR5bmFtaWNBdHRyaWJ1dGVPcGNvZGUgaW1wbGVtZW50cyBVcGRhdGluZ09wY29kZSB7XG4gIHByaXZhdGUgdXBkYXRlUmVmOiBSZWZlcmVuY2U7XG5cbiAgY29uc3RydWN0b3IocmVmZXJlbmNlOiBSZWZlcmVuY2U8dW5rbm93bj4sIGF0dHJpYnV0ZTogRHluYW1pY0F0dHJpYnV0ZSwgZW52OiBFbnZpcm9ubWVudCkge1xuICAgIGxldCBpbml0aWFsaXplZCA9IGZhbHNlO1xuXG4gICAgdGhpcy51cGRhdGVSZWYgPSBjcmVhdGVDb21wdXRlUmVmKCgpID0+IHtcbiAgICAgIGxldCB2YWx1ZSA9IHZhbHVlRm9yUmVmKHJlZmVyZW5jZSk7XG5cbiAgICAgIGlmIChpbml0aWFsaXplZCA9PT0gdHJ1ZSkge1xuICAgICAgICBhdHRyaWJ1dGUudXBkYXRlKHZhbHVlLCBlbnYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFsdWVGb3JSZWYodGhpcy51cGRhdGVSZWYpO1xuICB9XG5cbiAgZXZhbHVhdGUoKSB7XG4gICAgdmFsdWVGb3JSZWYodGhpcy51cGRhdGVSZWYpO1xuICB9XG59XG4iLCJpbXBvcnQge1xuICBjaGVjayxcbiAgQ2hlY2tGdW5jdGlvbixcbiAgQ2hlY2tIYW5kbGUsXG4gIENoZWNrSW5zdGFuY2VvZixcbiAgQ2hlY2tJbnRlcmZhY2UsXG4gIENoZWNrUHJvZ3JhbVN5bWJvbFRhYmxlLFxuICBDaGVja1N0cmluZyxcbiAgQ2hlY2tPcixcbn0gZnJvbSAnQGdsaW1tZXIvZGVidWcnO1xuaW1wb3J0IHsgREVCVUcgfSBmcm9tICdAZ2xpbW1lci9lbnYnO1xuaW1wb3J0IHtcbiAgQm91bmRzLFxuICBDb21wb25lbnREZWZpbml0aW9uLFxuICBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdHksXG4gIENvbXBvbmVudERlZmluaXRpb25TdGF0ZSxcbiAgQ29tcG9uZW50SW5zdGFuY2VTdGF0ZSxcbiAgSW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyLFxuICBEaWN0LFxuICBEeW5hbWljU2NvcGUsXG4gIEVsZW1lbnRPcGVyYXRpb25zLFxuICBPcCxcbiAgT3B0aW9uLFxuICBQcm9ncmFtU3ltYm9sVGFibGUsXG4gIFJlY2FzdCxcbiAgU2NvcGVTbG90LFxuICBWTUFyZ3VtZW50cyxcbiAgV2l0aER5bmFtaWNUYWdOYW1lLFxuICBXaXRoRWxlbWVudEhvb2ssXG4gIFdpdGhVcGRhdGVIb29rLFxuICBDYXB0dXJlZEFyZ3VtZW50cyxcbiAgQ29tcGlsYWJsZVByb2dyYW0sXG4gIENvbXBvbmVudEluc3RhbmNlLFxuICBNb2RpZmllckluc3RhbmNlLFxuICBDb21wb25lbnRJbnN0YW5jZVdpdGhDcmVhdGUsXG4gIE93bmVyLFxuICBDdXJyaWVkVHlwZSxcbiAgVXBkYXRpbmdPcGNvZGUsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgaXNDb25zdFJlZiwgUmVmZXJlbmNlLCB2YWx1ZUZvclJlZiB9IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQge1xuICBhc3NlcnQsXG4gIGFzc2lnbixcbiAgZGVidWdUb1N0cmluZyxcbiAgZGljdCxcbiAgRU1QVFlfU1RSSU5HX0FSUkFZLFxuICBleHBlY3QsXG4gIHVud3JhcFRlbXBsYXRlLFxufSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7ICR0MCwgJHQxIH0gZnJvbSAnQGdsaW1tZXIvdm0nO1xuaW1wb3J0IHsgcmVnaXN0ZXJEZXN0cnVjdG9yIH0gZnJvbSAnQGdsaW1tZXIvZGVzdHJveWFibGUnO1xuaW1wb3J0IHsgbWFuYWdlckhhc0NhcGFiaWxpdHkgfSBmcm9tICdAZ2xpbW1lci9tYW5hZ2VyJztcbmltcG9ydCB7IHJlc29sdmVDb21wb25lbnQgfSBmcm9tICcuLi8uLi9jb21wb25lbnQvcmVzb2x2ZSc7XG5pbXBvcnQgeyBoYXNDdXN0b21EZWJ1Z1JlbmRlclRyZWVMaWZlY3ljbGUgfSBmcm9tICcuLi8uLi9jb21wb25lbnQvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBBUFBFTkRfT1BDT0RFUyB9IGZyb20gJy4uLy4uL29wY29kZXMnO1xuaW1wb3J0IGNyZWF0ZUNsYXNzTGlzdFJlZiBmcm9tICcuLi8uLi9yZWZlcmVuY2VzL2NsYXNzLWxpc3QnO1xuaW1wb3J0IHsgQVJHUywgQ09OU1RBTlRTIH0gZnJvbSAnLi4vLi4vc3ltYm9scyc7XG5pbXBvcnQgeyBVcGRhdGluZ1ZNIH0gZnJvbSAnLi4vLi4vdm0nO1xuaW1wb3J0IHsgSW50ZXJuYWxWTSB9IGZyb20gJy4uLy4uL3ZtL2FwcGVuZCc7XG5pbXBvcnQgeyBCbG9ja0FyZ3VtZW50c0ltcGwsIEVNUFRZX0FSR1MsIFZNQXJndW1lbnRzSW1wbCB9IGZyb20gJy4uLy4uL3ZtL2FyZ3VtZW50cyc7XG5pbXBvcnQge1xuICBDaGVja0FyZ3VtZW50cyxcbiAgQ2hlY2tDb21wb25lbnREZWZpbml0aW9uLFxuICBDaGVja0NvbXBvbmVudEluc3RhbmNlLFxuICBDaGVja0ZpbmlzaGVkQ29tcG9uZW50SW5zdGFuY2UsXG4gIENoZWNrSW52b2NhdGlvbixcbiAgQ2hlY2tSZWZlcmVuY2UsXG4gIENoZWNrQ3VycmllZENvbXBvbmVudERlZmluaXRpb24sXG59IGZyb20gJy4vLWRlYnVnLXN0cmlwJztcbmltcG9ydCB7IFVwZGF0ZUR5bmFtaWNBdHRyaWJ1dGVPcGNvZGUgfSBmcm9tICcuL2RvbSc7XG5pbXBvcnQge1xuICBDdXJyaWVkVmFsdWUsXG4gIGlzQ3VycmllZFR5cGUsXG4gIGlzQ3VycmllZFZhbHVlLFxuICByZXNvbHZlQ3VycmllZFZhbHVlLFxufSBmcm9tICcuLi8uLi9jdXJyaWVkLXZhbHVlJztcblxuLyoqXG4gKiBUaGUgVk0gY3JlYXRlcyBhIG5ldyBDb21wb25lbnRJbnN0YW5jZSBkYXRhIHN0cnVjdHVyZSBmb3IgZXZlcnkgY29tcG9uZW50XG4gKiBpbnZvY2F0aW9uIGl0IGVuY291bnRlcnMuXG4gKlxuICogU2ltaWxhciB0byBob3cgYSBDb21wb25lbnREZWZpbml0aW9uIGNvbnRhaW5zIHN0YXRlIGFib3V0IGFsbCBjb21wb25lbnRzIG9mIGFcbiAqIHBhcnRpY3VsYXIgdHlwZSwgYSBDb21wb25lbnRJbnN0YW5jZSBjb250YWlucyBzdGF0ZSBzcGVjaWZpYyB0byBhIHBhcnRpY3VsYXJcbiAqIGluc3RhbmNlIG9mIGEgY29tcG9uZW50IHR5cGUuIEl0IGFsc28gY29udGFpbnMgYSBwb2ludGVyIGJhY2sgdG8gaXRzXG4gKiBjb21wb25lbnQgdHlwZSdzIENvbXBvbmVudERlZmluaXRpb24uXG4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBJbml0aWFsQ29tcG9uZW50SW5zdGFuY2Uge1xuICBkZWZpbml0aW9uOiBDb21wb25lbnREZWZpbml0aW9uO1xuICBtYW5hZ2VyOiBPcHRpb248SW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyPjtcbiAgY2FwYWJpbGl0aWVzOiBPcHRpb248SW50ZXJuYWxDb21wb25lbnRDYXBhYmlsaXR5PjtcbiAgc3RhdGU6IG51bGw7XG4gIGhhbmRsZTogT3B0aW9uPG51bWJlcj47XG4gIHRhYmxlOiBPcHRpb248UHJvZ3JhbVN5bWJvbFRhYmxlPjtcbiAgbG9va3VwOiBPcHRpb248RGljdDxTY29wZVNsb3Q+Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQb3B1bGF0ZWRDb21wb25lbnRJbnN0YW5jZSB7XG4gIGRlZmluaXRpb246IENvbXBvbmVudERlZmluaXRpb247XG4gIG1hbmFnZXI6IEludGVybmFsQ29tcG9uZW50TWFuYWdlcjtcbiAgY2FwYWJpbGl0aWVzOiBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdHk7XG4gIHN0YXRlOiBudWxsO1xuICBoYW5kbGU6IG51bWJlcjtcbiAgdGFibGU6IE9wdGlvbjxQcm9ncmFtU3ltYm9sVGFibGU+O1xuICBsb29rdXA6IE9wdGlvbjxEaWN0PFNjb3BlU2xvdD4+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhcnRpYWxDb21wb25lbnREZWZpbml0aW9uIHtcbiAgc3RhdGU6IE9wdGlvbjxDb21wb25lbnREZWZpbml0aW9uU3RhdGU+O1xuICBtYW5hZ2VyOiBJbnRlcm5hbENvbXBvbmVudE1hbmFnZXI7XG59XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5QdXNoQ29tcG9uZW50RGVmaW5pdGlvbiwgKHZtLCB7IG9wMTogaGFuZGxlIH0pID0+IHtcbiAgbGV0IGRlZmluaXRpb24gPSB2bVtDT05TVEFOVFNdLmdldFZhbHVlPENvbXBvbmVudERlZmluaXRpb24+KGhhbmRsZSk7XG4gIGFzc2VydCghIWRlZmluaXRpb24sIGBNaXNzaW5nIGNvbXBvbmVudCBmb3IgJHtoYW5kbGV9YCk7XG5cbiAgbGV0IHsgbWFuYWdlciwgY2FwYWJpbGl0aWVzIH0gPSBkZWZpbml0aW9uO1xuXG4gIGxldCBpbnN0YW5jZTogSW5pdGlhbENvbXBvbmVudEluc3RhbmNlID0ge1xuICAgIGRlZmluaXRpb24sXG4gICAgbWFuYWdlcixcbiAgICBjYXBhYmlsaXRpZXMsXG4gICAgc3RhdGU6IG51bGwsXG4gICAgaGFuZGxlOiBudWxsLFxuICAgIHRhYmxlOiBudWxsLFxuICAgIGxvb2t1cDogbnVsbCxcbiAgfTtcblxuICB2bS5zdGFjay5wdXNoKGluc3RhbmNlKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuUmVzb2x2ZUR5bmFtaWNDb21wb25lbnQsICh2bSwgeyBvcDE6IF9pc1N0cmljdCB9KSA9PiB7XG4gIGxldCBzdGFjayA9IHZtLnN0YWNrO1xuICBsZXQgY29tcG9uZW50ID0gY2hlY2soXG4gICAgdmFsdWVGb3JSZWYoY2hlY2soc3RhY2sucG9wKCksIENoZWNrUmVmZXJlbmNlKSksXG4gICAgQ2hlY2tPcihDaGVja1N0cmluZywgQ2hlY2tDdXJyaWVkQ29tcG9uZW50RGVmaW5pdGlvbilcbiAgKTtcbiAgbGV0IGNvbnN0YW50cyA9IHZtW0NPTlNUQU5UU107XG4gIGxldCBvd25lciA9IHZtLmdldE93bmVyKCk7XG4gIGxldCBpc1N0cmljdCA9IGNvbnN0YW50cy5nZXRWYWx1ZTxib29sZWFuPihfaXNTdHJpY3QpO1xuXG4gIHZtLmxvYWRWYWx1ZSgkdDEsIG51bGwpOyAvLyBDbGVhciB0aGUgdGVtcCByZWdpc3RlclxuXG4gIGxldCBkZWZpbml0aW9uOiBDb21wb25lbnREZWZpbml0aW9uIHwgQ3VycmllZFZhbHVlO1xuXG4gIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnc3RyaW5nJykge1xuICAgIGlmIChERUJVRyAmJiBpc1N0cmljdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQXR0ZW1wdGVkIHRvIHJlc29sdmUgYSBkeW5hbWljIGNvbXBvbmVudCB3aXRoIGEgc3RyaW5nIGRlZmluaXRpb24sIFxcYCR7Y29tcG9uZW50fVxcYCBpbiBhIHN0cmljdCBtb2RlIHRlbXBsYXRlLiBJbiBzdHJpY3QgbW9kZSwgdXNpbmcgc3RyaW5ncyB0byByZXNvbHZlIGNvbXBvbmVudCBkZWZpbml0aW9ucyBpcyBwcm9oaWJpdGVkLiBZb3UgY2FuIGluc3RlYWQgaW1wb3J0IHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbiBhbmQgdXNlIGl0IGRpcmVjdGx5LmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IHJlc29sdmVkRGVmaW5pdGlvbiA9IHJlc29sdmVDb21wb25lbnQodm0ucnVudGltZS5yZXNvbHZlciwgY29uc3RhbnRzLCBjb21wb25lbnQsIG93bmVyKTtcblxuICAgIGRlZmluaXRpb24gPSBleHBlY3QocmVzb2x2ZWREZWZpbml0aW9uLCBgQ291bGQgbm90IGZpbmQgYSBjb21wb25lbnQgbmFtZWQgXCIke2NvbXBvbmVudH1cImApO1xuICB9IGVsc2UgaWYgKGlzQ3VycmllZFZhbHVlKGNvbXBvbmVudCkpIHtcbiAgICBkZWZpbml0aW9uID0gY29tcG9uZW50O1xuICB9IGVsc2Uge1xuICAgIGRlZmluaXRpb24gPSBjb25zdGFudHMuY29tcG9uZW50KGNvbXBvbmVudCwgb3duZXIpO1xuICB9XG5cbiAgc3RhY2sucHVzaChkZWZpbml0aW9uKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuUmVzb2x2ZUN1cnJpZWRDb21wb25lbnQsICh2bSkgPT4ge1xuICBsZXQgc3RhY2sgPSB2bS5zdGFjaztcbiAgbGV0IHJlZiA9IGNoZWNrKHN0YWNrLnBvcCgpLCBDaGVja1JlZmVyZW5jZSk7XG4gIGxldCB2YWx1ZSA9IHZhbHVlRm9yUmVmKHJlZik7XG4gIGxldCBjb25zdGFudHMgPSB2bVtDT05TVEFOVFNdO1xuXG4gIGxldCBkZWZpbml0aW9uOiBDdXJyaWVkVmFsdWUgfCBDb21wb25lbnREZWZpbml0aW9uIHwgbnVsbDtcblxuICBpZiAoREVCVUcgJiYgISh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBFeHBlY3RlZCBhIGNvbXBvbmVudCBkZWZpbml0aW9uLCBidXQgcmVjZWl2ZWQgJHt2YWx1ZX0uIFlvdSBtYXkgaGF2ZSBhY2NpZGVudGFsbHkgZG9uZSA8JHtyZWYuZGVidWdMYWJlbH0+LCB3aGVyZSBcIiR7cmVmLmRlYnVnTGFiZWx9XCIgd2FzIGEgc3RyaW5nIGluc3RlYWQgb2YgYSBjdXJyaWVkIGNvbXBvbmVudCBkZWZpbml0aW9uLiBZb3UgbXVzdCBlaXRoZXIgdXNlIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbiBkaXJlY3RseSwgb3IgdXNlIHRoZSB7e2NvbXBvbmVudH19IGhlbHBlciB0byBjcmVhdGUgYSBjdXJyaWVkIGNvbXBvbmVudCBkZWZpbml0aW9uIHdoZW4gaW52b2tpbmcgZHluYW1pY2FsbHkuYFxuICAgICk7XG4gIH1cblxuICBpZiAoaXNDdXJyaWVkVmFsdWUodmFsdWUpKSB7XG4gICAgZGVmaW5pdGlvbiA9IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGRlZmluaXRpb24gPSBjb25zdGFudHMuY29tcG9uZW50KHZhbHVlIGFzIG9iamVjdCwgdm0uZ2V0T3duZXIoKSwgdHJ1ZSk7XG5cbiAgICBpZiAoREVCVUcgJiYgZGVmaW5pdGlvbiA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRXhwZWN0ZWQgYSBkeW5hbWljIGNvbXBvbmVudCBkZWZpbml0aW9uLCBidXQgcmVjZWl2ZWQgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHRoYXQgZGlkIG5vdCBoYXZlIGEgY29tcG9uZW50IG1hbmFnZXIgYXNzb2NpYXRlZCB3aXRoIGl0LiBUaGUgZHluYW1pYyBpbnZvY2F0aW9uIHdhcyBcXGA8JHtcbiAgICAgICAgICByZWYuZGVidWdMYWJlbFxuICAgICAgICB9PlxcYCBvciBcXGB7eyR7XG4gICAgICAgICAgcmVmLmRlYnVnTGFiZWxcbiAgICAgICAgfX19XFxgLCBhbmQgdGhlIGluY29ycmVjdCBkZWZpbml0aW9uIGlzIHRoZSB2YWx1ZSBhdCB0aGUgcGF0aCBcXGAke1xuICAgICAgICAgIHJlZi5kZWJ1Z0xhYmVsXG4gICAgICAgIH1cXGAsIHdoaWNoIHdhczogJHtkZWJ1Z1RvU3RyaW5nISh2YWx1ZSl9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBzdGFjay5wdXNoKGRlZmluaXRpb24pO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5QdXNoRHluYW1pY0NvbXBvbmVudEluc3RhbmNlLCAodm0pID0+IHtcbiAgbGV0IHsgc3RhY2sgfSA9IHZtO1xuICBsZXQgZGVmaW5pdGlvbiA9IHN0YWNrLnBvcDxDb21wb25lbnREZWZpbml0aW9uPigpO1xuXG4gIGxldCBjYXBhYmlsaXRpZXMsIG1hbmFnZXI7XG5cbiAgaWYgKGlzQ3VycmllZFZhbHVlKGRlZmluaXRpb24pKSB7XG4gICAgbWFuYWdlciA9IGNhcGFiaWxpdGllcyA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgbWFuYWdlciA9IGRlZmluaXRpb24ubWFuYWdlcjtcbiAgICBjYXBhYmlsaXRpZXMgPSBkZWZpbml0aW9uLmNhcGFiaWxpdGllcztcbiAgfVxuXG4gIHN0YWNrLnB1c2goeyBkZWZpbml0aW9uLCBjYXBhYmlsaXRpZXMsIG1hbmFnZXIsIHN0YXRlOiBudWxsLCBoYW5kbGU6IG51bGwsIHRhYmxlOiBudWxsIH0pO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5QdXNoQXJncywgKHZtLCB7IG9wMTogX25hbWVzLCBvcDI6IF9ibG9ja05hbWVzLCBvcDM6IGZsYWdzIH0pID0+IHtcbiAgbGV0IHN0YWNrID0gdm0uc3RhY2s7XG4gIGxldCBuYW1lcyA9IHZtW0NPTlNUQU5UU10uZ2V0QXJyYXk8c3RyaW5nPihfbmFtZXMpO1xuXG4gIGxldCBwb3NpdGlvbmFsQ291bnQgPSBmbGFncyA+PiA0O1xuICBsZXQgYXROYW1lcyA9IGZsYWdzICYgMGIxMDAwO1xuICBsZXQgYmxvY2tOYW1lcyA9XG4gICAgZmxhZ3MgJiAwYjAxMTEgPyB2bVtDT05TVEFOVFNdLmdldEFycmF5PHN0cmluZz4oX2Jsb2NrTmFtZXMpIDogRU1QVFlfU1RSSU5HX0FSUkFZO1xuXG4gIHZtW0FSR1NdLnNldHVwKHN0YWNrLCBuYW1lcywgYmxvY2tOYW1lcywgcG9zaXRpb25hbENvdW50LCAhIWF0TmFtZXMpO1xuICBzdGFjay5wdXNoKHZtW0FSR1NdKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuUHVzaEVtcHR5QXJncywgKHZtKSA9PiB7XG4gIGxldCB7IHN0YWNrIH0gPSB2bTtcblxuICBzdGFjay5wdXNoKHZtW0FSR1NdLmVtcHR5KHN0YWNrKSk7XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkNhcHR1cmVBcmdzLCAodm0pID0+IHtcbiAgbGV0IHN0YWNrID0gdm0uc3RhY2s7XG5cbiAgbGV0IGFyZ3MgPSBjaGVjayhzdGFjay5wb3AoKSwgQ2hlY2tJbnN0YW5jZW9mKFZNQXJndW1lbnRzSW1wbCkpO1xuICBsZXQgY2FwdHVyZWRBcmdzID0gYXJncy5jYXB0dXJlKCk7XG4gIHN0YWNrLnB1c2goY2FwdHVyZWRBcmdzKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuUHJlcGFyZUFyZ3MsICh2bSwgeyBvcDE6IF9zdGF0ZSB9KSA9PiB7XG4gIGxldCBzdGFjayA9IHZtLnN0YWNrO1xuICBsZXQgaW5zdGFuY2UgPSB2bS5mZXRjaFZhbHVlPENvbXBvbmVudEluc3RhbmNlPihfc3RhdGUpO1xuICBsZXQgYXJncyA9IGNoZWNrKHN0YWNrLnBvcCgpLCBDaGVja0luc3RhbmNlb2YoVk1Bcmd1bWVudHNJbXBsKSk7XG5cbiAgbGV0IHsgZGVmaW5pdGlvbiB9ID0gaW5zdGFuY2U7XG5cbiAgaWYgKGlzQ3VycmllZFR5cGUoZGVmaW5pdGlvbiwgQ3VycmllZFR5cGUuQ29tcG9uZW50KSkge1xuICAgIGFzc2VydChcbiAgICAgICFkZWZpbml0aW9uLm1hbmFnZXIsXG4gICAgICBcIklmIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbiB3YXMgY3VycmllZCwgd2UgZG9uJ3QgeWV0IGhhdmUgYSBtYW5hZ2VyXCJcbiAgICApO1xuXG4gICAgbGV0IGNvbnN0YW50cyA9IHZtW0NPTlNUQU5UU107XG5cbiAgICBsZXQge1xuICAgICAgZGVmaW5pdGlvbjogcmVzb2x2ZWREZWZpbml0aW9uLFxuICAgICAgb3duZXIsXG4gICAgICByZXNvbHZlZCxcbiAgICAgIHBvc2l0aW9uYWwsXG4gICAgICBuYW1lZCxcbiAgICB9ID0gcmVzb2x2ZUN1cnJpZWRWYWx1ZShkZWZpbml0aW9uKTtcblxuICAgIGlmIChyZXNvbHZlZCA9PT0gdHJ1ZSkge1xuICAgICAgZGVmaW5pdGlvbiA9IHJlc29sdmVkRGVmaW5pdGlvbiBhcyBDb21wb25lbnREZWZpbml0aW9uO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlc29sdmVkRGVmaW5pdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGxldCByZXNvbHZlZFZhbHVlID0gdm0ucnVudGltZS5yZXNvbHZlci5sb29rdXBDb21wb25lbnQocmVzb2x2ZWREZWZpbml0aW9uLCBvd25lcik7XG5cbiAgICAgIGRlZmluaXRpb24gPSBjb25zdGFudHMucmVzb2x2ZWRDb21wb25lbnQoXG4gICAgICAgIGV4cGVjdChyZXNvbHZlZFZhbHVlLCAnQlVHOiBleHBlY3RlZCByZXNvbHZlZCBjb21wb25lbnQnKSxcbiAgICAgICAgcmVzb2x2ZWREZWZpbml0aW9uXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWZpbml0aW9uID0gY29uc3RhbnRzLmNvbXBvbmVudChyZXNvbHZlZERlZmluaXRpb24sIG93bmVyKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYXJncy5uYW1lZC5tZXJnZShhc3NpZ24oe30sIC4uLm5hbWVkKSk7XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYXJncy5yZWFsbG9jKHBvc2l0aW9uYWwubGVuZ3RoKTtcbiAgICAgIGFyZ3MucG9zaXRpb25hbC5wcmVwZW5kKHBvc2l0aW9uYWwpO1xuICAgIH1cblxuICAgIGxldCB7IG1hbmFnZXIgfSA9IGRlZmluaXRpb247XG5cbiAgICBhc3NlcnQoaW5zdGFuY2UubWFuYWdlciA9PT0gbnVsbCwgJ2NvbXBvbmVudCBpbnN0YW5jZSBtYW5hZ2VyIHNob3VsZCBub3QgYmUgcG9wdWxhdGVkIHlldCcpO1xuICAgIGFzc2VydChcbiAgICAgIGluc3RhbmNlLmNhcGFiaWxpdGllcyA9PT0gbnVsbCxcbiAgICAgICdjb21wb25lbnQgaW5zdGFuY2UgbWFuYWdlciBzaG91bGQgbm90IGJlIHBvcHVsYXRlZCB5ZXQnXG4gICAgKTtcblxuICAgIGluc3RhbmNlLmRlZmluaXRpb24gPSBkZWZpbml0aW9uO1xuICAgIGluc3RhbmNlLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIGluc3RhbmNlLmNhcGFiaWxpdGllcyA9IGRlZmluaXRpb24uY2FwYWJpbGl0aWVzO1xuXG4gICAgLy8gU2F2ZSBvZmYgdGhlIG93bmVyIHRoYXQgdGhpcyBjb21wb25lbnQgd2FzIGN1cnJpZWQgd2l0aC4gTGF0ZXIgb24sXG4gICAgLy8gd2UnbGwgZmV0Y2ggdGhlIHZhbHVlIG9mIHRoaXMgcmVnaXN0ZXIgYW5kIHNldCBpdCBhcyB0aGUgb3duZXIgb24gdGhlXG4gICAgLy8gbmV3IHJvb3Qgc2NvcGUuXG4gICAgdm0ubG9hZFZhbHVlKCR0MSwgb3duZXIpO1xuICB9XG5cbiAgbGV0IHsgbWFuYWdlciwgc3RhdGUgfSA9IGRlZmluaXRpb247XG4gIGxldCBjYXBhYmlsaXRpZXMgPSBpbnN0YW5jZS5jYXBhYmlsaXRpZXM7XG5cbiAgaWYgKCFtYW5hZ2VySGFzQ2FwYWJpbGl0eShtYW5hZ2VyLCBjYXBhYmlsaXRpZXMsIEludGVybmFsQ29tcG9uZW50Q2FwYWJpbGl0eS5QcmVwYXJlQXJncykpIHtcbiAgICBzdGFjay5wdXNoKGFyZ3MpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBibG9ja3MgPSBhcmdzLmJsb2Nrcy52YWx1ZXM7XG4gIGxldCBibG9ja05hbWVzID0gYXJncy5ibG9ja3MubmFtZXM7XG4gIGxldCBwcmVwYXJlZEFyZ3MgPSBtYW5hZ2VyLnByZXBhcmVBcmdzKHN0YXRlLCBhcmdzKTtcblxuICBpZiAocHJlcGFyZWRBcmdzKSB7XG4gICAgYXJncy5jbGVhcigpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0YWNrLnB1c2goYmxvY2tzW2ldKTtcbiAgICB9XG5cbiAgICBsZXQgeyBwb3NpdGlvbmFsLCBuYW1lZCB9ID0gcHJlcGFyZWRBcmdzO1xuXG4gICAgbGV0IHBvc2l0aW9uYWxDb3VudCA9IHBvc2l0aW9uYWwubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbmFsQ291bnQ7IGkrKykge1xuICAgICAgc3RhY2sucHVzaChwb3NpdGlvbmFsW2ldKTtcbiAgICB9XG5cbiAgICBsZXQgbmFtZXMgPSBPYmplY3Qua2V5cyhuYW1lZCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzdGFjay5wdXNoKG5hbWVkW25hbWVzW2ldXSk7XG4gICAgfVxuXG4gICAgYXJncy5zZXR1cChzdGFjaywgbmFtZXMsIGJsb2NrTmFtZXMsIHBvc2l0aW9uYWxDb3VudCwgZmFsc2UpO1xuICB9XG5cbiAgc3RhY2sucHVzaChhcmdzKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuQ3JlYXRlQ29tcG9uZW50LCAodm0sIHsgb3AxOiBmbGFncywgb3AyOiBfc3RhdGUgfSkgPT4ge1xuICBsZXQgaW5zdGFuY2UgPSBjaGVjayh2bS5mZXRjaFZhbHVlKF9zdGF0ZSksIENoZWNrQ29tcG9uZW50SW5zdGFuY2UpO1xuICBsZXQgeyBkZWZpbml0aW9uLCBtYW5hZ2VyLCBjYXBhYmlsaXRpZXMgfSA9IGluc3RhbmNlO1xuXG4gIGlmICghbWFuYWdlckhhc0NhcGFiaWxpdHkobWFuYWdlciwgY2FwYWJpbGl0aWVzLCBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdHkuQ3JlYXRlSW5zdGFuY2UpKSB7XG4gICAgLy8gVE9ETzogQ2xvc3VyZSBhbmQgTWFpbiBjb21wb25lbnRzIGFyZSBhbHdheXMgaW52b2tlZCBkeW5hbWljYWxseSwgc28gdGhpc1xuICAgIC8vIG9wY29kZSBtYXkgcnVuIGV2ZW4gaWYgdGhpcyBjYXBhYmlsaXR5IGlzIG5vdCBlbmFibGVkLiBJbiB0aGUgZnV0dXJlIHdlXG4gICAgLy8gc2hvdWxkIGhhbmRsZSB0aGlzIGluIGEgYmV0dGVyIHdheS5cbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgZHluYW1pY1Njb3BlOiBPcHRpb248RHluYW1pY1Njb3BlPiA9IG51bGw7XG4gIGlmIChtYW5hZ2VySGFzQ2FwYWJpbGl0eShtYW5hZ2VyLCBjYXBhYmlsaXRpZXMsIEludGVybmFsQ29tcG9uZW50Q2FwYWJpbGl0eS5EeW5hbWljU2NvcGUpKSB7XG4gICAgZHluYW1pY1Njb3BlID0gdm0uZHluYW1pY1Njb3BlKCk7XG4gIH1cblxuICBsZXQgaGFzRGVmYXVsdEJsb2NrID0gZmxhZ3MgJiAxO1xuICBsZXQgYXJnczogT3B0aW9uPFZNQXJndW1lbnRzPiA9IG51bGw7XG5cbiAgaWYgKG1hbmFnZXJIYXNDYXBhYmlsaXR5KG1hbmFnZXIsIGNhcGFiaWxpdGllcywgSW50ZXJuYWxDb21wb25lbnRDYXBhYmlsaXR5LkNyZWF0ZUFyZ3MpKSB7XG4gICAgYXJncyA9IGNoZWNrKHZtLnN0YWNrLnBlZWsoKSwgQ2hlY2tBcmd1bWVudHMpO1xuICB9XG5cbiAgbGV0IHNlbGY6IE9wdGlvbjxSZWZlcmVuY2U+ID0gbnVsbDtcbiAgaWYgKG1hbmFnZXJIYXNDYXBhYmlsaXR5KG1hbmFnZXIsIGNhcGFiaWxpdGllcywgSW50ZXJuYWxDb21wb25lbnRDYXBhYmlsaXR5LkNyZWF0ZUNhbGxlcikpIHtcbiAgICBzZWxmID0gdm0uZ2V0U2VsZigpO1xuICB9XG5cbiAgbGV0IHN0YXRlID0gbWFuYWdlci5jcmVhdGUoXG4gICAgdm0uZ2V0T3duZXIoKSxcbiAgICBkZWZpbml0aW9uLnN0YXRlLFxuICAgIGFyZ3MsXG4gICAgdm0uZW52LFxuICAgIGR5bmFtaWNTY29wZSxcbiAgICBzZWxmLFxuICAgICEhaGFzRGVmYXVsdEJsb2NrXG4gICk7XG5cbiAgLy8gV2Ugd2FudCB0byByZXVzZSB0aGUgYHN0YXRlYCBQT0pPIGhlcmUsIGJlY2F1c2Ugd2Uga25vdyB0aGF0IHRoZSBvcGNvZGVzXG4gIC8vIG9ubHkgdHJhbnNpdGlvbiBhdCBleGFjdGx5IG9uZSBwbGFjZS5cbiAgaW5zdGFuY2Uuc3RhdGUgPSBzdGF0ZTtcblxuICBpZiAobWFuYWdlckhhc0NhcGFiaWxpdHkobWFuYWdlciwgY2FwYWJpbGl0aWVzLCBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdHkuVXBkYXRlSG9vaykpIHtcbiAgICB2bS51cGRhdGVXaXRoKG5ldyBVcGRhdGVDb21wb25lbnRPcGNvZGUoc3RhdGUsIG1hbmFnZXIsIGR5bmFtaWNTY29wZSkpO1xuICB9XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLlJlZ2lzdGVyQ29tcG9uZW50RGVzdHJ1Y3RvciwgKHZtLCB7IG9wMTogX3N0YXRlIH0pID0+IHtcbiAgbGV0IHsgbWFuYWdlciwgc3RhdGUsIGNhcGFiaWxpdGllcyB9ID0gY2hlY2sodm0uZmV0Y2hWYWx1ZShfc3RhdGUpLCBDaGVja0NvbXBvbmVudEluc3RhbmNlKTtcblxuICBsZXQgZCA9IG1hbmFnZXIuZ2V0RGVzdHJveWFibGUoc3RhdGUpO1xuXG4gIGlmIChcbiAgICBERUJVRyAmJlxuICAgICFtYW5hZ2VySGFzQ2FwYWJpbGl0eShtYW5hZ2VyLCBjYXBhYmlsaXRpZXMsIEludGVybmFsQ29tcG9uZW50Q2FwYWJpbGl0eS5XaWxsRGVzdHJveSkgJiZcbiAgICBkICE9PSBudWxsICYmXG4gICAgdHlwZW9mICd3aWxsRGVzdHJveScgaW4gZFxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQlVHOiBEZXN0cnVjdG9yIGhhcyB3aWxsRGVzdHJveSwgYnV0IHRoZSB3aWxsRGVzdHJveSBjYXBhYmlsaXR5IHdhcyBub3QgZW5hYmxlZCBmb3IgdGhpcyBjb21wb25lbnQuIFByZS1kZXN0cnVjdGlvbiBob29rcyBtdXN0IGJlIGV4cGxpY2l0bHkgb3B0ZWQgaW50bydcbiAgICApO1xuICB9XG5cbiAgaWYgKGQpIHZtLmFzc29jaWF0ZURlc3Ryb3lhYmxlKGQpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5CZWdpbkNvbXBvbmVudFRyYW5zYWN0aW9uLCAodm0sIHsgb3AxOiBfc3RhdGUgfSkgPT4ge1xuICBsZXQgbmFtZTtcblxuICBpZiAoREVCVUcpIHtcbiAgICBsZXQgeyBkZWZpbml0aW9uLCBtYW5hZ2VyIH0gPSBjaGVjayh2bS5mZXRjaFZhbHVlKF9zdGF0ZSksIENoZWNrQ29tcG9uZW50SW5zdGFuY2UpO1xuXG4gICAgbmFtZSA9IGRlZmluaXRpb24ucmVzb2x2ZWROYW1lID8/IG1hbmFnZXIuZ2V0RGVidWdOYW1lKGRlZmluaXRpb24uc3RhdGUpO1xuICB9XG5cbiAgdm0uYmVnaW5DYWNoZUdyb3VwKG5hbWUpO1xuICB2bS5lbGVtZW50cygpLnB1c2hTaW1wbGVCbG9jaygpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5QdXRDb21wb25lbnRPcGVyYXRpb25zLCAodm0pID0+IHtcbiAgdm0ubG9hZFZhbHVlKCR0MCwgbmV3IENvbXBvbmVudEVsZW1lbnRPcGVyYXRpb25zKCkpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5Db21wb25lbnRBdHRyLCAodm0sIHsgb3AxOiBfbmFtZSwgb3AyOiBfdHJ1c3RpbmcsIG9wMzogX25hbWVzcGFjZSB9KSA9PiB7XG4gIGxldCBuYW1lID0gdm1bQ09OU1RBTlRTXS5nZXRWYWx1ZTxzdHJpbmc+KF9uYW1lKTtcbiAgbGV0IHRydXN0aW5nID0gdm1bQ09OU1RBTlRTXS5nZXRWYWx1ZTxib29sZWFuPihfdHJ1c3RpbmcpO1xuICBsZXQgcmVmZXJlbmNlID0gY2hlY2sodm0uc3RhY2sucG9wKCksIENoZWNrUmVmZXJlbmNlKTtcbiAgbGV0IG5hbWVzcGFjZSA9IF9uYW1lc3BhY2UgPyB2bVtDT05TVEFOVFNdLmdldFZhbHVlPHN0cmluZz4oX25hbWVzcGFjZSkgOiBudWxsO1xuXG4gIGNoZWNrKHZtLmZldGNoVmFsdWUoJHQwKSwgQ2hlY2tJbnN0YW5jZW9mKENvbXBvbmVudEVsZW1lbnRPcGVyYXRpb25zKSkuc2V0QXR0cmlidXRlKFxuICAgIG5hbWUsXG4gICAgcmVmZXJlbmNlLFxuICAgIHRydXN0aW5nLFxuICAgIG5hbWVzcGFjZVxuICApO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5TdGF0aWNDb21wb25lbnRBdHRyLCAodm0sIHsgb3AxOiBfbmFtZSwgb3AyOiBfdmFsdWUsIG9wMzogX25hbWVzcGFjZSB9KSA9PiB7XG4gIGxldCBuYW1lID0gdm1bQ09OU1RBTlRTXS5nZXRWYWx1ZTxzdHJpbmc+KF9uYW1lKTtcbiAgbGV0IHZhbHVlID0gdm1bQ09OU1RBTlRTXS5nZXRWYWx1ZTxzdHJpbmc+KF92YWx1ZSk7XG4gIGxldCBuYW1lc3BhY2UgPSBfbmFtZXNwYWNlID8gdm1bQ09OU1RBTlRTXS5nZXRWYWx1ZTxzdHJpbmc+KF9uYW1lc3BhY2UpIDogbnVsbDtcblxuICBjaGVjayh2bS5mZXRjaFZhbHVlKCR0MCksIENoZWNrSW5zdGFuY2VvZihDb21wb25lbnRFbGVtZW50T3BlcmF0aW9ucykpLnNldFN0YXRpY0F0dHJpYnV0ZShcbiAgICBuYW1lLFxuICAgIHZhbHVlLFxuICAgIG5hbWVzcGFjZVxuICApO1xufSk7XG5cbnR5cGUgRGVmZXJyZWRBdHRyaWJ1dGUgPSB7XG4gIHZhbHVlOiBzdHJpbmcgfCBSZWZlcmVuY2U8dW5rbm93bj47XG4gIG5hbWVzcGFjZTogT3B0aW9uPHN0cmluZz47XG4gIHRydXN0aW5nPzogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCBjbGFzcyBDb21wb25lbnRFbGVtZW50T3BlcmF0aW9ucyBpbXBsZW1lbnRzIEVsZW1lbnRPcGVyYXRpb25zIHtcbiAgcHJpdmF0ZSBhdHRyaWJ1dGVzID0gZGljdDxEZWZlcnJlZEF0dHJpYnV0ZT4oKTtcbiAgcHJpdmF0ZSBjbGFzc2VzOiAoc3RyaW5nIHwgUmVmZXJlbmNlPHVua25vd24+KVtdID0gW107XG4gIHByaXZhdGUgbW9kaWZpZXJzOiBNb2RpZmllckluc3RhbmNlW10gPSBbXTtcblxuICBzZXRBdHRyaWJ1dGUoXG4gICAgbmFtZTogc3RyaW5nLFxuICAgIHZhbHVlOiBSZWZlcmVuY2U8dW5rbm93bj4sXG4gICAgdHJ1c3Rpbmc6IGJvb2xlYW4sXG4gICAgbmFtZXNwYWNlOiBPcHRpb248c3RyaW5nPlxuICApIHtcbiAgICBsZXQgZGVmZXJyZWQgPSB7IHZhbHVlLCBuYW1lc3BhY2UsIHRydXN0aW5nIH07XG5cbiAgICBpZiAobmFtZSA9PT0gJ2NsYXNzJykge1xuICAgICAgdGhpcy5jbGFzc2VzLnB1c2godmFsdWUpO1xuICAgIH1cblxuICAgIHRoaXMuYXR0cmlidXRlc1tuYW1lXSA9IGRlZmVycmVkO1xuICB9XG5cbiAgc2V0U3RhdGljQXR0cmlidXRlKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZywgbmFtZXNwYWNlOiBPcHRpb248c3RyaW5nPik6IHZvaWQge1xuICAgIGxldCBkZWZlcnJlZCA9IHsgdmFsdWUsIG5hbWVzcGFjZSB9O1xuXG4gICAgaWYgKG5hbWUgPT09ICdjbGFzcycpIHtcbiAgICAgIHRoaXMuY2xhc3Nlcy5wdXNoKHZhbHVlKTtcbiAgICB9XG5cbiAgICB0aGlzLmF0dHJpYnV0ZXNbbmFtZV0gPSBkZWZlcnJlZDtcbiAgfVxuXG4gIGFkZE1vZGlmaWVyKG1vZGlmaWVyOiBNb2RpZmllckluc3RhbmNlKTogdm9pZCB7XG4gICAgdGhpcy5tb2RpZmllcnMucHVzaChtb2RpZmllcik7XG4gIH1cblxuICBmbHVzaCh2bTogSW50ZXJuYWxWTSk6IE1vZGlmaWVySW5zdGFuY2VbXSB7XG4gICAgbGV0IHR5cGU6IERlZmVycmVkQXR0cmlidXRlIHwgdW5kZWZpbmVkO1xuICAgIGxldCBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG4gICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChuYW1lID09PSAndHlwZScpIHtcbiAgICAgICAgdHlwZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBsZXQgYXR0ciA9IHRoaXMuYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgIGlmIChuYW1lID09PSAnY2xhc3MnKSB7XG4gICAgICAgIHNldERlZmVycmVkQXR0cih2bSwgJ2NsYXNzJywgbWVyZ2VDbGFzc2VzKHRoaXMuY2xhc3NlcyksIGF0dHIubmFtZXNwYWNlLCBhdHRyLnRydXN0aW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldERlZmVycmVkQXR0cih2bSwgbmFtZSwgYXR0ci52YWx1ZSwgYXR0ci5uYW1lc3BhY2UsIGF0dHIudHJ1c3RpbmcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNldERlZmVycmVkQXR0cih2bSwgJ3R5cGUnLCB0eXBlLnZhbHVlLCB0eXBlLm5hbWVzcGFjZSwgdHlwZS50cnVzdGluZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubW9kaWZpZXJzO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NlcyhjbGFzc2VzOiAoc3RyaW5nIHwgUmVmZXJlbmNlKVtdKTogc3RyaW5nIHwgUmVmZXJlbmNlPHVua25vd24+IHtcbiAgaWYgKGNsYXNzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGlmIChjbGFzc2VzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBjbGFzc2VzWzBdO1xuICB9XG4gIGlmIChhbGxTdHJpbmdDbGFzc2VzKGNsYXNzZXMpKSB7XG4gICAgcmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUNsYXNzTGlzdFJlZihjbGFzc2VzIGFzIFJlZmVyZW5jZVtdKTtcbn1cblxuZnVuY3Rpb24gYWxsU3RyaW5nQ2xhc3NlcyhjbGFzc2VzOiAoc3RyaW5nIHwgUmVmZXJlbmNlPHVua25vd24+KVtdKTogY2xhc3NlcyBpcyBzdHJpbmdbXSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0eXBlb2YgY2xhc3Nlc1tpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHNldERlZmVycmVkQXR0cihcbiAgdm06IEludGVybmFsVk0sXG4gIG5hbWU6IHN0cmluZyxcbiAgdmFsdWU6IHN0cmluZyB8IFJlZmVyZW5jZTx1bmtub3duPixcbiAgbmFtZXNwYWNlOiBPcHRpb248c3RyaW5nPixcbiAgdHJ1c3RpbmcgPSBmYWxzZVxuKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdm0uZWxlbWVudHMoKS5zZXRTdGF0aWNBdHRyaWJ1dGUobmFtZSwgdmFsdWUsIG5hbWVzcGFjZSk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGF0dHJpYnV0ZSA9IHZtXG4gICAgICAuZWxlbWVudHMoKVxuICAgICAgLnNldER5bmFtaWNBdHRyaWJ1dGUobmFtZSwgdmFsdWVGb3JSZWYodmFsdWUpLCB0cnVzdGluZywgbmFtZXNwYWNlKTtcbiAgICBpZiAoIWlzQ29uc3RSZWYodmFsdWUpKSB7XG4gICAgICB2bS51cGRhdGVXaXRoKG5ldyBVcGRhdGVEeW5hbWljQXR0cmlidXRlT3Bjb2RlKHZhbHVlLCBhdHRyaWJ1dGUsIHZtLmVudikpO1xuICAgIH1cbiAgfVxufVxuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuRGlkQ3JlYXRlRWxlbWVudCwgKHZtLCB7IG9wMTogX3N0YXRlIH0pID0+IHtcbiAgbGV0IHsgZGVmaW5pdGlvbiwgc3RhdGUgfSA9IGNoZWNrKHZtLmZldGNoVmFsdWUoX3N0YXRlKSwgQ2hlY2tDb21wb25lbnRJbnN0YW5jZSk7XG4gIGxldCB7IG1hbmFnZXIgfSA9IGRlZmluaXRpb247XG5cbiAgbGV0IG9wZXJhdGlvbnMgPSBjaGVjayh2bS5mZXRjaFZhbHVlKCR0MCksIENoZWNrSW5zdGFuY2VvZihDb21wb25lbnRFbGVtZW50T3BlcmF0aW9ucykpO1xuXG4gIChtYW5hZ2VyIGFzIFdpdGhFbGVtZW50SG9vazx1bmtub3duPikuZGlkQ3JlYXRlRWxlbWVudChcbiAgICBzdGF0ZSxcbiAgICBleHBlY3Qodm0uZWxlbWVudHMoKS5jb25zdHJ1Y3RpbmcsIGBFeHBlY3RlZCBhIGNvbnN0cnVjdGluZyBlbGVtZW50IGluIERpZENyZWF0ZU9wY29kZWApLFxuICAgIG9wZXJhdGlvbnNcbiAgKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuR2V0Q29tcG9uZW50U2VsZiwgKHZtLCB7IG9wMTogX3N0YXRlLCBvcDI6IF9uYW1lcyB9KSA9PiB7XG4gIGxldCBpbnN0YW5jZSA9IGNoZWNrKHZtLmZldGNoVmFsdWUoX3N0YXRlKSwgQ2hlY2tDb21wb25lbnRJbnN0YW5jZSk7XG4gIGxldCB7IGRlZmluaXRpb24sIHN0YXRlIH0gPSBpbnN0YW5jZTtcbiAgbGV0IHsgbWFuYWdlciB9ID0gZGVmaW5pdGlvbjtcbiAgbGV0IHNlbGZSZWYgPSBtYW5hZ2VyLmdldFNlbGYoc3RhdGUpO1xuXG4gIGlmICh2bS5lbnYuZGVidWdSZW5kZXJUcmVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBsZXQgaW5zdGFuY2UgPSBjaGVjayh2bS5mZXRjaFZhbHVlKF9zdGF0ZSksIENoZWNrQ29tcG9uZW50SW5zdGFuY2UpO1xuICAgIGxldCB7IGRlZmluaXRpb24sIG1hbmFnZXIgfSA9IGluc3RhbmNlO1xuXG4gICAgbGV0IGFyZ3M6IENhcHR1cmVkQXJndW1lbnRzO1xuXG4gICAgaWYgKHZtLnN0YWNrLnBlZWsoKSA9PT0gdm1bQVJHU10pIHtcbiAgICAgIGFyZ3MgPSB2bVtBUkdTXS5jYXB0dXJlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBuYW1lcyA9IHZtW0NPTlNUQU5UU10uZ2V0QXJyYXk8c3RyaW5nPihfbmFtZXMpO1xuICAgICAgdm1bQVJHU10uc2V0dXAodm0uc3RhY2ssIG5hbWVzLCBbXSwgMCwgdHJ1ZSk7XG4gICAgICBhcmdzID0gdm1bQVJHU10uY2FwdHVyZSgpO1xuICAgIH1cblxuICAgIGxldCBtb2R1bGVOYW1lOiBzdHJpbmc7XG4gICAgbGV0IGNvbXBpbGFibGU6IENvbXBpbGFibGVQcm9ncmFtIHwgbnVsbCA9IGRlZmluaXRpb24uY29tcGlsYWJsZTtcblxuICAgIGlmIChjb21waWxhYmxlID09PSBudWxsKSB7XG4gICAgICBhc3NlcnQoXG4gICAgICAgIG1hbmFnZXJIYXNDYXBhYmlsaXR5KFxuICAgICAgICAgIG1hbmFnZXIsXG4gICAgICAgICAgaW5zdGFuY2UuY2FwYWJpbGl0aWVzLFxuICAgICAgICAgIEludGVybmFsQ29tcG9uZW50Q2FwYWJpbGl0eS5EeW5hbWljTGF5b3V0XG4gICAgICAgICksXG4gICAgICAgICdCVUc6IE5vIHRlbXBsYXRlIHdhcyBmb3VuZCBmb3IgdGhpcyBjb21wb25lbnQsIGFuZCB0aGUgY29tcG9uZW50IGRpZCBub3QgaGF2ZSB0aGUgZHluYW1pYyBsYXlvdXQgY2FwYWJpbGl0eSdcbiAgICAgICk7XG5cbiAgICAgIGNvbXBpbGFibGUgPSBtYW5hZ2VyLmdldER5bmFtaWNMYXlvdXQoc3RhdGUsIHZtLnJ1bnRpbWUucmVzb2x2ZXIpO1xuXG4gICAgICBpZiAoY29tcGlsYWJsZSAhPT0gbnVsbCkge1xuICAgICAgICBtb2R1bGVOYW1lID0gY29tcGlsYWJsZS5tb2R1bGVOYW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9kdWxlTmFtZSA9ICdfX2RlZmF1bHRfXy5oYnMnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtb2R1bGVOYW1lID0gY29tcGlsYWJsZS5tb2R1bGVOYW1lO1xuICAgIH1cblxuICAgIC8vIEZvciB0ZWFyaW5nIGRvd24gdGhlIGRlYnVnUmVuZGVyVHJlZVxuICAgIHZtLmFzc29jaWF0ZURlc3Ryb3lhYmxlKGluc3RhbmNlKTtcblxuICAgIGlmIChoYXNDdXN0b21EZWJ1Z1JlbmRlclRyZWVMaWZlY3ljbGUobWFuYWdlcikpIHtcbiAgICAgIGxldCBub2RlcyA9IG1hbmFnZXIuZ2V0RGVidWdDdXN0b21SZW5kZXJUcmVlKFxuICAgICAgICBpbnN0YW5jZS5kZWZpbml0aW9uLnN0YXRlLFxuICAgICAgICBpbnN0YW5jZS5zdGF0ZSxcbiAgICAgICAgYXJncyxcbiAgICAgICAgbW9kdWxlTmFtZVxuICAgICAgKTtcblxuICAgICAgbm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICBsZXQgeyBidWNrZXQgfSA9IG5vZGU7XG4gICAgICAgIHZtLmVudi5kZWJ1Z1JlbmRlclRyZWUhLmNyZWF0ZShidWNrZXQsIG5vZGUpO1xuXG4gICAgICAgIHJlZ2lzdGVyRGVzdHJ1Y3RvcihpbnN0YW5jZSwgKCkgPT4ge1xuICAgICAgICAgIHZtLmVudi5kZWJ1Z1JlbmRlclRyZWU/LndpbGxEZXN0cm95KGJ1Y2tldCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZtLnVwZGF0ZVdpdGgobmV3IERlYnVnUmVuZGVyVHJlZVVwZGF0ZU9wY29kZShidWNrZXQpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbmFtZSA9IGRlZmluaXRpb24ucmVzb2x2ZWROYW1lID8/IG1hbmFnZXIuZ2V0RGVidWdOYW1lKGRlZmluaXRpb24uc3RhdGUpO1xuXG4gICAgICB2bS5lbnYuZGVidWdSZW5kZXJUcmVlLmNyZWF0ZShpbnN0YW5jZSwge1xuICAgICAgICB0eXBlOiAnY29tcG9uZW50JyxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgYXJncyxcbiAgICAgICAgdGVtcGxhdGU6IG1vZHVsZU5hbWUsXG4gICAgICAgIGluc3RhbmNlOiB2YWx1ZUZvclJlZihzZWxmUmVmKSxcbiAgICAgIH0pO1xuXG4gICAgICB2bS5hc3NvY2lhdGVEZXN0cm95YWJsZShpbnN0YW5jZSk7XG5cbiAgICAgIHJlZ2lzdGVyRGVzdHJ1Y3RvcihpbnN0YW5jZSwgKCkgPT4ge1xuICAgICAgICB2bS5lbnYuZGVidWdSZW5kZXJUcmVlPy53aWxsRGVzdHJveShpbnN0YW5jZSk7XG4gICAgICB9KTtcblxuICAgICAgdm0udXBkYXRlV2l0aChuZXcgRGVidWdSZW5kZXJUcmVlVXBkYXRlT3Bjb2RlKGluc3RhbmNlKSk7XG4gICAgfVxuICB9XG5cbiAgdm0uc3RhY2sucHVzaChzZWxmUmVmKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuR2V0Q29tcG9uZW50VGFnTmFtZSwgKHZtLCB7IG9wMTogX3N0YXRlIH0pID0+IHtcbiAgbGV0IHsgZGVmaW5pdGlvbiwgc3RhdGUgfSA9IGNoZWNrKHZtLmZldGNoVmFsdWUoX3N0YXRlKSwgQ2hlY2tDb21wb25lbnRJbnN0YW5jZSk7XG4gIGxldCB7IG1hbmFnZXIgfSA9IGRlZmluaXRpb247XG5cbiAgbGV0IHRhZ05hbWUgPSAobWFuYWdlciBhcyBSZWNhc3Q8XG4gICAgSW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyLFxuICAgIFdpdGhEeW5hbWljVGFnTmFtZTx1bmtub3duPlxuICA+KS5nZXRUYWdOYW1lKHN0YXRlKTtcblxuICAvLyBVc2VyIHByb3ZpZGVkIHZhbHVlIGZyb20gSlMsIHNvIHdlIGRvbid0IGJvdGhlciB0byBlbmNvZGVcbiAgdm0uc3RhY2sucHVzaCh0YWdOYW1lKTtcbn0pO1xuXG4vLyBEeW5hbWljIEludm9jYXRpb24gT25seVxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkdldENvbXBvbmVudExheW91dCwgKHZtLCB7IG9wMTogX3N0YXRlIH0pID0+IHtcbiAgbGV0IGluc3RhbmNlID0gY2hlY2sodm0uZmV0Y2hWYWx1ZShfc3RhdGUpLCBDaGVja0NvbXBvbmVudEluc3RhbmNlKTtcblxuICBsZXQgeyBtYW5hZ2VyLCBkZWZpbml0aW9uIH0gPSBpbnN0YW5jZTtcbiAgbGV0IHsgc3RhY2sgfSA9IHZtO1xuXG4gIGxldCB7IGNvbXBpbGFibGUgfSA9IGRlZmluaXRpb247XG5cbiAgaWYgKGNvbXBpbGFibGUgPT09IG51bGwpIHtcbiAgICBsZXQgeyBjYXBhYmlsaXRpZXMgfSA9IGluc3RhbmNlO1xuXG4gICAgYXNzZXJ0KFxuICAgICAgbWFuYWdlckhhc0NhcGFiaWxpdHkobWFuYWdlciwgY2FwYWJpbGl0aWVzLCBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdHkuRHluYW1pY0xheW91dCksXG4gICAgICAnQlVHOiBObyB0ZW1wbGF0ZSB3YXMgZm91bmQgZm9yIHRoaXMgY29tcG9uZW50LCBhbmQgdGhlIGNvbXBvbmVudCBkaWQgbm90IGhhdmUgdGhlIGR5bmFtaWMgbGF5b3V0IGNhcGFiaWxpdHknXG4gICAgKTtcblxuICAgIGNvbXBpbGFibGUgPSBtYW5hZ2VyLmdldER5bmFtaWNMYXlvdXQoaW5zdGFuY2Uuc3RhdGUsIHZtLnJ1bnRpbWUucmVzb2x2ZXIpO1xuXG4gICAgaWYgKGNvbXBpbGFibGUgPT09IG51bGwpIHtcbiAgICAgIGlmIChtYW5hZ2VySGFzQ2FwYWJpbGl0eShtYW5hZ2VyLCBjYXBhYmlsaXRpZXMsIEludGVybmFsQ29tcG9uZW50Q2FwYWJpbGl0eS5XcmFwcGVkKSkge1xuICAgICAgICBjb21waWxhYmxlID0gdW53cmFwVGVtcGxhdGUodm1bQ09OU1RBTlRTXS5kZWZhdWx0VGVtcGxhdGUpLmFzV3JhcHBlZExheW91dCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcGlsYWJsZSA9IHVud3JhcFRlbXBsYXRlKHZtW0NPTlNUQU5UU10uZGVmYXVsdFRlbXBsYXRlKS5hc0xheW91dCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCBoYW5kbGUgPSBjb21waWxhYmxlLmNvbXBpbGUodm0uY29udGV4dCk7XG5cbiAgc3RhY2sucHVzaChjb21waWxhYmxlLnN5bWJvbFRhYmxlKTtcbiAgc3RhY2sucHVzaChoYW5kbGUpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5NYWluLCAodm0sIHsgb3AxOiByZWdpc3RlciB9KSA9PiB7XG4gIGxldCBkZWZpbml0aW9uID0gY2hlY2sodm0uc3RhY2sucG9wKCksIENoZWNrQ29tcG9uZW50RGVmaW5pdGlvbik7XG4gIGxldCBpbnZvY2F0aW9uID0gY2hlY2sodm0uc3RhY2sucG9wKCksIENoZWNrSW52b2NhdGlvbik7XG5cbiAgbGV0IHsgbWFuYWdlciwgY2FwYWJpbGl0aWVzIH0gPSBkZWZpbml0aW9uO1xuXG4gIGxldCBzdGF0ZTogUG9wdWxhdGVkQ29tcG9uZW50SW5zdGFuY2UgPSB7XG4gICAgZGVmaW5pdGlvbixcbiAgICBtYW5hZ2VyLFxuICAgIGNhcGFiaWxpdGllcyxcbiAgICBzdGF0ZTogbnVsbCxcbiAgICBoYW5kbGU6IGludm9jYXRpb24uaGFuZGxlLFxuICAgIHRhYmxlOiBpbnZvY2F0aW9uLnN5bWJvbFRhYmxlLFxuICAgIGxvb2t1cDogbnVsbCxcbiAgfTtcblxuICB2bS5sb2FkVmFsdWUocmVnaXN0ZXIsIHN0YXRlKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuUG9wdWxhdGVMYXlvdXQsICh2bSwgeyBvcDE6IF9zdGF0ZSB9KSA9PiB7XG4gIGxldCB7IHN0YWNrIH0gPSB2bTtcblxuICAvLyBJbiBERUJVRyBoYW5kbGVzIGNvdWxkIGJlIEVyckhhbmRsZSBvYmplY3RzXG4gIGxldCBoYW5kbGUgPSBjaGVjayhzdGFjay5wb3AoKSwgQ2hlY2tIYW5kbGUpO1xuICBsZXQgdGFibGUgPSBjaGVjayhzdGFjay5wb3AoKSwgQ2hlY2tQcm9ncmFtU3ltYm9sVGFibGUpO1xuXG4gIGxldCBzdGF0ZSA9IGNoZWNrKHZtLmZldGNoVmFsdWUoX3N0YXRlKSwgQ2hlY2tDb21wb25lbnRJbnN0YW5jZSk7XG5cbiAgc3RhdGUuaGFuZGxlID0gaGFuZGxlO1xuICBzdGF0ZS50YWJsZSA9IHRhYmxlO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5WaXJ0dWFsUm9vdFNjb3BlLCAodm0sIHsgb3AxOiBfc3RhdGUgfSkgPT4ge1xuICBsZXQgeyB0YWJsZSwgbWFuYWdlciwgY2FwYWJpbGl0aWVzLCBzdGF0ZSB9ID0gY2hlY2soXG4gICAgdm0uZmV0Y2hWYWx1ZShfc3RhdGUpLFxuICAgIENoZWNrRmluaXNoZWRDb21wb25lbnRJbnN0YW5jZVxuICApO1xuXG4gIGxldCBvd25lcjtcblxuICBpZiAobWFuYWdlckhhc0NhcGFiaWxpdHkobWFuYWdlciwgY2FwYWJpbGl0aWVzLCBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdHkuSGFzU3ViT3duZXIpKSB7XG4gICAgb3duZXIgPSBtYW5hZ2VyLmdldE93bmVyKHN0YXRlKTtcbiAgICB2bS5sb2FkVmFsdWUoJHQxLCBudWxsKTsgLy8gQ2xlYXIgdGhlIHRlbXAgcmVnaXN0ZXJcbiAgfSBlbHNlIHtcbiAgICAvLyBDaGVjayB0aGUgdGVtcCByZWdpc3RlciB0byBzZWUgaWYgYW4gb3duZXIgd2FzIHJlc29sdmVkIGZyb20gY3VycnlpbmdcbiAgICBvd25lciA9IHZtLmZldGNoVmFsdWU8T3duZXIgfCBudWxsPigkdDEpO1xuXG4gICAgaWYgKG93bmVyID09PSBudWxsKSB7XG4gICAgICAvLyBJZiBhbiBvd25lciB3YXNuJ3QgZm91bmQsIGRlZmF1bHQgdG8gdXNpbmcgdGhlIGN1cnJlbnQgb3duZXIuIFRoaXNcbiAgICAgIC8vIHdpbGwgaGFwcGVuIGZvciBub3JtYWwgZHluYW1pYyBjb21wb25lbnQgaW52b2NhdGlvbixcbiAgICAgIC8vIGUuZy4gPFNvbWVDbGFzc2ljRW1iZXJDb21wb25lbnQvPlxuICAgICAgb3duZXIgPSB2bS5nZXRPd25lcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFbHNlIHRoZSBvd25lciB3YXMgZm91bmQsIHNvIGNsZWFyIHRoZSB0ZW1wIHJlZ2lzdGVyLiBUaGlzIHdpbGwgaGFwcGVuXG4gICAgICAvLyBpZiB3ZSBhcmUgbG9hZGluZyBhIGN1cnJpZWQgY29tcG9uZW50LCBlLmcuIDxAc29tZUN1cnJpZWRDb21wb25lbnQvPlxuICAgICAgdm0ubG9hZFZhbHVlKCR0MSwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgdm0ucHVzaFJvb3RTY29wZSh0YWJsZS5zeW1ib2xzLmxlbmd0aCArIDEsIG93bmVyKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuU2V0dXBGb3JFdmFsLCAodm0sIHsgb3AxOiBfc3RhdGUgfSkgPT4ge1xuICBsZXQgc3RhdGUgPSBjaGVjayh2bS5mZXRjaFZhbHVlKF9zdGF0ZSksIENoZWNrRmluaXNoZWRDb21wb25lbnRJbnN0YW5jZSk7XG5cbiAgaWYgKHN0YXRlLnRhYmxlLmhhc0V2YWwpIHtcbiAgICBsZXQgbG9va3VwID0gKHN0YXRlLmxvb2t1cCA9IGRpY3Q8U2NvcGVTbG90PigpKTtcbiAgICB2bS5zY29wZSgpLmJpbmRFdmFsU2NvcGUobG9va3VwKTtcbiAgfVxufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5TZXROYW1lZFZhcmlhYmxlcywgKHZtLCB7IG9wMTogX3N0YXRlIH0pID0+IHtcbiAgbGV0IHN0YXRlID0gY2hlY2sodm0uZmV0Y2hWYWx1ZShfc3RhdGUpLCBDaGVja0ZpbmlzaGVkQ29tcG9uZW50SW5zdGFuY2UpO1xuICBsZXQgc2NvcGUgPSB2bS5zY29wZSgpO1xuXG4gIGxldCBhcmdzID0gY2hlY2sodm0uc3RhY2sucGVlaygpLCBDaGVja0FyZ3VtZW50cyk7XG4gIGxldCBjYWxsZXJOYW1lcyA9IGFyZ3MubmFtZWQuYXROYW1lcztcblxuICBmb3IgKGxldCBpID0gY2FsbGVyTmFtZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBsZXQgYXROYW1lID0gY2FsbGVyTmFtZXNbaV07XG4gICAgbGV0IHN5bWJvbCA9IHN0YXRlLnRhYmxlLnN5bWJvbHMuaW5kZXhPZihjYWxsZXJOYW1lc1tpXSk7XG4gICAgbGV0IHZhbHVlID0gYXJncy5uYW1lZC5nZXQoYXROYW1lLCB0cnVlKTtcblxuICAgIGlmIChzeW1ib2wgIT09IC0xKSBzY29wZS5iaW5kU3ltYm9sKHN5bWJvbCArIDEsIHZhbHVlKTtcbiAgICBpZiAoc3RhdGUubG9va3VwKSBzdGF0ZS5sb29rdXBbYXROYW1lXSA9IHZhbHVlO1xuICB9XG59KTtcblxuZnVuY3Rpb24gYmluZEJsb2NrKFxuICBzeW1ib2xOYW1lOiBzdHJpbmcsXG4gIGJsb2NrTmFtZTogc3RyaW5nLFxuICBzdGF0ZTogQ29tcG9uZW50SW5zdGFuY2UsXG4gIGJsb2NrczogQmxvY2tBcmd1bWVudHNJbXBsLFxuICB2bTogSW50ZXJuYWxWTVxuKSB7XG4gIGxldCBzeW1ib2wgPSBzdGF0ZS50YWJsZS5zeW1ib2xzLmluZGV4T2Yoc3ltYm9sTmFtZSk7XG4gIGxldCBibG9jayA9IGJsb2Nrcy5nZXQoYmxvY2tOYW1lKTtcblxuICBpZiAoc3ltYm9sICE9PSAtMSkgdm0uc2NvcGUoKS5iaW5kQmxvY2soc3ltYm9sICsgMSwgYmxvY2spO1xuICBpZiAoc3RhdGUubG9va3VwKSBzdGF0ZS5sb29rdXBbc3ltYm9sTmFtZV0gPSBibG9jaztcbn1cblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLlNldEJsb2NrcywgKHZtLCB7IG9wMTogX3N0YXRlIH0pID0+IHtcbiAgbGV0IHN0YXRlID0gY2hlY2sodm0uZmV0Y2hWYWx1ZShfc3RhdGUpLCBDaGVja0ZpbmlzaGVkQ29tcG9uZW50SW5zdGFuY2UpO1xuICBsZXQgeyBibG9ja3MgfSA9IGNoZWNrKHZtLnN0YWNrLnBlZWsoKSwgQ2hlY2tBcmd1bWVudHMpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tzLm5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgYmluZEJsb2NrKGJsb2Nrcy5zeW1ib2xOYW1lc1tpXSwgYmxvY2tzLm5hbWVzW2ldLCBzdGF0ZSwgYmxvY2tzLCB2bSk7XG4gIH1cbn0pO1xuXG4vLyBEeW5hbWljIEludm9jYXRpb24gT25seVxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkludm9rZUNvbXBvbmVudExheW91dCwgKHZtLCB7IG9wMTogX3N0YXRlIH0pID0+IHtcbiAgbGV0IHN0YXRlID0gY2hlY2sodm0uZmV0Y2hWYWx1ZShfc3RhdGUpLCBDaGVja0ZpbmlzaGVkQ29tcG9uZW50SW5zdGFuY2UpO1xuXG4gIHZtLmNhbGwoc3RhdGUuaGFuZGxlISk7XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkRpZFJlbmRlckxheW91dCwgKHZtLCB7IG9wMTogX3N0YXRlIH0pID0+IHtcbiAgbGV0IGluc3RhbmNlID0gY2hlY2sodm0uZmV0Y2hWYWx1ZShfc3RhdGUpLCBDaGVja0NvbXBvbmVudEluc3RhbmNlKTtcbiAgbGV0IHsgbWFuYWdlciwgc3RhdGUsIGNhcGFiaWxpdGllcyB9ID0gaW5zdGFuY2U7XG4gIGxldCBib3VuZHMgPSB2bS5lbGVtZW50cygpLnBvcEJsb2NrKCk7XG5cbiAgaWYgKHZtLmVudi5kZWJ1Z1JlbmRlclRyZWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChoYXNDdXN0b21EZWJ1Z1JlbmRlclRyZWVMaWZlY3ljbGUobWFuYWdlcikpIHtcbiAgICAgIGxldCBub2RlcyA9IG1hbmFnZXIuZ2V0RGVidWdDdXN0b21SZW5kZXJUcmVlKGluc3RhbmNlLmRlZmluaXRpb24uc3RhdGUsIHN0YXRlLCBFTVBUWV9BUkdTKTtcblxuICAgICAgbm9kZXMucmV2ZXJzZSgpLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgbGV0IHsgYnVja2V0IH0gPSBub2RlO1xuXG4gICAgICAgIHZtLmVudi5kZWJ1Z1JlbmRlclRyZWUhLmRpZFJlbmRlcihidWNrZXQsIGJvdW5kcyk7XG5cbiAgICAgICAgdm0udXBkYXRlV2l0aChuZXcgRGVidWdSZW5kZXJUcmVlRGlkUmVuZGVyT3Bjb2RlKGJ1Y2tldCwgYm91bmRzKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uZW52LmRlYnVnUmVuZGVyVHJlZS5kaWRSZW5kZXIoaW5zdGFuY2UsIGJvdW5kcyk7XG5cbiAgICAgIHZtLnVwZGF0ZVdpdGgobmV3IERlYnVnUmVuZGVyVHJlZURpZFJlbmRlck9wY29kZShpbnN0YW5jZSwgYm91bmRzKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG1hbmFnZXJIYXNDYXBhYmlsaXR5KG1hbmFnZXIsIGNhcGFiaWxpdGllcywgSW50ZXJuYWxDb21wb25lbnRDYXBhYmlsaXR5LkNyZWF0ZUluc3RhbmNlKSkge1xuICAgIGxldCBtZ3IgPSBjaGVjayhtYW5hZ2VyLCBDaGVja0ludGVyZmFjZSh7IGRpZFJlbmRlckxheW91dDogQ2hlY2tGdW5jdGlvbiB9KSk7XG4gICAgbWdyLmRpZFJlbmRlckxheW91dChzdGF0ZSwgYm91bmRzKTtcblxuICAgIHZtLmVudi5kaWRDcmVhdGUoaW5zdGFuY2UgYXMgQ29tcG9uZW50SW5zdGFuY2VXaXRoQ3JlYXRlKTtcbiAgICB2bS51cGRhdGVXaXRoKG5ldyBEaWRVcGRhdGVMYXlvdXRPcGNvZGUoaW5zdGFuY2UgYXMgQ29tcG9uZW50SW5zdGFuY2VXaXRoQ3JlYXRlLCBib3VuZHMpKTtcbiAgfVxufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5Db21taXRDb21wb25lbnRUcmFuc2FjdGlvbiwgKHZtKSA9PiB7XG4gIHZtLmNvbW1pdENhY2hlR3JvdXAoKTtcbn0pO1xuXG5leHBvcnQgY2xhc3MgVXBkYXRlQ29tcG9uZW50T3Bjb2RlIGltcGxlbWVudHMgVXBkYXRpbmdPcGNvZGUge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGNvbXBvbmVudDogQ29tcG9uZW50SW5zdGFuY2VTdGF0ZSxcbiAgICBwcml2YXRlIG1hbmFnZXI6IFdpdGhVcGRhdGVIb29rLFxuICAgIHByaXZhdGUgZHluYW1pY1Njb3BlOiBPcHRpb248RHluYW1pY1Njb3BlPlxuICApIHt9XG5cbiAgZXZhbHVhdGUoX3ZtOiBVcGRhdGluZ1ZNKSB7XG4gICAgbGV0IHsgY29tcG9uZW50LCBtYW5hZ2VyLCBkeW5hbWljU2NvcGUgfSA9IHRoaXM7XG5cbiAgICBtYW5hZ2VyLnVwZGF0ZShjb21wb25lbnQsIGR5bmFtaWNTY29wZSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIERpZFVwZGF0ZUxheW91dE9wY29kZSBpbXBsZW1lbnRzIFVwZGF0aW5nT3Bjb2RlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBjb21wb25lbnQ6IENvbXBvbmVudEluc3RhbmNlV2l0aENyZWF0ZSwgcHJpdmF0ZSBib3VuZHM6IEJvdW5kcykge31cblxuICBldmFsdWF0ZSh2bTogVXBkYXRpbmdWTSkge1xuICAgIGxldCB7IGNvbXBvbmVudCwgYm91bmRzIH0gPSB0aGlzO1xuICAgIGxldCB7IG1hbmFnZXIsIHN0YXRlIH0gPSBjb21wb25lbnQ7XG5cbiAgICBtYW5hZ2VyLmRpZFVwZGF0ZUxheW91dChzdGF0ZSwgYm91bmRzKTtcblxuICAgIHZtLmVudi5kaWRVcGRhdGUoY29tcG9uZW50KTtcbiAgfVxufVxuXG5jbGFzcyBEZWJ1Z1JlbmRlclRyZWVVcGRhdGVPcGNvZGUgaW1wbGVtZW50cyBVcGRhdGluZ09wY29kZSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgYnVja2V0OiBvYmplY3QpIHt9XG5cbiAgZXZhbHVhdGUodm06IFVwZGF0aW5nVk0pIHtcbiAgICB2bS5lbnYuZGVidWdSZW5kZXJUcmVlPy51cGRhdGUodGhpcy5idWNrZXQpO1xuICB9XG59XG5cbmNsYXNzIERlYnVnUmVuZGVyVHJlZURpZFJlbmRlck9wY29kZSBpbXBsZW1lbnRzIFVwZGF0aW5nT3Bjb2RlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBidWNrZXQ6IG9iamVjdCwgcHJpdmF0ZSBib3VuZHM6IEJvdW5kcykge31cblxuICBldmFsdWF0ZSh2bTogVXBkYXRpbmdWTSkge1xuICAgIHZtLmVudi5kZWJ1Z1JlbmRlclRyZWU/LmRpZFJlbmRlcih0aGlzLmJ1Y2tldCwgdGhpcy5ib3VuZHMpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBpc0VtcHR5LCBpc1N0cmluZyB9IGZyb20gJy4uLy4uL2RvbS9ub3JtYWxpemUnO1xuaW1wb3J0IHsgVXBkYXRpbmdPcGNvZGUgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IFJlZmVyZW5jZSwgdmFsdWVGb3JSZWYgfSBmcm9tICdAZ2xpbW1lci9yZWZlcmVuY2UnO1xuaW1wb3J0IHsgU2ltcGxlVGV4dCB9IGZyb20gJ0BzaW1wbGUtZG9tL2ludGVyZmFjZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIER5bmFtaWNUZXh0Q29udGVudCBpbXBsZW1lbnRzIFVwZGF0aW5nT3Bjb2RlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIG5vZGU6IFNpbXBsZVRleHQsXG4gICAgcHJpdmF0ZSByZWZlcmVuY2U6IFJlZmVyZW5jZTx1bmtub3duPixcbiAgICBwcml2YXRlIGxhc3RWYWx1ZTogc3RyaW5nXG4gICkge31cblxuICBldmFsdWF0ZSgpIHtcbiAgICBsZXQgdmFsdWUgPSB2YWx1ZUZvclJlZih0aGlzLnJlZmVyZW5jZSk7XG5cbiAgICBsZXQgeyBsYXN0VmFsdWUgfSA9IHRoaXM7XG5cbiAgICBpZiAodmFsdWUgPT09IGxhc3RWYWx1ZSkgcmV0dXJuO1xuXG4gICAgbGV0IG5vcm1hbGl6ZWQ6IHN0cmluZztcblxuICAgIGlmIChpc0VtcHR5KHZhbHVlKSkge1xuICAgICAgbm9ybWFsaXplZCA9ICcnO1xuICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICBub3JtYWxpemVkID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vcm1hbGl6ZWQgPSBTdHJpbmcodmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChub3JtYWxpemVkICE9PSBsYXN0VmFsdWUpIHtcbiAgICAgIGxldCB0ZXh0Tm9kZSA9IHRoaXMubm9kZTtcbiAgICAgIHRleHROb2RlLm5vZGVWYWx1ZSA9IHRoaXMubGFzdFZhbHVlID0gbm9ybWFsaXplZDtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IGlzQ29uc3RSZWYsIHZhbHVlRm9yUmVmIH0gZnJvbSAnQGdsaW1tZXIvcmVmZXJlbmNlJztcbmltcG9ydCB7XG4gIGNoZWNrLFxuICBDaGVja1N0cmluZyxcbiAgQ2hlY2tTYWZlU3RyaW5nLFxuICBDaGVja05vZGUsXG4gIENoZWNrRG9jdW1lbnRGcmFnbWVudCxcbn0gZnJvbSAnQGdsaW1tZXIvZGVidWcnO1xuaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcblxuaW1wb3J0IHsgQVBQRU5EX09QQ09ERVMgfSBmcm9tICcuLi8uLi9vcGNvZGVzJztcbmltcG9ydCB7IENoZWNrUmVmZXJlbmNlIH0gZnJvbSAnLi8tZGVidWctc3RyaXAnO1xuaW1wb3J0IHsgaXNFbXB0eSwgaXNTYWZlU3RyaW5nLCBpc0ZyYWdtZW50LCBpc05vZGUsIHNob3VsZENvZXJjZSB9IGZyb20gJy4uLy4uL2RvbS9ub3JtYWxpemUnO1xuaW1wb3J0IER5bmFtaWNUZXh0Q29udGVudCBmcm9tICcuLi8uLi92bS9jb250ZW50L3RleHQnO1xuaW1wb3J0IHsgQ29udGVudFR5cGUsIEN1cnJpZWRUeXBlLCBPcCB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgQXNzZXJ0RmlsdGVyIH0gZnJvbSAnLi92bSc7XG5pbXBvcnQgeyBoYXNJbnRlcm5hbENvbXBvbmVudE1hbmFnZXIsIGhhc0ludGVybmFsSGVscGVyTWFuYWdlciB9IGZyb20gJ0BnbGltbWVyL21hbmFnZXInO1xuaW1wb3J0IHsgREVCVUcgfSBmcm9tICdAZ2xpbW1lci9lbnYnO1xuaW1wb3J0IHsgaXNDdXJyaWVkVHlwZSB9IGZyb20gJy4uLy4uL2N1cnJpZWQtdmFsdWUnO1xuXG5mdW5jdGlvbiB0b0NvbnRlbnRUeXBlKHZhbHVlOiB1bmtub3duKSB7XG4gIGlmIChzaG91bGRDb2VyY2UodmFsdWUpKSB7XG4gICAgcmV0dXJuIENvbnRlbnRUeXBlLlN0cmluZztcbiAgfSBlbHNlIGlmIChcbiAgICBpc0N1cnJpZWRUeXBlKHZhbHVlLCBDdXJyaWVkVHlwZS5Db21wb25lbnQpIHx8XG4gICAgaGFzSW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyKHZhbHVlIGFzIG9iamVjdClcbiAgKSB7XG4gICAgcmV0dXJuIENvbnRlbnRUeXBlLkNvbXBvbmVudDtcbiAgfSBlbHNlIGlmIChcbiAgICBpc0N1cnJpZWRUeXBlKHZhbHVlLCBDdXJyaWVkVHlwZS5IZWxwZXIpIHx8XG4gICAgaGFzSW50ZXJuYWxIZWxwZXJNYW5hZ2VyKHZhbHVlIGFzIG9iamVjdClcbiAgKSB7XG4gICAgcmV0dXJuIENvbnRlbnRUeXBlLkhlbHBlcjtcbiAgfSBlbHNlIGlmIChpc1NhZmVTdHJpbmcodmFsdWUpKSB7XG4gICAgcmV0dXJuIENvbnRlbnRUeXBlLlNhZmVTdHJpbmc7XG4gIH0gZWxzZSBpZiAoaXNGcmFnbWVudCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gQ29udGVudFR5cGUuRnJhZ21lbnQ7XG4gIH0gZWxzZSBpZiAoaXNOb2RlKHZhbHVlKSkge1xuICAgIHJldHVybiBDb250ZW50VHlwZS5Ob2RlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBDb250ZW50VHlwZS5TdHJpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gdG9EeW5hbWljQ29udGVudFR5cGUodmFsdWU6IHVua25vd24pIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gQ29udGVudFR5cGUuU3RyaW5nO1xuICB9XG5cbiAgaWYgKGlzQ3VycmllZFR5cGUodmFsdWUsIEN1cnJpZWRUeXBlLkNvbXBvbmVudCkgfHwgaGFzSW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyKHZhbHVlIGFzIG9iamVjdCkpIHtcbiAgICByZXR1cm4gQ29udGVudFR5cGUuQ29tcG9uZW50O1xuICB9IGVsc2Uge1xuICAgIGlmIChcbiAgICAgIERFQlVHICYmXG4gICAgICAhaXNDdXJyaWVkVHlwZSh2YWx1ZSwgQ3VycmllZFR5cGUuSGVscGVyKSAmJlxuICAgICAgIWhhc0ludGVybmFsSGVscGVyTWFuYWdlcih2YWx1ZSBhcyBvYmplY3QpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBBdHRlbXB0ZWQgdXNlIGEgZHluYW1pYyB2YWx1ZSBhcyBhIGNvbXBvbmVudCBvciBoZWxwZXIsIGJ1dCB0aGF0IHZhbHVlIGRpZCBub3QgaGF2ZSBhbiBhc3NvY2lhdGVkIGNvbXBvbmVudCBvciBoZWxwZXIgbWFuYWdlci4gVGhlIHZhbHVlIHdhczogJHt2YWx1ZX1gXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBDb250ZW50VHlwZS5IZWxwZXI7XG4gIH1cbn1cblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkNvbnRlbnRUeXBlLCAodm0pID0+IHtcbiAgbGV0IHJlZmVyZW5jZSA9IGNoZWNrKHZtLnN0YWNrLnBlZWsoKSwgQ2hlY2tSZWZlcmVuY2UpO1xuXG4gIHZtLnN0YWNrLnB1c2godG9Db250ZW50VHlwZSh2YWx1ZUZvclJlZihyZWZlcmVuY2UpKSk7XG5cbiAgaWYgKCFpc0NvbnN0UmVmKHJlZmVyZW5jZSkpIHtcbiAgICB2bS51cGRhdGVXaXRoKG5ldyBBc3NlcnRGaWx0ZXIocmVmZXJlbmNlLCB0b0NvbnRlbnRUeXBlKSk7XG4gIH1cbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuRHluYW1pY0NvbnRlbnRUeXBlLCAodm0pID0+IHtcbiAgbGV0IHJlZmVyZW5jZSA9IGNoZWNrKHZtLnN0YWNrLnBlZWsoKSwgQ2hlY2tSZWZlcmVuY2UpO1xuXG4gIHZtLnN0YWNrLnB1c2godG9EeW5hbWljQ29udGVudFR5cGUodmFsdWVGb3JSZWYocmVmZXJlbmNlKSkpO1xuXG4gIGlmICghaXNDb25zdFJlZihyZWZlcmVuY2UpKSB7XG4gICAgdm0udXBkYXRlV2l0aChuZXcgQXNzZXJ0RmlsdGVyKHJlZmVyZW5jZSwgdG9EeW5hbWljQ29udGVudFR5cGUpKTtcbiAgfVxufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5BcHBlbmRIVE1MLCAodm0pID0+IHtcbiAgbGV0IHJlZmVyZW5jZSA9IGNoZWNrKHZtLnN0YWNrLnBvcCgpLCBDaGVja1JlZmVyZW5jZSk7XG5cbiAgbGV0IHJhd1ZhbHVlID0gdmFsdWVGb3JSZWYocmVmZXJlbmNlKTtcbiAgbGV0IHZhbHVlID0gaXNFbXB0eShyYXdWYWx1ZSkgPyAnJyA6IFN0cmluZyhyYXdWYWx1ZSk7XG5cbiAgdm0uZWxlbWVudHMoKS5hcHBlbmREeW5hbWljSFRNTCh2YWx1ZSk7XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkFwcGVuZFNhZmVIVE1MLCAodm0pID0+IHtcbiAgbGV0IHJlZmVyZW5jZSA9IGNoZWNrKHZtLnN0YWNrLnBvcCgpLCBDaGVja1JlZmVyZW5jZSk7XG5cbiAgbGV0IHJhd1ZhbHVlID0gY2hlY2sodmFsdWVGb3JSZWYocmVmZXJlbmNlKSwgQ2hlY2tTYWZlU3RyaW5nKS50b0hUTUwoKTtcbiAgbGV0IHZhbHVlID0gaXNFbXB0eShyYXdWYWx1ZSkgPyAnJyA6IGNoZWNrKHJhd1ZhbHVlLCBDaGVja1N0cmluZyk7XG5cbiAgdm0uZWxlbWVudHMoKS5hcHBlbmREeW5hbWljSFRNTCh2YWx1ZSk7XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkFwcGVuZFRleHQsICh2bSkgPT4ge1xuICBsZXQgcmVmZXJlbmNlID0gY2hlY2sodm0uc3RhY2sucG9wKCksIENoZWNrUmVmZXJlbmNlKTtcblxuICBsZXQgcmF3VmFsdWUgPSB2YWx1ZUZvclJlZihyZWZlcmVuY2UpO1xuICBsZXQgdmFsdWUgPSBpc0VtcHR5KHJhd1ZhbHVlKSA/ICcnIDogU3RyaW5nKHJhd1ZhbHVlKTtcblxuICBsZXQgbm9kZSA9IHZtLmVsZW1lbnRzKCkuYXBwZW5kRHluYW1pY1RleHQodmFsdWUpO1xuXG4gIGlmICghaXNDb25zdFJlZihyZWZlcmVuY2UpKSB7XG4gICAgdm0udXBkYXRlV2l0aChuZXcgRHluYW1pY1RleHRDb250ZW50KG5vZGUsIHJlZmVyZW5jZSwgdmFsdWUpKTtcbiAgfVxufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5BcHBlbmREb2N1bWVudEZyYWdtZW50LCAodm0pID0+IHtcbiAgbGV0IHJlZmVyZW5jZSA9IGNoZWNrKHZtLnN0YWNrLnBvcCgpLCBDaGVja1JlZmVyZW5jZSk7XG5cbiAgbGV0IHZhbHVlID0gY2hlY2sodmFsdWVGb3JSZWYocmVmZXJlbmNlKSwgQ2hlY2tEb2N1bWVudEZyYWdtZW50KTtcblxuICB2bS5lbGVtZW50cygpLmFwcGVuZER5bmFtaWNGcmFnbWVudCh2YWx1ZSk7XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkFwcGVuZE5vZGUsICh2bSkgPT4ge1xuICBsZXQgcmVmZXJlbmNlID0gY2hlY2sodm0uc3RhY2sucG9wKCksIENoZWNrUmVmZXJlbmNlKTtcblxuICBsZXQgdmFsdWUgPSBjaGVjayh2YWx1ZUZvclJlZihyZWZlcmVuY2UpLCBDaGVja05vZGUpO1xuXG4gIHZtLmVsZW1lbnRzKCkuYXBwZW5kRHluYW1pY05vZGUodmFsdWUpO1xufSk7XG4iLCJpbXBvcnQgeyBPcCwgU2NvcGUgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IFJlZmVyZW5jZSwgY2hpbGRSZWZGb3IsIHZhbHVlRm9yUmVmIH0gZnJvbSAnQGdsaW1tZXIvcmVmZXJlbmNlJztcbmltcG9ydCB7IGRpY3QsIGRlY29kZUhhbmRsZSB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgQVBQRU5EX09QQ09ERVMgfSBmcm9tICcuLi8uLi9vcGNvZGVzJztcbmltcG9ydCB7IENPTlNUQU5UUyB9IGZyb20gJy4uLy4uL3N5bWJvbHMnO1xuXG5leHBvcnQgdHlwZSBEZWJ1Z0dldCA9IChwYXRoOiBzdHJpbmcpID0+IHVua25vd247XG5cbmV4cG9ydCB0eXBlIERlYnVnQ2FsbGJhY2sgPSAoY29udGV4dDogdW5rbm93biwgZ2V0OiBEZWJ1Z0dldCkgPT4gdm9pZDtcblxuZnVuY3Rpb24gZGVidWdDYWxsYmFjayhjb250ZXh0OiB1bmtub3duLCBnZXQ6IERlYnVnR2V0KTogdm9pZCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gIGNvbnNvbGUuaW5mbygnVXNlIGBjb250ZXh0YCwgYW5kIGBnZXQoPHBhdGg+KWAgdG8gZGVidWcgdGhpcyB0ZW1wbGF0ZS4nKTtcblxuICAvLyBmb3IgZXhhbXBsZS4uLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gIGNvbnRleHQgPT09IGdldCgndGhpcycpO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kZWJ1Z2dlclxuICBkZWJ1Z2dlcjtcbn1cblxubGV0IGNhbGxiYWNrID0gZGVidWdDYWxsYmFjaztcblxuLy8gRm9yIHRlc3RpbmcgcHVycG9zZXNcbmV4cG9ydCBmdW5jdGlvbiBzZXREZWJ1Z2dlckNhbGxiYWNrKGNiOiBEZWJ1Z0NhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gY2I7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNldERlYnVnZ2VyQ2FsbGJhY2soKSB7XG4gIGNhbGxiYWNrID0gZGVidWdDYWxsYmFjaztcbn1cblxuY2xhc3MgU2NvcGVJbnNwZWN0b3Ige1xuICBwcml2YXRlIGxvY2FscyA9IGRpY3Q8UmVmZXJlbmNlPigpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgc2NvcGU6IFNjb3BlLCBzeW1ib2xzOiBzdHJpbmdbXSwgZXZhbEluZm86IG51bWJlcltdKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmFsSW5mby5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHNsb3QgPSBldmFsSW5mb1tpXTtcbiAgICAgIGxldCBuYW1lID0gc3ltYm9sc1tzbG90IC0gMV07XG4gICAgICBsZXQgcmVmID0gc2NvcGUuZ2V0U3ltYm9sKHNsb3QpO1xuICAgICAgdGhpcy5sb2NhbHNbbmFtZV0gPSByZWY7XG4gICAgfVxuICB9XG5cbiAgZ2V0KHBhdGg6IHN0cmluZyk6IFJlZmVyZW5jZSB7XG4gICAgbGV0IHsgc2NvcGUsIGxvY2FscyB9ID0gdGhpcztcbiAgICBsZXQgcGFydHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgbGV0IFtoZWFkLCAuLi50YWlsXSA9IHBhdGguc3BsaXQoJy4nKTtcblxuICAgIGxldCBldmFsU2NvcGUgPSBzY29wZS5nZXRFdmFsU2NvcGUoKSE7XG4gICAgbGV0IHJlZjogUmVmZXJlbmNlO1xuXG4gICAgaWYgKGhlYWQgPT09ICd0aGlzJykge1xuICAgICAgcmVmID0gc2NvcGUuZ2V0U2VsZigpO1xuICAgIH0gZWxzZSBpZiAobG9jYWxzW2hlYWRdKSB7XG4gICAgICByZWYgPSBsb2NhbHNbaGVhZF07XG4gICAgfSBlbHNlIGlmIChoZWFkLmluZGV4T2YoJ0AnKSA9PT0gMCAmJiBldmFsU2NvcGVbaGVhZF0pIHtcbiAgICAgIHJlZiA9IGV2YWxTY29wZVtoZWFkXSBhcyBSZWZlcmVuY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZiA9IHRoaXMuc2NvcGUuZ2V0U2VsZigpO1xuICAgICAgdGFpbCA9IHBhcnRzO1xuICAgIH1cblxuICAgIHJldHVybiB0YWlsLnJlZHVjZSgociwgcGFydCkgPT4gY2hpbGRSZWZGb3IociwgcGFydCksIHJlZik7XG4gIH1cbn1cblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkRlYnVnZ2VyLCAodm0sIHsgb3AxOiBfc3ltYm9scywgb3AyOiBfZXZhbEluZm8gfSkgPT4ge1xuICBsZXQgc3ltYm9scyA9IHZtW0NPTlNUQU5UU10uZ2V0QXJyYXk8c3RyaW5nPihfc3ltYm9scyk7XG4gIGxldCBldmFsSW5mbyA9IHZtW0NPTlNUQU5UU10uZ2V0QXJyYXk8bnVtYmVyPihkZWNvZGVIYW5kbGUoX2V2YWxJbmZvKSk7XG4gIGxldCBpbnNwZWN0b3IgPSBuZXcgU2NvcGVJbnNwZWN0b3Iodm0uc2NvcGUoKSwgc3ltYm9scywgZXZhbEluZm8pO1xuICBjYWxsYmFjayh2YWx1ZUZvclJlZih2bS5nZXRTZWxmKCkpLCAocGF0aCkgPT4gdmFsdWVGb3JSZWYoaW5zcGVjdG9yLmdldChwYXRoKSkpO1xufSk7XG4iLCJpbXBvcnQgeyBjcmVhdGVJdGVyYXRvclJlZiwgdmFsdWVGb3JSZWYgfSBmcm9tICdAZ2xpbW1lci9yZWZlcmVuY2UnO1xuaW1wb3J0IHsgQVBQRU5EX09QQ09ERVMgfSBmcm9tICcuLi8uLi9vcGNvZGVzJztcbmltcG9ydCB7IENoZWNrUmVmZXJlbmNlLCBDaGVja0l0ZXJhdG9yIH0gZnJvbSAnLi8tZGVidWctc3RyaXAnO1xuaW1wb3J0IHsgY2hlY2sgfSBmcm9tICdAZ2xpbW1lci9kZWJ1Zyc7XG5pbXBvcnQgeyBPcCB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgQXNzZXJ0RmlsdGVyIH0gZnJvbSAnLi92bSc7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5FbnRlckxpc3QsICh2bSwgeyBvcDE6IHJlbGF0aXZlU3RhcnQsIG9wMjogZWxzZVRhcmdldCB9KSA9PiB7XG4gIGxldCBzdGFjayA9IHZtLnN0YWNrO1xuICBsZXQgbGlzdFJlZiA9IGNoZWNrKHN0YWNrLnBvcCgpLCBDaGVja1JlZmVyZW5jZSk7XG4gIGxldCBrZXlSZWYgPSBjaGVjayhzdGFjay5wb3AoKSwgQ2hlY2tSZWZlcmVuY2UpO1xuXG4gIGxldCBrZXlWYWx1ZSA9IHZhbHVlRm9yUmVmKGtleVJlZik7XG4gIGxldCBrZXkgPSBrZXlWYWx1ZSA9PT0gbnVsbCA/ICdAaWRlbnRpdHknIDogU3RyaW5nKGtleVZhbHVlKTtcblxuICBsZXQgaXRlcmF0b3JSZWYgPSBjcmVhdGVJdGVyYXRvclJlZihsaXN0UmVmLCBrZXkpO1xuICBsZXQgaXRlcmF0b3IgPSB2YWx1ZUZvclJlZihpdGVyYXRvclJlZik7XG5cbiAgdm0udXBkYXRlV2l0aChuZXcgQXNzZXJ0RmlsdGVyKGl0ZXJhdG9yUmVmLCAoaXRlcmF0b3IpID0+IGl0ZXJhdG9yLmlzRW1wdHkoKSkpO1xuXG4gIGlmIChpdGVyYXRvci5pc0VtcHR5KCkgPT09IHRydWUpIHtcbiAgICAvLyBUT0RPOiBGaXggdGhpcyBvZmZzZXQsIHNob3VsZCBiZSBhY2N1cmF0ZVxuICAgIHZtLmdvdG8oZWxzZVRhcmdldCArIDEpO1xuICB9IGVsc2Uge1xuICAgIHZtLmVudGVyTGlzdChpdGVyYXRvclJlZiwgcmVsYXRpdmVTdGFydCk7XG4gICAgdm0uc3RhY2sucHVzaChpdGVyYXRvcik7XG4gIH1cbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuRXhpdExpc3QsICh2bSkgPT4ge1xuICB2bS5leGl0TGlzdCgpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5JdGVyYXRlLCAodm0sIHsgb3AxOiBicmVha3MgfSkgPT4ge1xuICBsZXQgc3RhY2sgPSB2bS5zdGFjaztcbiAgbGV0IGl0ZXJhdG9yID0gY2hlY2soc3RhY2sucGVlaygpLCBDaGVja0l0ZXJhdG9yKTtcbiAgbGV0IGl0ZW0gPSBpdGVyYXRvci5uZXh0KCk7XG5cbiAgaWYgKGl0ZW0gIT09IG51bGwpIHtcbiAgICB2bS5yZWdpc3Rlckl0ZW0odm0uZW50ZXJJdGVtKGl0ZW0pKTtcbiAgfSBlbHNlIHtcbiAgICB2bS5nb3RvKGJyZWFrcyk7XG4gIH1cbn0pO1xuIiwiaW1wb3J0IHsgSW50ZXJuYWxDb21wb25lbnRDYXBhYmlsaXRpZXMsIEludGVybmFsQ29tcG9uZW50TWFuYWdlciB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgTlVMTF9SRUZFUkVOQ0UsIFJlZmVyZW5jZSB9IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQgeyBzZXRJbnRlcm5hbENvbXBvbmVudE1hbmFnZXIgfSBmcm9tICdAZ2xpbW1lci9tYW5hZ2VyJztcblxuY29uc3QgQ0FQQUJJTElUSUVTOiBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdGllcyA9IHtcbiAgZHluYW1pY0xheW91dDogZmFsc2UsXG4gIGR5bmFtaWNUYWc6IGZhbHNlLFxuICBwcmVwYXJlQXJnczogZmFsc2UsXG4gIGNyZWF0ZUFyZ3M6IGZhbHNlLFxuICBhdHRyaWJ1dGVIb29rOiBmYWxzZSxcbiAgZWxlbWVudEhvb2s6IGZhbHNlLFxuICBjcmVhdGVDYWxsZXI6IGZhbHNlLFxuICBkeW5hbWljU2NvcGU6IGZhbHNlLFxuICB1cGRhdGVIb29rOiBmYWxzZSxcbiAgY3JlYXRlSW5zdGFuY2U6IGZhbHNlLFxuICB3cmFwcGVkOiBmYWxzZSxcbiAgd2lsbERlc3Ryb3k6IGZhbHNlLFxuICBoYXNTdWJPd25lcjogZmFsc2UsXG59O1xuXG5leHBvcnQgY2xhc3MgVGVtcGxhdGVPbmx5Q29tcG9uZW50TWFuYWdlciBpbXBsZW1lbnRzIEludGVybmFsQ29tcG9uZW50TWFuYWdlciB7XG4gIGdldENhcGFiaWxpdGllcygpOiBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdGllcyB7XG4gICAgcmV0dXJuIENBUEFCSUxJVElFUztcbiAgfVxuXG4gIGdldERlYnVnTmFtZSh7IG5hbWUgfTogVGVtcGxhdGVPbmx5Q29tcG9uZW50RGVmaW5pdGlvbik6IHN0cmluZyB7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cblxuICBnZXRTZWxmKCk6IFJlZmVyZW5jZSB7XG4gICAgcmV0dXJuIE5VTExfUkVGRVJFTkNFO1xuICB9XG5cbiAgZ2V0RGVzdHJveWFibGUoKTogbnVsbCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IFRFTVBMQVRFX09OTFlfQ09NUE9ORU5UX01BTkFHRVIgPSBuZXcgVGVtcGxhdGVPbmx5Q29tcG9uZW50TWFuYWdlcigpO1xuXG4vLyBUaGlzIGlzIG9ubHkgZXhwb3J0ZWQgZm9yIHR5cGVzLCBkb24ndCB1c2UgdGhpcyBjbGFzcyBkaXJlY3RseVxuZXhwb3J0IGNsYXNzIFRlbXBsYXRlT25seUNvbXBvbmVudERlZmluaXRpb24ge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgbW9kdWxlTmFtZSA9ICdAZ2xpbW1lci9jb21wb25lbnQvdGVtcGxhdGUtb25seScsXG4gICAgcHVibGljIG5hbWUgPSAnKHVua25vd24gdGVtcGxhdGUtb25seSBjb21wb25lbnQpJ1xuICApIHt9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlTmFtZTtcbiAgfVxufVxuXG5zZXRJbnRlcm5hbENvbXBvbmVudE1hbmFnZXIoXG4gIFRFTVBMQVRFX09OTFlfQ09NUE9ORU5UX01BTkFHRVIsXG4gIFRlbXBsYXRlT25seUNvbXBvbmVudERlZmluaXRpb24ucHJvdG90eXBlXG4pO1xuXG4vKipcbiAgVGhpcyB1dGlsaXR5IGZ1bmN0aW9uIGlzIHVzZWQgdG8gZGVjbGFyZSBhIGdpdmVuIGNvbXBvbmVudCBoYXMgbm8gYmFja2luZyBjbGFzcy4gV2hlbiB0aGUgcmVuZGVyaW5nIGVuZ2luZSBkZXRlY3RzIHRoaXMgaXRcbiAgaXMgYWJsZSB0byBwZXJmb3JtIGEgbnVtYmVyIG9mIG9wdGltaXphdGlvbnMuIFRlbXBsYXRlcyB0aGF0IGFyZSBhc3NvY2lhdGVkIHdpdGggYHRlbXBsYXRlT25seSgpYCB3aWxsIGJlIHJlbmRlcmVkIF9hcyBpc19cbiAgd2l0aG91dCBhZGRpbmcgYSB3cmFwcGluZyBgPGRpdj5gIChvciBhbnkgb2YgdGhlIG90aGVyIGVsZW1lbnQgY3VzdG9taXphdGlvbiBiZWhhdmlvcnMgb2YgW0BlbWJlci9jb21wb25lbnRdKC9lbWJlci9yZWxlYXNlL2NsYXNzZXMvQ29tcG9uZW50KSkuXG4gIFNwZWNpZmljYWxseSwgdGhpcyBtZWFucyB0aGF0IHRoZSB0ZW1wbGF0ZSB3aWxsIGJlIHJlbmRlcmVkIGFzIFwib3V0ZXIgSFRNTFwiLlxuXG4gIEluIGdlbmVyYWwsIHRoaXMgbWV0aG9kIHdpbGwgYmUgdXNlZCBieSBidWlsZCB0aW1lIHRvb2xpbmcgYW5kIHdvdWxkIG5vdCBiZSBkaXJlY3RseSB3cml0dGVuIGluIGFuIGFwcGxpY2F0aW9uLiBIb3dldmVyLFxuICBhdCB0aW1lcyBpdCBtYXkgYmUgdXNlZnVsIHRvIHVzZSBkaXJlY3RseSB0byBsZXZlcmFnZSB0aGUgXCJvdXRlciBIVE1MXCIgc2VtYW50aWNzIG1lbnRpb25lZCBhYm92ZS4gRm9yIGV4YW1wbGUsIGlmIGFuIGFkZG9uIHdvdWxkIGxpa2VcbiAgdG8gdXNlIHRoZXNlIHNlbWFudGljcyBmb3IgaXRzIHRlbXBsYXRlcyBidXQgY2Fubm90IGJlIGNlcnRhaW4gaXQgd2lsbCBvbmx5IGJlIGNvbnN1bWVkIGJ5IGFwcGxpY2F0aW9ucyB0aGF0IGhhdmUgZW5hYmxlZCB0aGVcbiAgYHRlbXBsYXRlLW9ubHktZ2xpbW1lci1jb21wb25lbnRzYCBvcHRpb25hbCBmZWF0dXJlLlxuXG4gIEBleGFtcGxlXG5cbiAgYGBganNcbiAgaW1wb3J0IHsgdGVtcGxhdGVPbmx5Q29tcG9uZW50IH0gZnJvbSAnQGdsaW1tZXIvcnVudGltZSc7XG5cbiAgZXhwb3J0IGRlZmF1bHQgdGVtcGxhdGVPbmx5Q29tcG9uZW50KCk7XG4gIGBgYFxuXG4gIEBwdWJsaWNcbiAgQG1ldGhvZCB0ZW1wbGF0ZU9ubHlcbiAgQHBhcmFtIHtTdHJpbmd9IG1vZHVsZU5hbWUgdGhlIG1vZHVsZSBuYW1lIHRoYXQgdGhlIHRlbXBsYXRlIG9ubHkgY29tcG9uZW50IHJlcHJlc2VudHMsIHRoaXMgd2lsbCBiZSB1c2VkIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXNcbiAgQGNhdGVnb3J5IEVNQkVSX0dMSU1NRVJfU0VUX0NPTVBPTkVOVF9URU1QTEFURVxuKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlT25seUNvbXBvbmVudChcbiAgbW9kdWxlTmFtZT86IHN0cmluZyxcbiAgbmFtZT86IHN0cmluZ1xuKTogVGVtcGxhdGVPbmx5Q29tcG9uZW50RGVmaW5pdGlvbiB7XG4gIHJldHVybiBuZXcgVGVtcGxhdGVPbmx5Q29tcG9uZW50RGVmaW5pdGlvbihtb2R1bGVOYW1lLCBuYW1lKTtcbn1cbiIsImltcG9ydCB7XG4gIFNpbXBsZUVsZW1lbnQsXG4gIFNpbXBsZURvY3VtZW50LFxuICBOYW1lc3BhY2UsXG4gIFNpbXBsZU5vZGUsXG4gIEluc2VydFBvc2l0aW9uLFxuICBTaW1wbGVUZXh0LFxuICBTaW1wbGVDb21tZW50LFxufSBmcm9tICdAc2ltcGxlLWRvbS9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgRGljdCwgT3B0aW9uLCBCb3VuZHMgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IENvbmNyZXRlQm91bmRzIH0gZnJvbSAnLi4vYm91bmRzJztcbmltcG9ydCB7IGV4cGVjdCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sL3N5bnRheC5odG1sI2h0bWwtaW50ZWdyYXRpb24tcG9pbnRcbmNvbnN0IFNWR19JTlRFR1JBVElPTl9QT0lOVFMgPSB7IGZvcmVpZ25PYmplY3Q6IDEsIGRlc2M6IDEsIHRpdGxlOiAxIH07XG5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWwvc3ludGF4Lmh0bWwjYWRqdXN0LXN2Zy1hdHRyaWJ1dGVzXG4vLyBUT0RPOiBBZGp1c3QgU1ZHIGF0dHJpYnV0ZXNcblxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbC9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5mb3JlaWduXG4vLyBUT0RPOiBBZGp1c3QgU1ZHIGVsZW1lbnRzXG5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWwvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluZm9yZWlnblxuZXhwb3J0IGNvbnN0IEJMQUNLTElTVF9UQUJMRSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmV4cG9ydCBjbGFzcyBET01PcGVyYXRpb25zIHtcbiAgcHJvdGVjdGVkIHVzZWxlc3NFbGVtZW50ITogU2ltcGxlRWxlbWVudDsgLy8gU2V0IGJ5IHRoaXMuc2V0dXBVc2VsZXNzRWxlbWVudCgpIGluIGNvbnN0cnVjdG9yXG5cbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIGRvY3VtZW50OiBTaW1wbGVEb2N1bWVudCkge1xuICAgIHRoaXMuc2V0dXBVc2VsZXNzRWxlbWVudCgpO1xuICB9XG5cbiAgLy8gc3BsaXQgaW50byBzZXBhcmF0ZSBtZXRob2Qgc28gdGhhdCBOb2RlRE9NVHJlZUNvbnN0cnVjdGlvblxuICAvLyBjYW4gb3ZlcnJpZGUgaXQuXG4gIHByb3RlY3RlZCBzZXR1cFVzZWxlc3NFbGVtZW50KCkge1xuICAgIHRoaXMudXNlbGVzc0VsZW1lbnQgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB9XG5cbiAgY3JlYXRlRWxlbWVudCh0YWc6IHN0cmluZywgY29udGV4dD86IFNpbXBsZUVsZW1lbnQpOiBTaW1wbGVFbGVtZW50IHtcbiAgICBsZXQgaXNFbGVtZW50SW5TVkdOYW1lc3BhY2U6IGJvb2xlYW4sIGlzSFRNTEludGVncmF0aW9uUG9pbnQ6IGJvb2xlYW47XG5cbiAgICBpZiAoY29udGV4dCkge1xuICAgICAgaXNFbGVtZW50SW5TVkdOYW1lc3BhY2UgPSBjb250ZXh0Lm5hbWVzcGFjZVVSSSA9PT0gTmFtZXNwYWNlLlNWRyB8fCB0YWcgPT09ICdzdmcnO1xuICAgICAgaXNIVE1MSW50ZWdyYXRpb25Qb2ludCA9ICEhKFNWR19JTlRFR1JBVElPTl9QT0lOVFMgYXMgRGljdDxudW1iZXI+KVtjb250ZXh0LnRhZ05hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc0VsZW1lbnRJblNWR05hbWVzcGFjZSA9IHRhZyA9PT0gJ3N2Zyc7XG4gICAgICBpc0hUTUxJbnRlZ3JhdGlvblBvaW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlzRWxlbWVudEluU1ZHTmFtZXNwYWNlICYmICFpc0hUTUxJbnRlZ3JhdGlvblBvaW50KSB7XG4gICAgICAvLyBGSVhNRTogVGhpcyBkb2VzIG5vdCBwcm9wZXJseSBoYW5kbGUgPGZvbnQ+IHdpdGggY29sb3IsIGZhY2UsIG9yXG4gICAgICAvLyBzaXplIGF0dHJpYnV0ZXMsIHdoaWNoIGlzIGFsc28gZGlzYWxsb3dlZCBieSB0aGUgc3BlYy4gV2Ugc2hvdWxkIGZpeFxuICAgICAgLy8gdGhpcy5cbiAgICAgIGlmIChCTEFDS0xJU1RfVEFCTEVbdGFnXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjcmVhdGUgYSAke3RhZ30gaW5zaWRlIGFuIFNWRyBjb250ZXh0YCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhOYW1lc3BhY2UuU1ZHLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgfVxuICB9XG5cbiAgaW5zZXJ0QmVmb3JlKHBhcmVudDogU2ltcGxlRWxlbWVudCwgbm9kZTogU2ltcGxlTm9kZSwgcmVmZXJlbmNlOiBPcHRpb248U2ltcGxlTm9kZT4pIHtcbiAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIHJlZmVyZW5jZSk7XG4gIH1cblxuICBpbnNlcnRIVE1MQmVmb3JlKHBhcmVudDogU2ltcGxlRWxlbWVudCwgbmV4dFNpYmxpbmc6IE9wdGlvbjxTaW1wbGVOb2RlPiwgaHRtbDogc3RyaW5nKTogQm91bmRzIHtcbiAgICBpZiAoaHRtbCA9PT0gJycpIHtcbiAgICAgIGxldCBjb21tZW50ID0gdGhpcy5jcmVhdGVDb21tZW50KCcnKTtcbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY29tbWVudCwgbmV4dFNpYmxpbmcpO1xuICAgICAgcmV0dXJuIG5ldyBDb25jcmV0ZUJvdW5kcyhwYXJlbnQsIGNvbW1lbnQsIGNvbW1lbnQpO1xuICAgIH1cblxuICAgIGxldCBwcmV2ID0gbmV4dFNpYmxpbmcgPyBuZXh0U2libGluZy5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnQubGFzdENoaWxkO1xuICAgIGxldCBsYXN0OiBTaW1wbGVOb2RlO1xuXG4gICAgaWYgKG5leHRTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBwYXJlbnQuaW5zZXJ0QWRqYWNlbnRIVE1MKEluc2VydFBvc2l0aW9uLmJlZm9yZWVuZCwgaHRtbCk7XG4gICAgICBsYXN0ID0gZXhwZWN0KHBhcmVudC5sYXN0Q2hpbGQsICdidWcgaW4gaW5zZXJ0QWRqYWNlbnRIVE1MPycpO1xuICAgIH0gZWxzZSBpZiAobmV4dFNpYmxpbmcgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgbmV4dFNpYmxpbmcuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmViZWdpbicsIGh0bWwpO1xuICAgICAgbGFzdCA9IGV4cGVjdChuZXh0U2libGluZy5wcmV2aW91c1NpYmxpbmcsICdidWcgaW4gaW5zZXJ0QWRqYWNlbnRIVE1MPycpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOb24tZWxlbWVudCBub2RlcyBkbyBub3Qgc3VwcG9ydCBpbnNlcnRBZGphY2VudEhUTUwsIHNvIGFkZCBhblxuICAgICAgLy8gZWxlbWVudCBhbmQgY2FsbCBpdCBvbiB0aGF0IGVsZW1lbnQuIFRoZW4gcmVtb3ZlIHRoZSBlbGVtZW50LlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgYWxzbyBwcm90ZWN0cyBFZGdlLCBJRSBhbmQgRmlyZWZveCB3L28gdGhlIGluc3BlY3RvciBvcGVuXG4gICAgICAvLyBmcm9tIG1lcmdpbmcgYWRqYWNlbnQgdGV4dCBub2Rlcy4gU2VlIC4vY29tcGF0L3RleHQtbm9kZS1tZXJnaW5nLWZpeC50c1xuICAgICAgbGV0IHsgdXNlbGVzc0VsZW1lbnQgfSA9IHRoaXM7XG5cbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodXNlbGVzc0VsZW1lbnQsIG5leHRTaWJsaW5nKTtcbiAgICAgIHVzZWxlc3NFbGVtZW50Lmluc2VydEFkamFjZW50SFRNTChJbnNlcnRQb3NpdGlvbi5iZWZvcmViZWdpbiwgaHRtbCk7XG4gICAgICBsYXN0ID0gZXhwZWN0KHVzZWxlc3NFbGVtZW50LnByZXZpb3VzU2libGluZywgJ2J1ZyBpbiBpbnNlcnRBZGphY2VudEhUTUw/Jyk7XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodXNlbGVzc0VsZW1lbnQpO1xuICAgIH1cblxuICAgIGxldCBmaXJzdCA9IGV4cGVjdChwcmV2ID8gcHJldi5uZXh0U2libGluZyA6IHBhcmVudC5maXJzdENoaWxkLCAnYnVnIGluIGluc2VydEFkamFjZW50SFRNTD8nKTtcbiAgICByZXR1cm4gbmV3IENvbmNyZXRlQm91bmRzKHBhcmVudCwgZmlyc3QsIGxhc3QpO1xuICB9XG5cbiAgY3JlYXRlVGV4dE5vZGUodGV4dDogc3RyaW5nKTogU2ltcGxlVGV4dCB7XG4gICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG4gIH1cblxuICBjcmVhdGVDb21tZW50KGRhdGE6IHN0cmluZyk6IFNpbXBsZUNvbW1lbnQge1xuICAgIHJldHVybiB0aGlzLmRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoZGF0YSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1vdmVOb2Rlc0JlZm9yZShcbiAgc291cmNlOiBTaW1wbGVOb2RlLFxuICB0YXJnZXQ6IFNpbXBsZUVsZW1lbnQsXG4gIG5leHRTaWJsaW5nOiBPcHRpb248U2ltcGxlTm9kZT5cbik6IEJvdW5kcyB7XG4gIGxldCBmaXJzdCA9IGV4cGVjdChzb3VyY2UuZmlyc3RDaGlsZCwgJ3NvdXJjZSBpcyBlbXB0eScpO1xuICBsZXQgbGFzdDogU2ltcGxlTm9kZSA9IGZpcnN0O1xuICBsZXQgY3VycmVudDogT3B0aW9uPFNpbXBsZU5vZGU+ID0gZmlyc3Q7XG5cbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBsZXQgbmV4dDogT3B0aW9uPFNpbXBsZU5vZGU+ID0gY3VycmVudC5uZXh0U2libGluZztcblxuICAgIHRhcmdldC5pbnNlcnRCZWZvcmUoY3VycmVudCwgbmV4dFNpYmxpbmcpO1xuXG4gICAgbGFzdCA9IGN1cnJlbnQ7XG4gICAgY3VycmVudCA9IG5leHQ7XG4gIH1cblxuICByZXR1cm4gbmV3IENvbmNyZXRlQm91bmRzKHRhcmdldCwgZmlyc3QsIGxhc3QpO1xufVxuIiwiaW1wb3J0IHsgQm91bmRzLCBPcHRpb24gfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGFzc2VydCwgY2FzdFRvQnJvd3NlciwgY2xlYXJFbGVtZW50LCB1bndyYXAgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7XG4gIEluc2VydFBvc2l0aW9uLFxuICBOYW1lc3BhY2UsXG4gIFNpbXBsZURvY3VtZW50LFxuICBTaW1wbGVFbGVtZW50LFxuICBTaW1wbGVOb2RlLFxufSBmcm9tICdAc2ltcGxlLWRvbS9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgRE9NT3BlcmF0aW9ucywgbW92ZU5vZGVzQmVmb3JlIH0gZnJvbSAnLi4vZG9tL29wZXJhdGlvbnMnO1xuXG5leHBvcnQgY29uc3QgU1ZHX05BTUVTUEFDRSA9IE5hbWVzcGFjZS5TVkc7XG5leHBvcnQgdHlwZSBTVkdfTkFNRVNQQUNFID0gdHlwZW9mIFNWR19OQU1FU1BBQ0U7XG5cbi8vIFBhdGNoOiAgICBpbnNlcnRBZGphY2VudEhUTUwgb24gU1ZHIEZpeFxuLy8gQnJvd3NlcnM6IFNhZmFyaSwgSUUsIEVkZ2UsIEZpcmVmb3ggfjMzLTM0XG4vLyBSZWFzb246ICAgaW5zZXJ0QWRqYWNlbnRIVE1MIGRvZXMgbm90IGV4aXN0IG9uIFNWRyBlbGVtZW50cyBpbiBTYWZhcmkuIEl0IGlzXG4vLyAgICAgICAgICAgcHJlc2VudCBidXQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBvbiBJRSBhbmQgRWRnZS4gT2xkIHZlcnNpb25zIG9mXG4vLyAgICAgICAgICAgRmlyZWZveCBjcmVhdGUgbm9kZXMgaW4gdGhlIGluY29ycmVjdCBuYW1lc3BhY2UuXG4vLyBGaXg6ICAgICAgU2luY2UgSUUgYW5kIEVkZ2Ugc2lsZW50bHkgZmFpbCB0byBjcmVhdGUgU1ZHIG5vZGVzIHVzaW5nXG4vLyAgICAgICAgICAgaW5uZXJIVE1MLCBhbmQgYmVjYXVzZSBGaXJlZm94IG1heSBjcmVhdGUgbm9kZXMgaW4gdGhlIGluY29ycmVjdFxuLy8gICAgICAgICAgIG5hbWVzcGFjZSB1c2luZyBpbm5lckhUTUwgb24gU1ZHIGVsZW1lbnRzLCBhbiBIVE1MLXN0cmluZyB3cmFwcGluZ1xuLy8gICAgICAgICAgIGFwcHJvYWNoIGlzIHVzZWQuIEEgcHJlL3Bvc3QgU1ZHIHRhZyBpcyBhZGRlZCB0byB0aGUgc3RyaW5nLCB0aGVuXG4vLyAgICAgICAgICAgdGhhdCB3aG9sZSBzdHJpbmcgaXMgYWRkZWQgdG8gYSBkaXYuIFRoZSBjcmVhdGVkIG5vZGVzIGFyZSBwbHVja2VkXG4vLyAgICAgICAgICAgb3V0IGFuZCBhcHBsaWVkIHRvIHRoZSB0YXJnZXQgbG9jYXRpb24gb24gRE9NLlxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5U1ZHSW5uZXJIVE1MRml4KFxuICBkb2N1bWVudDogT3B0aW9uPFNpbXBsZURvY3VtZW50PixcbiAgRE9NQ2xhc3M6IHR5cGVvZiBET01PcGVyYXRpb25zLFxuICBzdmdOYW1lc3BhY2U6IFNWR19OQU1FU1BBQ0Vcbik6IHR5cGVvZiBET01PcGVyYXRpb25zIHtcbiAgaWYgKCFkb2N1bWVudCkgcmV0dXJuIERPTUNsYXNzO1xuXG4gIGlmICghc2hvdWxkQXBwbHlGaXgoZG9jdW1lbnQsIHN2Z05hbWVzcGFjZSkpIHtcbiAgICByZXR1cm4gRE9NQ2xhc3M7XG4gIH1cblxuICBsZXQgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykgYXMgU2ltcGxlRWxlbWVudDtcblxuICByZXR1cm4gY2xhc3MgRE9NQ2hhbmdlc1dpdGhTVkdJbm5lckhUTUxGaXggZXh0ZW5kcyBET01DbGFzcyB7XG4gICAgaW5zZXJ0SFRNTEJlZm9yZShwYXJlbnQ6IFNpbXBsZUVsZW1lbnQsIG5leHRTaWJsaW5nOiBPcHRpb248U2ltcGxlTm9kZT4sIGh0bWw6IHN0cmluZyk6IEJvdW5kcyB7XG4gICAgICBpZiAoaHRtbCA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmluc2VydEhUTUxCZWZvcmUocGFyZW50LCBuZXh0U2libGluZywgaHRtbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJICE9PSBzdmdOYW1lc3BhY2UpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmluc2VydEhUTUxCZWZvcmUocGFyZW50LCBuZXh0U2libGluZywgaHRtbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmaXhTVkcocGFyZW50LCBkaXYsIGh0bWwsIG5leHRTaWJsaW5nKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZpeFNWRyhcbiAgcGFyZW50OiBTaW1wbGVFbGVtZW50LFxuICBkaXY6IFNpbXBsZUVsZW1lbnQsXG4gIGh0bWw6IHN0cmluZyxcbiAgcmVmZXJlbmNlOiBPcHRpb248U2ltcGxlTm9kZT5cbik6IEJvdW5kcyB7XG4gIGFzc2VydChodG1sICE9PSAnJywgJ2h0bWwgY2Fubm90IGJlIGVtcHR5Jyk7XG5cbiAgbGV0IHNvdXJjZTogU2ltcGxlTm9kZTtcblxuICAvLyBUaGlzIGlzIGltcG9ydGFudCwgYmVjYXVzZSBkZXNjZW5kYW50cyBvZiB0aGUgPGZvcmVpZ25PYmplY3Q+IGludGVncmF0aW9uXG4gIC8vIHBvaW50IGFyZSBwYXJzZWQgaW4gdGhlIEhUTUwgbmFtZXNwYWNlXG4gIGlmIChwYXJlbnQudGFnTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnRk9SRUlHTk9CSkVDVCcpIHtcbiAgICAvLyBJRSwgRWRnZTogYWxzbyBkbyBub3QgY29ycmVjdGx5IHN1cHBvcnQgdXNpbmcgYGlubmVySFRNTGAgb24gU1ZHXG4gICAgLy8gbmFtZXNwYWNlZCBlbGVtZW50cy4gU28gaGVyZSBhIHdyYXBwZXIgaXMgdXNlZC5cbiAgICBsZXQgd3JhcHBlZEh0bWwgPSAnPHN2Zz48Zm9yZWlnbk9iamVjdD4nICsgaHRtbCArICc8L2ZvcmVpZ25PYmplY3Q+PC9zdmc+JztcblxuICAgIGNsZWFyRWxlbWVudChkaXYpO1xuICAgIGRpdi5pbnNlcnRBZGphY2VudEhUTUwoSW5zZXJ0UG9zaXRpb24uYWZ0ZXJiZWdpbiwgd3JhcHBlZEh0bWwpO1xuXG4gICAgc291cmNlID0gZGl2LmZpcnN0Q2hpbGQhLmZpcnN0Q2hpbGQhO1xuICB9IGVsc2Uge1xuICAgIC8vIElFLCBFZGdlOiBhbHNvIGRvIG5vdCBjb3JyZWN0bHkgc3VwcG9ydCB1c2luZyBgaW5uZXJIVE1MYCBvbiBTVkdcbiAgICAvLyBuYW1lc3BhY2VkIGVsZW1lbnRzLiBTbyBoZXJlIGEgd3JhcHBlciBpcyB1c2VkLlxuICAgIGxldCB3cmFwcGVkSHRtbCA9ICc8c3ZnPicgKyBodG1sICsgJzwvc3ZnPic7XG5cbiAgICBjbGVhckVsZW1lbnQoZGl2KTtcbiAgICBkaXYuaW5zZXJ0QWRqYWNlbnRIVE1MKEluc2VydFBvc2l0aW9uLmFmdGVyYmVnaW4sIHdyYXBwZWRIdG1sKTtcblxuICAgIHNvdXJjZSA9IGRpdi5maXJzdENoaWxkITtcbiAgfVxuXG4gIHJldHVybiBtb3ZlTm9kZXNCZWZvcmUoc291cmNlLCBwYXJlbnQsIHJlZmVyZW5jZSk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZEFwcGx5Rml4KGRvY3VtZW50OiBTaW1wbGVEb2N1bWVudCwgc3ZnTmFtZXNwYWNlOiBTVkdfTkFNRVNQQUNFKSB7XG4gIGxldCBzdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnTmFtZXNwYWNlLCAnc3ZnJyk7XG5cbiAgdHJ5IHtcbiAgICBzdmcuaW5zZXJ0QWRqYWNlbnRIVE1MKEluc2VydFBvc2l0aW9uLmJlZm9yZWVuZCwgJzxjaXJjbGU+PC9jaXJjbGU+Jyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJRSwgRWRnZTogV2lsbCB0aHJvdywgaW5zZXJ0QWRqYWNlbnRIVE1MIGlzIHVuc3VwcG9ydGVkIG9uIFNWR1xuICAgIC8vIFNhZmFyaTogV2lsbCB0aHJvdywgaW5zZXJ0QWRqYWNlbnRIVE1MIGlzIG5vdCBwcmVzZW50IG9uIFNWR1xuICB9IGZpbmFsbHkge1xuICAgIC8vIEZGOiBPbGQgdmVyc2lvbnMgd2lsbCBjcmVhdGUgYSBub2RlIGluIHRoZSB3cm9uZyBuYW1lc3BhY2VcbiAgICBpZiAoXG4gICAgICBzdmcuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgIGNhc3RUb0Jyb3dzZXIodW53cmFwKHN2Zy5maXJzdENoaWxkKSwgJ1NWRycpLm5hbWVzcGFjZVVSSSA9PT0gU1ZHX05BTUVTUEFDRVxuICAgICkge1xuICAgICAgLy8gVGhlIHRlc3Qgd29ya2VkIGFzIGV4cGVjdGVkLCBubyBmaXggcmVxdWlyZWRcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgQm91bmRzLCBPcHRpb24gfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7XG4gIEluc2VydFBvc2l0aW9uLFxuICBTaW1wbGVDb21tZW50LFxuICBTaW1wbGVEb2N1bWVudCxcbiAgU2ltcGxlRWxlbWVudCxcbiAgU2ltcGxlTm9kZSxcbn0gZnJvbSAnQHNpbXBsZS1kb20vaW50ZXJmYWNlJztcbmltcG9ydCB7IERPTU9wZXJhdGlvbnMgfSBmcm9tICcuLi9kb20vb3BlcmF0aW9ucyc7XG5cbi8vIFBhdGNoOiAgICBBZGphY2VudCB0ZXh0IG5vZGUgbWVyZ2luZyBmaXhcbi8vIEJyb3dzZXJzOiBJRSwgRWRnZSwgRmlyZWZveCB3L28gaW5zcGVjdG9yIG9wZW5cbi8vIFJlYXNvbjogICBUaGVzZSBicm93c2VycyB3aWxsIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXMuIEZvciBleGFtcGxlIGdpdmVuXG4vLyAgICAgICAgICAgPGRpdj5IZWxsbzwvZGl2PiB3aXRoIGRpdi5pbnNlcnRBZGphY2VudEhUTUwoJyB3b3JsZCcpIGJyb3dzZXJzXG4vLyAgICAgICAgICAgd2l0aCBwcm9wZXIgYmVoYXZpb3Igd2lsbCBwb3B1bGF0ZSBkaXYuY2hpbGROb2RlcyB3aXRoIHR3byBpdGVtcy5cbi8vICAgICAgICAgICBUaGVzZSBicm93c2VycyB3aWxsIHBvcHVsYXRlIGl0IHdpdGggb25lIG1lcmdlZCBub2RlIGluc3RlYWQuXG4vLyBGaXg6ICAgICAgQWRkIHRoZXNlIG5vZGVzIHRvIGEgd3JhcHBlciBlbGVtZW50LCB0aGVuIGl0ZXJhdGUgdGhlIGNoaWxkTm9kZXNcbi8vICAgICAgICAgICBvZiB0aGF0IHdyYXBwZXIgYW5kIG1vdmUgdGhlIG5vZGVzIHRvIHRoZWlyIHRhcmdldCBsb2NhdGlvbi4gTm90ZVxuLy8gICAgICAgICAgIHRoYXQgcG90ZW50aWFsIFNWRyBidWdzIHdpbGwgaGF2ZSBiZWVuIGhhbmRsZWQgYmVmb3JlIHRoaXMgZml4LlxuLy8gICAgICAgICAgIE5vdGUgdGhhdCB0aGlzIGZpeCBtdXN0IG9ubHkgYXBwbHkgdG8gdGhlIHByZXZpb3VzIHRleHQgbm9kZSwgYXNcbi8vICAgICAgICAgICB0aGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgaW5zZXJ0SFRNTEJlZm9yZWAgYWxyZWFkeSBoYW5kbGVzXG4vLyAgICAgICAgICAgZm9sbG93aW5nIHRleHQgbm9kZXMgY29ycmVjdGx5LlxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5VGV4dE5vZGVNZXJnaW5nRml4KFxuICBkb2N1bWVudDogT3B0aW9uPFNpbXBsZURvY3VtZW50PixcbiAgRE9NQ2xhc3M6IHR5cGVvZiBET01PcGVyYXRpb25zXG4pOiB0eXBlb2YgRE9NT3BlcmF0aW9ucyB7XG4gIGlmICghZG9jdW1lbnQpIHJldHVybiBET01DbGFzcztcblxuICBpZiAoIXNob3VsZEFwcGx5Rml4KGRvY3VtZW50KSkge1xuICAgIHJldHVybiBET01DbGFzcztcbiAgfVxuXG4gIHJldHVybiBjbGFzcyBET01DaGFuZ2VzV2l0aFRleHROb2RlTWVyZ2luZ0ZpeCBleHRlbmRzIERPTUNsYXNzIHtcbiAgICBwcml2YXRlIHVzZWxlc3NDb21tZW50OiBTaW1wbGVDb21tZW50O1xuXG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQ6IFNpbXBsZURvY3VtZW50KSB7XG4gICAgICBzdXBlcihkb2N1bWVudCk7XG4gICAgICB0aGlzLnVzZWxlc3NDb21tZW50ID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnJyk7XG4gICAgfVxuXG4gICAgaW5zZXJ0SFRNTEJlZm9yZShwYXJlbnQ6IFNpbXBsZUVsZW1lbnQsIG5leHRTaWJsaW5nOiBPcHRpb248U2ltcGxlTm9kZT4sIGh0bWw6IHN0cmluZyk6IEJvdW5kcyB7XG4gICAgICBpZiAoaHRtbCA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmluc2VydEhUTUxCZWZvcmUocGFyZW50LCBuZXh0U2libGluZywgaHRtbCk7XG4gICAgICB9XG5cbiAgICAgIGxldCBkaWRTZXRVc2VsZXNzQ29tbWVudCA9IGZhbHNlO1xuXG4gICAgICBsZXQgbmV4dFByZXZpb3VzID0gbmV4dFNpYmxpbmcgPyBuZXh0U2libGluZy5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnQubGFzdENoaWxkO1xuXG4gICAgICBpZiAobmV4dFByZXZpb3VzICYmIG5leHRQcmV2aW91cyBpbnN0YW5jZW9mIFRleHQpIHtcbiAgICAgICAgZGlkU2V0VXNlbGVzc0NvbW1lbnQgPSB0cnVlO1xuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMudXNlbGVzc0NvbW1lbnQsIG5leHRTaWJsaW5nKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGJvdW5kcyA9IHN1cGVyLmluc2VydEhUTUxCZWZvcmUocGFyZW50LCBuZXh0U2libGluZywgaHRtbCk7XG5cbiAgICAgIGlmIChkaWRTZXRVc2VsZXNzQ29tbWVudCkge1xuICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy51c2VsZXNzQ29tbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBib3VuZHM7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBzaG91bGRBcHBseUZpeChkb2N1bWVudDogU2ltcGxlRG9jdW1lbnQpIHtcbiAgbGV0IG1lcmdpbmdUZXh0RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgbWVyZ2luZ1RleHREaXYuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ2ZpcnN0JykpO1xuICBtZXJnaW5nVGV4dERpdi5pbnNlcnRBZGphY2VudEhUTUwoSW5zZXJ0UG9zaXRpb24uYmVmb3JlZW5kLCAnc2Vjb25kJyk7XG5cbiAgaWYgKG1lcmdpbmdUZXh0RGl2LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyKSB7XG4gICAgLy8gSXQgd29ya2VkIGFzIGV4cGVjdGVkLCBubyBmaXggcmVxdWlyZWRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbiIsImltcG9ydCB7IEdsaW1tZXJUcmVlQ2hhbmdlcywgR2xpbW1lclRyZWVDb25zdHJ1Y3Rpb24sIE9wdGlvbiB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgY2FzdFRvU2ltcGxlIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQge1xuICBBdHRyTmFtZXNwYWNlLFxuICBFbGVtZW50TmFtZXNwYWNlLFxuICBOYW1lc3BhY2UsXG4gIFNpbXBsZURvY3VtZW50LFxuICBTaW1wbGVFbGVtZW50LFxuICBTaW1wbGVOb2RlLFxufSBmcm9tICdAc2ltcGxlLWRvbS9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgYXBwbHlTVkdJbm5lckhUTUxGaXggfSBmcm9tICcuLi9jb21wYXQvc3ZnLWlubmVyLWh0bWwtZml4JztcbmltcG9ydCB7IGFwcGx5VGV4dE5vZGVNZXJnaW5nRml4IH0gZnJvbSAnLi4vY29tcGF0L3RleHQtbm9kZS1tZXJnaW5nLWZpeCc7XG5pbXBvcnQgeyBCTEFDS0xJU1RfVEFCTEUsIERPTU9wZXJhdGlvbnMgfSBmcm9tICcuL29wZXJhdGlvbnMnO1xuXG5bXG4gICdiJyxcbiAgJ2JpZycsXG4gICdibG9ja3F1b3RlJyxcbiAgJ2JvZHknLFxuICAnYnInLFxuICAnY2VudGVyJyxcbiAgJ2NvZGUnLFxuICAnZGQnLFxuICAnZGl2JyxcbiAgJ2RsJyxcbiAgJ2R0JyxcbiAgJ2VtJyxcbiAgJ2VtYmVkJyxcbiAgJ2gxJyxcbiAgJ2gyJyxcbiAgJ2gzJyxcbiAgJ2g0JyxcbiAgJ2g1JyxcbiAgJ2g2JyxcbiAgJ2hlYWQnLFxuICAnaHInLFxuICAnaScsXG4gICdpbWcnLFxuICAnbGknLFxuICAnbGlzdGluZycsXG4gICdtYWluJyxcbiAgJ21ldGEnLFxuICAnbm9icicsXG4gICdvbCcsXG4gICdwJyxcbiAgJ3ByZScsXG4gICdydWJ5JyxcbiAgJ3MnLFxuICAnc21hbGwnLFxuICAnc3BhbicsXG4gICdzdHJvbmcnLFxuICAnc3RyaWtlJyxcbiAgJ3N1YicsXG4gICdzdXAnLFxuICAndGFibGUnLFxuICAndHQnLFxuICAndScsXG4gICd1bCcsXG4gICd2YXInLFxuXS5mb3JFYWNoKCh0YWcpID0+IChCTEFDS0xJU1RfVEFCTEVbdGFnXSA9IDEpKTtcblxuY29uc3QgV0hJVEVTUEFDRSA9IC9bXFx0LVxcciBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMC1cXHUyMDBBXFx1MjAyOFxcdTIwMjlcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHVGRUZGXS87XG5cbmxldCBkb2M6IE9wdGlvbjxTaW1wbGVEb2N1bWVudD4gPSB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IGNhc3RUb1NpbXBsZShkb2N1bWVudCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1doaXRlc3BhY2Uoc3RyaW5nOiBzdHJpbmcpIHtcbiAgcmV0dXJuIFdISVRFU1BBQ0UudGVzdChzdHJpbmcpO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIERPTSB7XG4gIGV4cG9ydCBjbGFzcyBUcmVlQ29uc3RydWN0aW9uIGV4dGVuZHMgRE9NT3BlcmF0aW9ucyBpbXBsZW1lbnRzIEdsaW1tZXJUcmVlQ29uc3RydWN0aW9uIHtcbiAgICBjcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlOiBFbGVtZW50TmFtZXNwYWNlLCB0YWc6IHN0cmluZyk6IFNpbXBsZUVsZW1lbnQge1xuICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZSwgdGFnKTtcbiAgICB9XG5cbiAgICBzZXRBdHRyaWJ1dGUoXG4gICAgICBlbGVtZW50OiBTaW1wbGVFbGVtZW50LFxuICAgICAgbmFtZTogc3RyaW5nLFxuICAgICAgdmFsdWU6IHN0cmluZyxcbiAgICAgIG5hbWVzcGFjZTogT3B0aW9uPEF0dHJOYW1lc3BhY2U+ID0gbnVsbFxuICAgICkge1xuICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgbmFtZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCBhcHBsaWVkVHJlZUNvbnN0cnVjdGlvbiA9IFRyZWVDb25zdHJ1Y3Rpb247XG4gIGFwcGxpZWRUcmVlQ29uc3RydWN0aW9uID0gYXBwbHlUZXh0Tm9kZU1lcmdpbmdGaXgoXG4gICAgZG9jLFxuICAgIGFwcGxpZWRUcmVlQ29uc3RydWN0aW9uXG4gICkgYXMgdHlwZW9mIFRyZWVDb25zdHJ1Y3Rpb247XG4gIGFwcGxpZWRUcmVlQ29uc3RydWN0aW9uID0gYXBwbHlTVkdJbm5lckhUTUxGaXgoXG4gICAgZG9jLFxuICAgIGFwcGxpZWRUcmVlQ29uc3RydWN0aW9uLFxuICAgIE5hbWVzcGFjZS5TVkdcbiAgKSBhcyB0eXBlb2YgVHJlZUNvbnN0cnVjdGlvbjtcblxuICBleHBvcnQgY29uc3QgRE9NVHJlZUNvbnN0cnVjdGlvbiA9IGFwcGxpZWRUcmVlQ29uc3RydWN0aW9uO1xuICBleHBvcnQgdHlwZSBET01UcmVlQ29uc3RydWN0aW9uID0gVHJlZUNvbnN0cnVjdGlvbjtcbn1cblxuZXhwb3J0IGNsYXNzIERPTUNoYW5nZXNJbXBsIGV4dGVuZHMgRE9NT3BlcmF0aW9ucyBpbXBsZW1lbnRzIEdsaW1tZXJUcmVlQ2hhbmdlcyB7XG4gIHByb3RlY3RlZCBuYW1lc3BhY2U6IE9wdGlvbjxzdHJpbmc+O1xuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBkb2N1bWVudDogU2ltcGxlRG9jdW1lbnQpIHtcbiAgICBzdXBlcihkb2N1bWVudCk7XG4gICAgdGhpcy5uYW1lc3BhY2UgPSBudWxsO1xuICB9XG5cbiAgc2V0QXR0cmlidXRlKGVsZW1lbnQ6IFNpbXBsZUVsZW1lbnQsIG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZykge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgfVxuXG4gIHJlbW92ZUF0dHJpYnV0ZShlbGVtZW50OiBTaW1wbGVFbGVtZW50LCBuYW1lOiBzdHJpbmcpIHtcbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfVxuXG4gIGluc2VydEFmdGVyKGVsZW1lbnQ6IFNpbXBsZUVsZW1lbnQsIG5vZGU6IFNpbXBsZU5vZGUsIHJlZmVyZW5jZTogU2ltcGxlTm9kZSkge1xuICAgIHRoaXMuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIG5vZGUsIHJlZmVyZW5jZS5uZXh0U2libGluZyk7XG4gIH1cbn1cblxubGV0IGhlbHBlciA9IERPTUNoYW5nZXNJbXBsO1xuXG5oZWxwZXIgPSBhcHBseVRleHROb2RlTWVyZ2luZ0ZpeChkb2MsIGhlbHBlcikgYXMgdHlwZW9mIERPTUNoYW5nZXNJbXBsO1xuaGVscGVyID0gYXBwbHlTVkdJbm5lckhUTUxGaXgoZG9jLCBoZWxwZXIsIE5hbWVzcGFjZS5TVkcpIGFzIHR5cGVvZiBET01DaGFuZ2VzSW1wbDtcblxuZXhwb3J0IGRlZmF1bHQgaGVscGVyO1xuZXhwb3J0IGNvbnN0IERPTVRyZWVDb25zdHJ1Y3Rpb24gPSBET00uRE9NVHJlZUNvbnN0cnVjdGlvbjtcbmV4cG9ydCB0eXBlIERPTVRyZWVDb25zdHJ1Y3Rpb24gPSBET00uRE9NVHJlZUNvbnN0cnVjdGlvbjtcbmV4cG9ydCB0eXBlIERPTU5hbWVzcGFjZSA9IE5hbWVzcGFjZTtcbiIsImltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7XG4gIEJvdW5kcyxcbiAgQ2FwdHVyZWRSZW5kZXJOb2RlLFxuICBEZWJ1Z1JlbmRlclRyZWUsXG4gIE9wdGlvbixcbiAgUmVuZGVyTm9kZSxcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBleHBlY3QsIGFzc2lnbiwgU3RhY2sgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IHJlaWZ5QXJncyB9IGZyb20gJy4vdm0vYXJndW1lbnRzJztcblxuaW50ZXJmYWNlIEludGVybmFsUmVuZGVyTm9kZTxUIGV4dGVuZHMgb2JqZWN0PiBleHRlbmRzIFJlbmRlck5vZGUge1xuICBib3VuZHM6IE9wdGlvbjxCb3VuZHM+O1xuICByZWZzOiBTZXQ8UmVmPFQ+PjtcbiAgcGFyZW50PzogSW50ZXJuYWxSZW5kZXJOb2RlPFQ+O1xufVxuXG5sZXQgR1VJRCA9IDA7XG5cbmV4cG9ydCBjbGFzcyBSZWY8VCBleHRlbmRzIG9iamVjdD4ge1xuICByZWFkb25seSBpZDogbnVtYmVyID0gR1VJRCsrO1xuICBwcml2YXRlIHZhbHVlOiBPcHRpb248VD47XG5cbiAgY29uc3RydWN0b3IodmFsdWU6IFQpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICBnZXQoKTogT3B0aW9uPFQ+IHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxuXG4gIHJlbGVhc2UoKTogdm9pZCB7XG4gICAgaWYgKERFQlVHICYmIHRoaXMudmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQlVHOiBkb3VibGUgcmVsZWFzZT8nKTtcbiAgICB9XG5cbiAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgfVxuXG4gIHRvU3RyaW5nKCk6IFN0cmluZyB7XG4gICAgbGV0IGxhYmVsID0gYFJlZiAke3RoaXMuaWR9YDtcblxuICAgIGlmICh0aGlzLnZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gYCR7bGFiZWx9IChyZWxlYXNlZClgO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYCR7bGFiZWx9OiAke3RoaXMudmFsdWV9YDtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlYnVnUmVuZGVyVHJlZUltcGw8VEJ1Y2tldCBleHRlbmRzIG9iamVjdD5cbiAgaW1wbGVtZW50cyBEZWJ1Z1JlbmRlclRyZWU8VEJ1Y2tldD4ge1xuICBwcml2YXRlIHN0YWNrID0gbmV3IFN0YWNrPFRCdWNrZXQ+KCk7XG5cbiAgcHJpdmF0ZSByZWZzID0gbmV3IFdlYWtNYXA8VEJ1Y2tldCwgUmVmPFRCdWNrZXQ+PigpO1xuICBwcml2YXRlIHJvb3RzID0gbmV3IFNldDxSZWY8VEJ1Y2tldD4+KCk7XG4gIHByaXZhdGUgbm9kZXMgPSBuZXcgV2Vha01hcDxUQnVja2V0LCBJbnRlcm5hbFJlbmRlck5vZGU8VEJ1Y2tldD4+KCk7XG5cbiAgYmVnaW4oKTogdm9pZCB7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG5cbiAgY3JlYXRlKHN0YXRlOiBUQnVja2V0LCBub2RlOiBSZW5kZXJOb2RlKTogdm9pZCB7XG4gICAgbGV0IGludGVybmFsTm9kZTogSW50ZXJuYWxSZW5kZXJOb2RlPFRCdWNrZXQ+ID0gYXNzaWduKHt9LCBub2RlLCB7XG4gICAgICBib3VuZHM6IG51bGwsXG4gICAgICByZWZzOiBuZXcgU2V0PFJlZjxUQnVja2V0Pj4oKSxcbiAgICB9KTtcbiAgICB0aGlzLm5vZGVzLnNldChzdGF0ZSwgaW50ZXJuYWxOb2RlKTtcbiAgICB0aGlzLmFwcGVuZENoaWxkKGludGVybmFsTm9kZSwgc3RhdGUpO1xuICAgIHRoaXMuZW50ZXIoc3RhdGUpO1xuICB9XG5cbiAgdXBkYXRlKHN0YXRlOiBUQnVja2V0KTogdm9pZCB7XG4gICAgdGhpcy5lbnRlcihzdGF0ZSk7XG4gIH1cblxuICBkaWRSZW5kZXIoc3RhdGU6IFRCdWNrZXQsIGJvdW5kczogQm91bmRzKTogdm9pZCB7XG4gICAgaWYgKERFQlVHICYmIHRoaXMuc3RhY2suY3VycmVudCAhPT0gc3RhdGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQlVHOiBleHBlY3RpbmcgJHt0aGlzLnN0YWNrLmN1cnJlbnR9LCBnb3QgJHtzdGF0ZX1gKTtcbiAgICB9XG5cbiAgICB0aGlzLm5vZGVGb3Ioc3RhdGUpLmJvdW5kcyA9IGJvdW5kcztcbiAgICB0aGlzLmV4aXQoKTtcbiAgfVxuXG4gIHdpbGxEZXN0cm95KHN0YXRlOiBUQnVja2V0KTogdm9pZCB7XG4gICAgZXhwZWN0KHRoaXMucmVmcy5nZXQoc3RhdGUpLCAnQlVHOiBtaXNzaW5nIHJlZicpLnJlbGVhc2UoKTtcbiAgfVxuXG4gIGNvbW1pdCgpOiB2b2lkIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxuICBjYXB0dXJlKCk6IENhcHR1cmVkUmVuZGVyTm9kZVtdIHtcbiAgICByZXR1cm4gdGhpcy5jYXB0dXJlUmVmcyh0aGlzLnJvb3RzKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVzZXQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuc3RhY2suc2l6ZSAhPT0gMCkge1xuICAgICAgLy8gV2UgcHJvYmFibHkgZW5jb3VudGVyZWQgYW4gZXJyb3IgZHVyaW5nIHRoZSByZW5kZXJpbmcgbG9vcC4gVGhpcyB3aWxsXG4gICAgICAvLyBsaWtlbHkgdHJpZ2dlciB1bmRlZmluZWQgYmVoYXZpb3IgYW5kIG1lbW9yeSBsZWFrcyBhcyB0aGUgZXJyb3IgbGVmdFxuICAgICAgLy8gdGhpbmdzIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS4gSXQgaXMgcmVjb21tZW5kZWQgdGhhdCB0aGUgdXNlclxuICAgICAgLy8gcmVmcmVzaCB0aGUgcGFnZS5cblxuICAgICAgLy8gVE9ETzogV2UgY291bGQgd2FybiBoZXJlPyBCdXQgdGhpcyBoYXBwZW5zIGFsbCB0aGUgdGltZSBpbiBvdXIgdGVzdHM/XG5cbiAgICAgIC8vIENsZWFuIHVwIHRoZSByb290IHJlZmVyZW5jZSB0byBwcmV2ZW50IGVycm9ycyBmcm9tIGhhcHBlbmluZyBpZiB3ZVxuICAgICAgLy8gYXR0ZW1wdCB0byBjYXB0dXJlIHRoZSByZW5kZXIgdHJlZSAoRW1iZXIgSW5zcGVjdG9yIG1heSBkbyB0aGlzKVxuICAgICAgbGV0IHJvb3QgPSBleHBlY3QodGhpcy5zdGFjay50b0FycmF5KClbMF0sICdleHBlY3RlZCByb290IHN0YXRlIHdoZW4gcmVzZXR0aW5nIHJlbmRlciB0cmVlJyk7XG4gICAgICBsZXQgcmVmID0gdGhpcy5yZWZzLmdldChyb290KTtcblxuICAgICAgaWYgKHJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMucm9vdHMuZGVsZXRlKHJlZik7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICghdGhpcy5zdGFjay5pc0VtcHR5KCkpIHtcbiAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGVudGVyKHN0YXRlOiBUQnVja2V0KTogdm9pZCB7XG4gICAgdGhpcy5zdGFjay5wdXNoKHN0YXRlKTtcbiAgfVxuXG4gIHByaXZhdGUgZXhpdCgpOiB2b2lkIHtcbiAgICBpZiAoREVCVUcgJiYgdGhpcy5zdGFjay5zaXplID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JVRzogdW5iYWxhbmNlZCBwb3AnKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICB9XG5cbiAgcHJpdmF0ZSBub2RlRm9yKHN0YXRlOiBUQnVja2V0KTogSW50ZXJuYWxSZW5kZXJOb2RlPFRCdWNrZXQ+IHtcbiAgICByZXR1cm4gZXhwZWN0KHRoaXMubm9kZXMuZ2V0KHN0YXRlKSwgJ0JVRzogbWlzc2luZyBub2RlJyk7XG4gIH1cblxuICBwcml2YXRlIGFwcGVuZENoaWxkKG5vZGU6IEludGVybmFsUmVuZGVyTm9kZTxUQnVja2V0Piwgc3RhdGU6IFRCdWNrZXQpOiB2b2lkIHtcbiAgICBpZiAoREVCVUcgJiYgdGhpcy5yZWZzLmhhcyhzdGF0ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQlVHOiBjaGlsZCBhbHJlYWR5IGFwcGVuZGVkJyk7XG4gICAgfVxuXG4gICAgbGV0IHBhcmVudCA9IHRoaXMuc3RhY2suY3VycmVudDtcbiAgICBsZXQgcmVmID0gbmV3IFJlZihzdGF0ZSk7XG5cbiAgICB0aGlzLnJlZnMuc2V0KHN0YXRlLCByZWYpO1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgbGV0IHBhcmVudE5vZGUgPSB0aGlzLm5vZGVGb3IocGFyZW50KTtcbiAgICAgIHBhcmVudE5vZGUucmVmcy5hZGQocmVmKTtcbiAgICAgIG5vZGUucGFyZW50ID0gcGFyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yb290cy5hZGQocmVmKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNhcHR1cmVSZWZzKHJlZnM6IFNldDxSZWY8VEJ1Y2tldD4+KTogQ2FwdHVyZWRSZW5kZXJOb2RlW10ge1xuICAgIGxldCBjYXB0dXJlZDogQ2FwdHVyZWRSZW5kZXJOb2RlW10gPSBbXTtcblxuICAgIHJlZnMuZm9yRWFjaCgocmVmKSA9PiB7XG4gICAgICBsZXQgc3RhdGUgPSByZWYuZ2V0KCk7XG5cbiAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICBjYXB0dXJlZC5wdXNoKHRoaXMuY2FwdHVyZU5vZGUoYHJlbmRlci1ub2RlOiR7cmVmLmlkfWAsIHN0YXRlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWZzLmRlbGV0ZShyZWYpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNhcHR1cmVkO1xuICB9XG5cbiAgcHJpdmF0ZSBjYXB0dXJlTm9kZShpZDogc3RyaW5nLCBzdGF0ZTogVEJ1Y2tldCk6IENhcHR1cmVkUmVuZGVyTm9kZSB7XG4gICAgbGV0IG5vZGUgPSB0aGlzLm5vZGVGb3Ioc3RhdGUpO1xuICAgIGxldCB7IHR5cGUsIG5hbWUsIGFyZ3MsIGluc3RhbmNlLCByZWZzIH0gPSBub2RlO1xuICAgIGxldCB0ZW1wbGF0ZSA9IHRoaXMuY2FwdHVyZVRlbXBsYXRlKG5vZGUpO1xuICAgIGxldCBib3VuZHMgPSB0aGlzLmNhcHR1cmVCb3VuZHMobm9kZSk7XG4gICAgbGV0IGNoaWxkcmVuID0gdGhpcy5jYXB0dXJlUmVmcyhyZWZzKTtcbiAgICByZXR1cm4geyBpZCwgdHlwZSwgbmFtZSwgYXJnczogcmVpZnlBcmdzKGFyZ3MpLCBpbnN0YW5jZSwgdGVtcGxhdGUsIGJvdW5kcywgY2hpbGRyZW4gfTtcbiAgfVxuXG4gIHByaXZhdGUgY2FwdHVyZVRlbXBsYXRlKHsgdGVtcGxhdGUgfTogSW50ZXJuYWxSZW5kZXJOb2RlPFRCdWNrZXQ+KTogT3B0aW9uPHN0cmluZz4ge1xuICAgIHJldHVybiB0ZW1wbGF0ZSB8fCBudWxsO1xuICB9XG5cbiAgcHJpdmF0ZSBjYXB0dXJlQm91bmRzKG5vZGU6IEludGVybmFsUmVuZGVyTm9kZTxUQnVja2V0Pik6IENhcHR1cmVkUmVuZGVyTm9kZVsnYm91bmRzJ10ge1xuICAgIGxldCBib3VuZHMgPSBleHBlY3Qobm9kZS5ib3VuZHMsICdCVUc6IG1pc3NpbmcgYm91bmRzJyk7XG4gICAgbGV0IHBhcmVudEVsZW1lbnQgPSBib3VuZHMucGFyZW50RWxlbWVudCgpO1xuICAgIGxldCBmaXJzdE5vZGUgPSBib3VuZHMuZmlyc3ROb2RlKCk7XG4gICAgbGV0IGxhc3ROb2RlID0gYm91bmRzLmxhc3ROb2RlKCk7XG4gICAgcmV0dXJuIHsgcGFyZW50RWxlbWVudCwgZmlyc3ROb2RlLCBsYXN0Tm9kZSB9O1xuICB9XG59XG4iLCJpbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5pbXBvcnQge1xuICBFbnZpcm9ubWVudCxcbiAgRW52aXJvbm1lbnRPcHRpb25zLFxuICBHbGltbWVyVHJlZUNoYW5nZXMsXG4gIEdsaW1tZXJUcmVlQ29uc3RydWN0aW9uLFxuICBUcmFuc2FjdGlvbixcbiAgVHJhbnNhY3Rpb25TeW1ib2wsXG4gIFJ1bnRpbWVDb250ZXh0LFxuICBSdW50aW1lUmVzb2x2ZXIsXG4gIE9wdGlvbixcbiAgUnVudGltZUFydGlmYWN0cyxcbiAgQ29tcG9uZW50SW5zdGFuY2VXaXRoQ3JlYXRlLFxuICBNb2RpZmllckluc3RhbmNlLFxuICBJbnRlcm5hbE1vZGlmaWVyTWFuYWdlcixcbiAgTW9kaWZpZXJJbnN0YW5jZVN0YXRlLFxufSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGFzc2VydCwgZXhwZWN0LCBzeW1ib2wgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IHRyYWNrLCB1cGRhdGVUYWcgfSBmcm9tICdAZ2xpbW1lci92YWxpZGF0b3InO1xuaW1wb3J0IHsgRE9NQ2hhbmdlc0ltcGwsIERPTVRyZWVDb25zdHJ1Y3Rpb24gfSBmcm9tICcuL2RvbS9oZWxwZXInO1xuaW1wb3J0IHsgUnVudGltZVByb2dyYW1JbXBsIH0gZnJvbSAnQGdsaW1tZXIvcHJvZ3JhbSc7XG5pbXBvcnQgRGVidWdSZW5kZXJUcmVlIGZyb20gJy4vZGVidWctcmVuZGVyLXRyZWUnO1xuXG5leHBvcnQgY29uc3QgVFJBTlNBQ1RJT046IFRyYW5zYWN0aW9uU3ltYm9sID0gc3ltYm9sKCdUUkFOU0FDVElPTicpO1xuXG5jbGFzcyBUcmFuc2FjdGlvbkltcGwgaW1wbGVtZW50cyBUcmFuc2FjdGlvbiB7XG4gIHB1YmxpYyBzY2hlZHVsZWRJbnN0YWxsTW9kaWZpZXJzOiBNb2RpZmllckluc3RhbmNlW10gPSBbXTtcbiAgcHVibGljIHNjaGVkdWxlZFVwZGF0ZU1vZGlmaWVyczogTW9kaWZpZXJJbnN0YW5jZVtdID0gW107XG4gIHB1YmxpYyBjcmVhdGVkQ29tcG9uZW50czogQ29tcG9uZW50SW5zdGFuY2VXaXRoQ3JlYXRlW10gPSBbXTtcbiAgcHVibGljIHVwZGF0ZWRDb21wb25lbnRzOiBDb21wb25lbnRJbnN0YW5jZVdpdGhDcmVhdGVbXSA9IFtdO1xuXG4gIGRpZENyZWF0ZShjb21wb25lbnQ6IENvbXBvbmVudEluc3RhbmNlV2l0aENyZWF0ZSkge1xuICAgIHRoaXMuY3JlYXRlZENvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICB9XG5cbiAgZGlkVXBkYXRlKGNvbXBvbmVudDogQ29tcG9uZW50SW5zdGFuY2VXaXRoQ3JlYXRlKSB7XG4gICAgdGhpcy51cGRhdGVkQ29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gIH1cblxuICBzY2hlZHVsZUluc3RhbGxNb2RpZmllcihtb2RpZmllcjogTW9kaWZpZXJJbnN0YW5jZSkge1xuICAgIHRoaXMuc2NoZWR1bGVkSW5zdGFsbE1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcbiAgfVxuXG4gIHNjaGVkdWxlVXBkYXRlTW9kaWZpZXIobW9kaWZpZXI6IE1vZGlmaWVySW5zdGFuY2UpIHtcbiAgICB0aGlzLnNjaGVkdWxlZFVwZGF0ZU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcbiAgfVxuXG4gIGNvbW1pdCgpIHtcbiAgICBsZXQgeyBjcmVhdGVkQ29tcG9uZW50cywgdXBkYXRlZENvbXBvbmVudHMgfSA9IHRoaXM7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNyZWF0ZWRDb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgeyBtYW5hZ2VyLCBzdGF0ZSB9ID0gY3JlYXRlZENvbXBvbmVudHNbaV07XG4gICAgICBtYW5hZ2VyLmRpZENyZWF0ZShzdGF0ZSk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1cGRhdGVkQ29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHsgbWFuYWdlciwgc3RhdGUgfSA9IHVwZGF0ZWRDb21wb25lbnRzW2ldO1xuICAgICAgbWFuYWdlci5kaWRVcGRhdGUoc3RhdGUpO1xuICAgIH1cblxuICAgIGxldCB7IHNjaGVkdWxlZEluc3RhbGxNb2RpZmllcnMsIHNjaGVkdWxlZFVwZGF0ZU1vZGlmaWVycyB9ID0gdGhpcztcblxuICAgIC8vIFByZXZlbnQgYSB0cmFuc3BpbGF0aW9uIGlzc3VlIHdlIGd1YXJkIGFnYWluc3QgaW4gRW1iZXIsIHRoZVxuICAgIC8vIHRocm93LWlmLWNsb3N1cmUtcmVxdWlyZWQgaXNzdWVcbiAgICBsZXQgbWFuYWdlcjogSW50ZXJuYWxNb2RpZmllck1hbmFnZXIsIHN0YXRlOiBNb2RpZmllckluc3RhbmNlU3RhdGU7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVkdWxlZEluc3RhbGxNb2RpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBtb2RpZmllciA9IHNjaGVkdWxlZEluc3RhbGxNb2RpZmllcnNbaV07XG4gICAgICBtYW5hZ2VyID0gbW9kaWZpZXIubWFuYWdlcjtcbiAgICAgIHN0YXRlID0gbW9kaWZpZXIuc3RhdGU7XG5cbiAgICAgIGxldCBtb2RpZmllclRhZyA9IG1hbmFnZXIuZ2V0VGFnKHN0YXRlKTtcblxuICAgICAgaWYgKG1vZGlmaWVyVGFnICE9PSBudWxsKSB7XG4gICAgICAgIGxldCB0YWcgPSB0cmFjayhcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9vcC1mdW5jXG4gICAgICAgICAgKCkgPT4gbWFuYWdlci5pbnN0YWxsKHN0YXRlKSxcbiAgICAgICAgICBERUJVRyAmJlxuICAgICAgICAgICAgYC0gV2hpbGUgcmVuZGVyaW5nOlxcbiAgKGluc3RhbmNlIG9mIGEgXFxgJHtcbiAgICAgICAgICAgICAgbW9kaWZpZXIuZGVmaW5pdGlvbi5yZXNvbHZlZE5hbWUgfHwgbWFuYWdlci5nZXREZWJ1Z05hbWUobW9kaWZpZXIuZGVmaW5pdGlvbi5zdGF0ZSlcbiAgICAgICAgICAgIH1cXGAgbW9kaWZpZXIpYFxuICAgICAgICApO1xuICAgICAgICB1cGRhdGVUYWcobW9kaWZpZXJUYWcsIHRhZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYW5hZ2VyLmluc3RhbGwoc3RhdGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NoZWR1bGVkVXBkYXRlTW9kaWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgbW9kaWZpZXIgPSBzY2hlZHVsZWRVcGRhdGVNb2RpZmllcnNbaV07XG4gICAgICBtYW5hZ2VyID0gbW9kaWZpZXIubWFuYWdlcjtcbiAgICAgIHN0YXRlID0gbW9kaWZpZXIuc3RhdGU7XG5cbiAgICAgIGxldCBtb2RpZmllclRhZyA9IG1hbmFnZXIuZ2V0VGFnKHN0YXRlKTtcblxuICAgICAgaWYgKG1vZGlmaWVyVGFnICE9PSBudWxsKSB7XG4gICAgICAgIGxldCB0YWcgPSB0cmFjayhcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9vcC1mdW5jXG4gICAgICAgICAgKCkgPT4gbWFuYWdlci51cGRhdGUoc3RhdGUpLFxuICAgICAgICAgIERFQlVHICYmXG4gICAgICAgICAgICBgLSBXaGlsZSByZW5kZXJpbmc6XFxuICAoaW5zdGFuY2Ugb2YgYSBcXGAke1xuICAgICAgICAgICAgICBtb2RpZmllci5kZWZpbml0aW9uLnJlc29sdmVkTmFtZSB8fCBtYW5hZ2VyLmdldERlYnVnTmFtZShtb2RpZmllci5kZWZpbml0aW9uLnN0YXRlKVxuICAgICAgICAgICAgfVxcYCBtb2RpZmllcilgXG4gICAgICAgICk7XG4gICAgICAgIHVwZGF0ZVRhZyhtb2RpZmllclRhZywgdGFnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hbmFnZXIudXBkYXRlKHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEVudmlyb25tZW50SW1wbCBpbXBsZW1lbnRzIEVudmlyb25tZW50IHtcbiAgW1RSQU5TQUNUSU9OXTogT3B0aW9uPFRyYW5zYWN0aW9uSW1wbD4gPSBudWxsO1xuXG4gIHByb3RlY3RlZCBhcHBlbmRPcGVyYXRpb25zITogR2xpbW1lclRyZWVDb25zdHJ1Y3Rpb247XG4gIHByb3RlY3RlZCB1cGRhdGVPcGVyYXRpb25zPzogR2xpbW1lclRyZWVDaGFuZ2VzO1xuXG4gIC8vIERlbGVnYXRlIG1ldGhvZHMgYW5kIHZhbHVlc1xuICBwdWJsaWMgaXNJbnRlcmFjdGl2ZSA9IHRoaXMuZGVsZWdhdGUuaXNJbnRlcmFjdGl2ZTtcblxuICBkZWJ1Z1JlbmRlclRyZWUgPSB0aGlzLmRlbGVnYXRlLmVuYWJsZURlYnVnVG9vbGluZyA/IG5ldyBEZWJ1Z1JlbmRlclRyZWUoKSA6IHVuZGVmaW5lZDtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBFbnZpcm9ubWVudE9wdGlvbnMsIHByaXZhdGUgZGVsZWdhdGU6IEVudmlyb25tZW50RGVsZWdhdGUpIHtcbiAgICBpZiAob3B0aW9ucy5hcHBlbmRPcGVyYXRpb25zKSB7XG4gICAgICB0aGlzLmFwcGVuZE9wZXJhdGlvbnMgPSBvcHRpb25zLmFwcGVuZE9wZXJhdGlvbnM7XG4gICAgICB0aGlzLnVwZGF0ZU9wZXJhdGlvbnMgPSBvcHRpb25zLnVwZGF0ZU9wZXJhdGlvbnM7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmRvY3VtZW50KSB7XG4gICAgICB0aGlzLmFwcGVuZE9wZXJhdGlvbnMgPSBuZXcgRE9NVHJlZUNvbnN0cnVjdGlvbihvcHRpb25zLmRvY3VtZW50KTtcbiAgICAgIHRoaXMudXBkYXRlT3BlcmF0aW9ucyA9IG5ldyBET01DaGFuZ2VzSW1wbChvcHRpb25zLmRvY3VtZW50KTtcbiAgICB9IGVsc2UgaWYgKERFQlVHKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3lvdSBtdXN0IHBhc3MgZG9jdW1lbnQgb3IgYXBwZW5kT3BlcmF0aW9ucyB0byBhIG5ldyBydW50aW1lJyk7XG4gICAgfVxuICB9XG5cbiAgZ2V0QXBwZW5kT3BlcmF0aW9ucygpOiBHbGltbWVyVHJlZUNvbnN0cnVjdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuYXBwZW5kT3BlcmF0aW9ucztcbiAgfVxuXG4gIGdldERPTSgpOiBHbGltbWVyVHJlZUNoYW5nZXMge1xuICAgIHJldHVybiBleHBlY3QoXG4gICAgICB0aGlzLnVwZGF0ZU9wZXJhdGlvbnMsXG4gICAgICAnQXR0ZW1wdGVkIHRvIGdldCBET00gdXBkYXRlT3BlcmF0aW9ucywgYnV0IHRoZXkgd2VyZSBub3QgcHJvdmlkZWQgYnkgdGhlIGVudmlyb25tZW50LiBZb3UgbWF5IGJlIGF0dGVtcHRpbmcgdG8gcmVyZW5kZXIgaW4gYW4gZW52aXJvbm1lbnQgd2hpY2ggZG9lcyBub3Qgc3VwcG9ydCByZXJlbmRlcmluZywgc3VjaCBhcyBTU1IuJ1xuICAgICk7XG4gIH1cblxuICBiZWdpbigpIHtcbiAgICBhc3NlcnQoXG4gICAgICAhdGhpc1tUUkFOU0FDVElPTl0sXG4gICAgICAnQSBnbGltbWVyIHRyYW5zYWN0aW9uIHdhcyBiZWd1biwgYnV0IG9uZSBhbHJlYWR5IGV4aXN0cy4gWW91IG1heSBoYXZlIGEgbmVzdGVkIHRyYW5zYWN0aW9uLCBwb3NzaWJseSBjYXVzZWQgYnkgYW4gZWFybGllciBydW50aW1lIGV4Y2VwdGlvbiB3aGlsZSByZW5kZXJpbmcuIFBsZWFzZSBjaGVjayB5b3VyIGNvbnNvbGUgZm9yIHRoZSBzdGFjayB0cmFjZSBvZiBhbnkgcHJpb3IgZXhjZXB0aW9ucy4nXG4gICAgKTtcblxuICAgIHRoaXMuZGVidWdSZW5kZXJUcmVlPy5iZWdpbigpO1xuXG4gICAgdGhpc1tUUkFOU0FDVElPTl0gPSBuZXcgVHJhbnNhY3Rpb25JbXBsKCk7XG4gIH1cblxuICBwcml2YXRlIGdldCB0cmFuc2FjdGlvbigpOiBUcmFuc2FjdGlvbkltcGwge1xuICAgIHJldHVybiBleHBlY3QodGhpc1tUUkFOU0FDVElPTl0hLCAnbXVzdCBiZSBpbiBhIHRyYW5zYWN0aW9uJyk7XG4gIH1cblxuICBkaWRDcmVhdGUoY29tcG9uZW50OiBDb21wb25lbnRJbnN0YW5jZVdpdGhDcmVhdGUpIHtcbiAgICB0aGlzLnRyYW5zYWN0aW9uLmRpZENyZWF0ZShjb21wb25lbnQpO1xuICB9XG5cbiAgZGlkVXBkYXRlKGNvbXBvbmVudDogQ29tcG9uZW50SW5zdGFuY2VXaXRoQ3JlYXRlKSB7XG4gICAgdGhpcy50cmFuc2FjdGlvbi5kaWRVcGRhdGUoY29tcG9uZW50KTtcbiAgfVxuXG4gIHNjaGVkdWxlSW5zdGFsbE1vZGlmaWVyKG1vZGlmaWVyOiBNb2RpZmllckluc3RhbmNlKSB7XG4gICAgaWYgKHRoaXMuaXNJbnRlcmFjdGl2ZSkge1xuICAgICAgdGhpcy50cmFuc2FjdGlvbi5zY2hlZHVsZUluc3RhbGxNb2RpZmllcihtb2RpZmllcik7XG4gICAgfVxuICB9XG5cbiAgc2NoZWR1bGVVcGRhdGVNb2RpZmllcihtb2RpZmllcjogTW9kaWZpZXJJbnN0YW5jZSkge1xuICAgIGlmICh0aGlzLmlzSW50ZXJhY3RpdmUpIHtcbiAgICAgIHRoaXMudHJhbnNhY3Rpb24uc2NoZWR1bGVVcGRhdGVNb2RpZmllcihtb2RpZmllcik7XG4gICAgfVxuICB9XG5cbiAgY29tbWl0KCkge1xuICAgIGxldCB0cmFuc2FjdGlvbiA9IHRoaXMudHJhbnNhY3Rpb247XG4gICAgdGhpc1tUUkFOU0FDVElPTl0gPSBudWxsO1xuICAgIHRyYW5zYWN0aW9uLmNvbW1pdCgpO1xuXG4gICAgdGhpcy5kZWJ1Z1JlbmRlclRyZWU/LmNvbW1pdCgpO1xuXG4gICAgdGhpcy5kZWxlZ2F0ZS5vblRyYW5zYWN0aW9uQ29tbWl0KCk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBFbnZpcm9ubWVudERlbGVnYXRlIHtcbiAgLyoqXG4gICAqIFVzZWQgdG8gZGV0ZXJtaW5lIHRoZSB0aGUgZW52aXJvbm1lbnQgaXMgaW50ZXJhY3RpdmUgKGUuZy4gU1NSIGlzIG5vdFxuICAgKiBpbnRlcmFjdGl2ZSkuIEludGVyYWN0aXZlIGVudmlyb25tZW50cyBzY2hlZHVsZSBtb2RpZmllcnMsIGFtb25nIG90aGVyIHRoaW5ncy5cbiAgICovXG4gIGlzSW50ZXJhY3RpdmU6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gZW5hYmxlIGRlYnVnIHRvb2xpbmdcbiAgICovXG4gIGVuYWJsZURlYnVnVG9vbGluZzogYm9vbGVhbjtcblxuICAvKipcbiAgICogQ2FsbGJhY2sgdG8gYmUgY2FsbGVkIHdoZW4gYW4gZW52aXJvbm1lbnQgdHJhbnNhY3Rpb24gY29tbWl0c1xuICAgKi9cbiAgb25UcmFuc2FjdGlvbkNvbW1pdDogKCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJ1bnRpbWVDb250ZXh0KFxuICBvcHRpb25zOiBFbnZpcm9ubWVudE9wdGlvbnMsXG4gIGRlbGVnYXRlOiBFbnZpcm9ubWVudERlbGVnYXRlLFxuICBhcnRpZmFjdHM6IFJ1bnRpbWVBcnRpZmFjdHMsXG4gIHJlc29sdmVyOiBSdW50aW1lUmVzb2x2ZXJcbik6IFJ1bnRpbWVDb250ZXh0IHtcbiAgcmV0dXJuIHtcbiAgICBlbnY6IG5ldyBFbnZpcm9ubWVudEltcGwob3B0aW9ucywgZGVsZWdhdGUpLFxuICAgIHByb2dyYW06IG5ldyBSdW50aW1lUHJvZ3JhbUltcGwoYXJ0aWZhY3RzLmNvbnN0YW50cywgYXJ0aWZhY3RzLmhlYXApLFxuICAgIHJlc29sdmVyOiByZXNvbHZlcixcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluVHJhbnNhY3Rpb24oZW52OiBFbnZpcm9ubWVudCwgY2I6ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgaWYgKCFlbnZbVFJBTlNBQ1RJT05dKSB7XG4gICAgZW52LmJlZ2luKCk7XG4gICAgdHJ5IHtcbiAgICAgIGNiKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGVudi5jb21taXQoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY2IoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBFbnZpcm9ubWVudEltcGw7XG4iLCJpbXBvcnQgeyBPcHRpb24sIFJ1bnRpbWVIZWFwLCBNYWNoaW5lT3AsIFJ1bnRpbWVQcm9ncmFtLCBSdW50aW1lT3AgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IEFQUEVORF9PUENPREVTIH0gZnJvbSAnLi4vb3Bjb2Rlcyc7XG5pbXBvcnQgVk0gZnJvbSAnLi9hcHBlbmQnO1xuaW1wb3J0IHsgTE9DQUxfREVCVUcgfSBmcm9tICdAZ2xpbW1lci9sb2NhbC1kZWJ1Zy1mbGFncyc7XG5pbXBvcnQgeyBNYWNoaW5lUmVnaXN0ZXIsICRwYywgJHJhLCAkZnAsICRzcCB9IGZyb20gJ0BnbGltbWVyL3ZtJztcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuXG5leHBvcnQgaW50ZXJmYWNlIExvd0xldmVsUmVnaXN0ZXJzIHtcbiAgW01hY2hpbmVSZWdpc3Rlci5wY106IG51bWJlcjtcbiAgW01hY2hpbmVSZWdpc3Rlci5yYV06IG51bWJlcjtcbiAgW01hY2hpbmVSZWdpc3Rlci5zcF06IG51bWJlcjtcbiAgW01hY2hpbmVSZWdpc3Rlci5mcF06IG51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpemVSZWdpc3RlcnMoKTogTG93TGV2ZWxSZWdpc3RlcnMge1xuICByZXR1cm4gWzAsIC0xLCAwLCAwXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpemVSZWdpc3RlcnNXaXRoU1Aoc3A6IG51bWJlcik6IExvd0xldmVsUmVnaXN0ZXJzIHtcbiAgcmV0dXJuIFswLCAtMSwgc3AsIDBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZVJlZ2lzdGVyc1dpdGhQQyhwYzogbnVtYmVyKTogTG93TGV2ZWxSZWdpc3RlcnMge1xuICByZXR1cm4gW3BjLCAtMSwgMCwgMF07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhY2sge1xuICBwdXNoKHZhbHVlOiB1bmtub3duKTogdm9pZDtcbiAgZ2V0KHBvc2l0aW9uOiBudW1iZXIpOiBudW1iZXI7XG4gIHBvcDxUPigpOiBUO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4dGVybnMge1xuICBkZWJ1Z0JlZm9yZShvcGNvZGU6IFJ1bnRpbWVPcCk6IHVua25vd247XG4gIGRlYnVnQWZ0ZXIoc3RhdGU6IHVua25vd24pOiB2b2lkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb3dMZXZlbFZNIHtcbiAgcHVibGljIGN1cnJlbnRPcFNpemUgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBzdGFjazogU3RhY2ssXG4gICAgcHVibGljIGhlYXA6IFJ1bnRpbWVIZWFwLFxuICAgIHB1YmxpYyBwcm9ncmFtOiBSdW50aW1lUHJvZ3JhbSxcbiAgICBwdWJsaWMgZXh0ZXJuczogRXh0ZXJucyxcbiAgICByZWFkb25seSByZWdpc3RlcnM6IExvd0xldmVsUmVnaXN0ZXJzXG4gICkge31cblxuICBmZXRjaFJlZ2lzdGVyKHJlZ2lzdGVyOiBNYWNoaW5lUmVnaXN0ZXIpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyc1tyZWdpc3Rlcl07XG4gIH1cblxuICBsb2FkUmVnaXN0ZXIocmVnaXN0ZXI6IE1hY2hpbmVSZWdpc3RlciwgdmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMucmVnaXN0ZXJzW3JlZ2lzdGVyXSA9IHZhbHVlO1xuICB9XG5cbiAgc2V0UGMocGM6IG51bWJlcik6IHZvaWQge1xuICAgIGFzc2VydCh0eXBlb2YgcGMgPT09ICdudW1iZXInICYmICFpc05hTihwYyksICdwYyBpcyBzZXQgdG8gYSBudW1iZXInKTtcbiAgICB0aGlzLnJlZ2lzdGVyc1skcGNdID0gcGM7XG4gIH1cblxuICAvLyBTdGFydCBhIG5ldyBmcmFtZSBhbmQgc2F2ZSAkcmEgYW5kICRmcCBvbiB0aGUgc3RhY2tcbiAgcHVzaEZyYW1lKCkge1xuICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLnJlZ2lzdGVyc1skcmFdKTtcbiAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5yZWdpc3RlcnNbJGZwXSk7XG4gICAgdGhpcy5yZWdpc3RlcnNbJGZwXSA9IHRoaXMucmVnaXN0ZXJzWyRzcF0gLSAxO1xuICB9XG5cbiAgLy8gUmVzdG9yZSAkcmEsICRzcCBhbmQgJGZwXG4gIHBvcEZyYW1lKCkge1xuICAgIHRoaXMucmVnaXN0ZXJzWyRzcF0gPSB0aGlzLnJlZ2lzdGVyc1skZnBdIC0gMTtcbiAgICB0aGlzLnJlZ2lzdGVyc1skcmFdID0gdGhpcy5zdGFjay5nZXQoMCk7XG4gICAgdGhpcy5yZWdpc3RlcnNbJGZwXSA9IHRoaXMuc3RhY2suZ2V0KDEpO1xuICB9XG5cbiAgcHVzaFNtYWxsRnJhbWUoKSB7XG4gICAgdGhpcy5zdGFjay5wdXNoKHRoaXMucmVnaXN0ZXJzWyRyYV0pO1xuICB9XG5cbiAgcG9wU21hbGxGcmFtZSgpIHtcbiAgICB0aGlzLnJlZ2lzdGVyc1skcmFdID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgfVxuXG4gIC8vIEp1bXAgdG8gYW4gYWRkcmVzcyBpbiBgcHJvZ3JhbWBcbiAgZ290byhvZmZzZXQ6IG51bWJlcikge1xuICAgIHRoaXMuc2V0UGModGhpcy50YXJnZXQob2Zmc2V0KSk7XG4gIH1cblxuICB0YXJnZXQob2Zmc2V0OiBudW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5yZWdpc3RlcnNbJHBjXSArIG9mZnNldCAtIHRoaXMuY3VycmVudE9wU2l6ZTtcbiAgfVxuXG4gIC8vIFNhdmUgJHBjIGludG8gJHJhLCB0aGVuIGp1bXAgdG8gYSBuZXcgYWRkcmVzcyBpbiBgcHJvZ3JhbWAgKGphbCBpbiBNSVBTKVxuICBjYWxsKGhhbmRsZTogbnVtYmVyKSB7XG4gICAgYXNzZXJ0KGhhbmRsZSA8IDB4ZmZmZmZmZmYsIGBKdW1waW5nIHRvIHBsYWNlaG9sZGVyIGFkZHJlc3NgKTtcblxuICAgIHRoaXMucmVnaXN0ZXJzWyRyYV0gPSB0aGlzLnJlZ2lzdGVyc1skcGNdO1xuICAgIHRoaXMuc2V0UGModGhpcy5oZWFwLmdldGFkZHIoaGFuZGxlKSk7XG4gIH1cblxuICAvLyBQdXQgYSBzcGVjaWZpYyBgcHJvZ3JhbWAgYWRkcmVzcyBpbiAkcmFcbiAgcmV0dXJuVG8ob2Zmc2V0OiBudW1iZXIpIHtcbiAgICB0aGlzLnJlZ2lzdGVyc1skcmFdID0gdGhpcy50YXJnZXQob2Zmc2V0KTtcbiAgfVxuXG4gIC8vIFJldHVybiB0byB0aGUgYHByb2dyYW1gIGFkZHJlc3Mgc3RvcmVkIGluICRyYVxuICByZXR1cm4oKSB7XG4gICAgdGhpcy5zZXRQYyh0aGlzLnJlZ2lzdGVyc1skcmFdKTtcbiAgfVxuXG4gIG5leHRTdGF0ZW1lbnQoKTogT3B0aW9uPFJ1bnRpbWVPcD4ge1xuICAgIGxldCB7IHJlZ2lzdGVycywgcHJvZ3JhbSB9ID0gdGhpcztcblxuICAgIGxldCBwYyA9IHJlZ2lzdGVyc1skcGNdO1xuXG4gICAgYXNzZXJ0KHR5cGVvZiBwYyA9PT0gJ251bWJlcicsICdwYyBpcyBhIG51bWJlcicpO1xuXG4gICAgaWYgKHBjID09PSAtMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gV2UgaGF2ZSB0byBzYXZlIG9mZiB0aGUgY3VycmVudCBvcGVyYXRpb25zIHNpemUgc28gdGhhdFxuICAgIC8vIHdoZW4gd2UgZG8gYSBqdW1wIHdlIGNhbiBjYWxjdWxhdGUgdGhlIGNvcnJlY3Qgb2Zmc2V0XG4gICAgLy8gdG8gd2hlcmUgd2UgYXJlIGdvaW5nLiBXZSBjYW4ndCBzaW1wbHkgYXNrIGZvciB0aGUgc2l6ZVxuICAgIC8vIGluIGEganVtcCBiZWNhdXNlIHdlIGhhdmUgaGF2ZSBhbHJlYWR5IGluY3JlbWVudGVkIHRoZVxuICAgIC8vIHByb2dyYW0gY291bnRlciB0byB0aGUgbmV4dCBpbnN0cnVjdGlvbiBwcmlvciB0byBleGVjdXRpbmcuXG4gICAgbGV0IG9wY29kZSA9IHByb2dyYW0ub3Bjb2RlKHBjKTtcbiAgICBsZXQgb3BlcmF0aW9uU2l6ZSA9ICh0aGlzLmN1cnJlbnRPcFNpemUgPSBvcGNvZGUuc2l6ZSk7XG4gICAgdGhpcy5yZWdpc3RlcnNbJHBjXSArPSBvcGVyYXRpb25TaXplO1xuXG4gICAgcmV0dXJuIG9wY29kZTtcbiAgfVxuXG4gIGV2YWx1YXRlT3V0ZXIob3Bjb2RlOiBSdW50aW1lT3AsIHZtOiBWTSkge1xuICAgIGlmIChMT0NBTF9ERUJVRykge1xuICAgICAgbGV0IHtcbiAgICAgICAgZXh0ZXJuczogeyBkZWJ1Z0JlZm9yZSwgZGVidWdBZnRlciB9LFxuICAgICAgfSA9IHRoaXM7XG4gICAgICBsZXQgc3RhdGUgPSBkZWJ1Z0JlZm9yZShvcGNvZGUpO1xuICAgICAgdGhpcy5ldmFsdWF0ZUlubmVyKG9wY29kZSwgdm0pO1xuICAgICAgZGVidWdBZnRlcihzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXZhbHVhdGVJbm5lcihvcGNvZGUsIHZtKTtcbiAgICB9XG4gIH1cblxuICBldmFsdWF0ZUlubmVyKG9wY29kZTogUnVudGltZU9wLCB2bTogVk0pIHtcbiAgICBpZiAob3Bjb2RlLmlzTWFjaGluZSkge1xuICAgICAgdGhpcy5ldmFsdWF0ZU1hY2hpbmUob3Bjb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ldmFsdWF0ZVN5c2NhbGwob3Bjb2RlLCB2bSk7XG4gICAgfVxuICB9XG5cbiAgZXZhbHVhdGVNYWNoaW5lKG9wY29kZTogUnVudGltZU9wKSB7XG4gICAgc3dpdGNoIChvcGNvZGUudHlwZSkge1xuICAgICAgY2FzZSBNYWNoaW5lT3AuUHVzaEZyYW1lOlxuICAgICAgICByZXR1cm4gdGhpcy5wdXNoRnJhbWUoKTtcbiAgICAgIGNhc2UgTWFjaGluZU9wLlBvcEZyYW1lOlxuICAgICAgICByZXR1cm4gdGhpcy5wb3BGcmFtZSgpO1xuICAgICAgY2FzZSBNYWNoaW5lT3AuSW52b2tlU3RhdGljOlxuICAgICAgICByZXR1cm4gdGhpcy5jYWxsKG9wY29kZS5vcDEpO1xuICAgICAgY2FzZSBNYWNoaW5lT3AuSW52b2tlVmlydHVhbDpcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbCh0aGlzLnN0YWNrLnBvcCgpKTtcbiAgICAgIGNhc2UgTWFjaGluZU9wLkp1bXA6XG4gICAgICAgIHJldHVybiB0aGlzLmdvdG8ob3Bjb2RlLm9wMSk7XG4gICAgICBjYXNlIE1hY2hpbmVPcC5SZXR1cm46XG4gICAgICAgIHJldHVybiB0aGlzLnJldHVybigpO1xuICAgICAgY2FzZSBNYWNoaW5lT3AuUmV0dXJuVG86XG4gICAgICAgIHJldHVybiB0aGlzLnJldHVyblRvKG9wY29kZS5vcDEpO1xuICAgIH1cbiAgfVxuXG4gIGV2YWx1YXRlU3lzY2FsbChvcGNvZGU6IFJ1bnRpbWVPcCwgdm06IFZNKSB7XG4gICAgQVBQRU5EX09QQ09ERVMuZXZhbHVhdGUodm0sIG9wY29kZSwgb3Bjb2RlLnR5cGUpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5pbXBvcnQge1xuICBCb3VuZHMsXG4gIER5bmFtaWNTY29wZSxcbiAgRWxlbWVudEJ1aWxkZXIsXG4gIEVudmlyb25tZW50LFxuICBFeGNlcHRpb25IYW5kbGVyLFxuICBHbGltbWVyVHJlZUNoYW5nZXMsXG4gIExpdmVCbG9jayxcbiAgT3B0aW9uLFxuICBSdW50aW1lQ29udGV4dCxcbiAgU2NvcGUsXG4gIFVwZGF0YWJsZUJsb2NrLFxuICBVcGRhdGluZ1ZNLFxuICBVcGRhdGluZ09wY29kZSxcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBMT0NBTF9ERUJVRyB9IGZyb20gJ0BnbGltbWVyL2xvY2FsLWRlYnVnLWZsYWdzJztcbmltcG9ydCB7XG4gIE9wYXF1ZUl0ZXJhdGlvbkl0ZW0sXG4gIE9wYXF1ZUl0ZXJhdG9yLFxuICBSZWZlcmVuY2UsXG4gIHVwZGF0ZVJlZixcbiAgdmFsdWVGb3JSZWYsXG59IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQgeyBhc3NvY2lhdGVEZXN0cm95YWJsZUNoaWxkLCBkZXN0cm95LCBkZXN0cm95Q2hpbGRyZW4gfSBmcm9tICdAZ2xpbW1lci9kZXN0cm95YWJsZSc7XG5pbXBvcnQgeyBleHBlY3QsIFN0YWNrLCBsb2dTdGVwIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyByZXNldFRyYWNraW5nLCBydW5JblRyYWNraW5nVHJhbnNhY3Rpb24gfSBmcm9tICdAZ2xpbW1lci92YWxpZGF0b3InO1xuaW1wb3J0IHsgU2ltcGxlQ29tbWVudCB9IGZyb20gJ0BzaW1wbGUtZG9tL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBjbGVhciwgbW92ZSBhcyBtb3ZlQm91bmRzIH0gZnJvbSAnLi4vYm91bmRzJztcbmltcG9ydCB7IEludGVybmFsVk0sIFZtSW5pdENhbGxiYWNrIH0gZnJvbSAnLi9hcHBlbmQnO1xuaW1wb3J0IHsgTGl2ZUJsb2NrTGlzdCwgTmV3RWxlbWVudEJ1aWxkZXIgfSBmcm9tICcuL2VsZW1lbnQtYnVpbGRlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVwZGF0aW5nVk1JbXBsIGltcGxlbWVudHMgVXBkYXRpbmdWTSB7XG4gIHB1YmxpYyBlbnY6IEVudmlyb25tZW50O1xuICBwdWJsaWMgZG9tOiBHbGltbWVyVHJlZUNoYW5nZXM7XG4gIHB1YmxpYyBhbHdheXNSZXZhbGlkYXRlOiBib29sZWFuO1xuXG4gIHByaXZhdGUgZnJhbWVTdGFjazogU3RhY2s8VXBkYXRpbmdWTUZyYW1lPiA9IG5ldyBTdGFjazxVcGRhdGluZ1ZNRnJhbWU+KCk7XG5cbiAgY29uc3RydWN0b3IoZW52OiBFbnZpcm9ubWVudCwgeyBhbHdheXNSZXZhbGlkYXRlID0gZmFsc2UgfSkge1xuICAgIHRoaXMuZW52ID0gZW52O1xuICAgIHRoaXMuZG9tID0gZW52LmdldERPTSgpO1xuICAgIHRoaXMuYWx3YXlzUmV2YWxpZGF0ZSA9IGFsd2F5c1JldmFsaWRhdGU7XG4gIH1cblxuICBleGVjdXRlKG9wY29kZXM6IFVwZGF0aW5nT3Bjb2RlW10sIGhhbmRsZXI6IEV4Y2VwdGlvbkhhbmRsZXIpIHtcbiAgICBpZiAoREVCVUcpIHtcbiAgICAgIGxldCBoYXNFcnJvcmVkID0gdHJ1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJ1bkluVHJhY2tpbmdUcmFuc2FjdGlvbiEoKCkgPT4gdGhpcy5fZXhlY3V0ZShvcGNvZGVzLCBoYW5kbGVyKSwgJy0gV2hpbGUgcmVuZGVyaW5nOicpO1xuXG4gICAgICAgIC8vIHVzaW5nIGEgYm9vbGVhbiBoZXJlIHRvIGF2b2lkIGJyZWFraW5nIGVyZ29ub21pY3Mgb2YgXCJwYXVzZSBvbiB1bmNhdWdodCBleGNlcHRpb25zXCJcbiAgICAgICAgLy8gd2hpY2ggd291bGQgaGFwcGVuIHdpdGggYSBgY2F0Y2hgICsgYHRocm93YFxuICAgICAgICBoYXNFcnJvcmVkID0gZmFsc2U7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoaGFzRXJyb3JlZCkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgXFxuXFxuRXJyb3Igb2NjdXJyZWQ6XFxuXFxuJHtyZXNldFRyYWNraW5nKCl9XFxuXFxuYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZXhlY3V0ZShvcGNvZGVzLCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9leGVjdXRlKG9wY29kZXM6IFVwZGF0aW5nT3Bjb2RlW10sIGhhbmRsZXI6IEV4Y2VwdGlvbkhhbmRsZXIpIHtcbiAgICBsZXQgeyBmcmFtZVN0YWNrIH0gPSB0aGlzO1xuXG4gICAgdGhpcy50cnkob3Bjb2RlcywgaGFuZGxlcik7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGZyYW1lU3RhY2suaXNFbXB0eSgpKSBicmVhaztcblxuICAgICAgbGV0IG9wY29kZSA9IHRoaXMuZnJhbWUubmV4dFN0YXRlbWVudCgpO1xuXG4gICAgICBpZiAob3Bjb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZnJhbWVTdGFjay5wb3AoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIG9wY29kZS5ldmFsdWF0ZSh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldCBmcmFtZSgpIHtcbiAgICByZXR1cm4gZXhwZWN0KHRoaXMuZnJhbWVTdGFjay5jdXJyZW50LCAnYnVnOiBleHBlY3RlZCBhIGZyYW1lJyk7XG4gIH1cblxuICBnb3RvKGluZGV4OiBudW1iZXIpIHtcbiAgICB0aGlzLmZyYW1lLmdvdG8oaW5kZXgpO1xuICB9XG5cbiAgdHJ5KG9wczogVXBkYXRpbmdPcGNvZGVbXSwgaGFuZGxlcjogT3B0aW9uPEV4Y2VwdGlvbkhhbmRsZXI+KSB7XG4gICAgdGhpcy5mcmFtZVN0YWNrLnB1c2gobmV3IFVwZGF0aW5nVk1GcmFtZShvcHMsIGhhbmRsZXIpKTtcbiAgfVxuXG4gIHRocm93KCkge1xuICAgIHRoaXMuZnJhbWUuaGFuZGxlRXhjZXB0aW9uKCk7XG4gICAgdGhpcy5mcmFtZVN0YWNrLnBvcCgpO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVk1TdGF0ZSB7XG4gIHJlYWRvbmx5IHBjOiBudW1iZXI7XG4gIHJlYWRvbmx5IHNjb3BlOiBTY29wZTtcbiAgcmVhZG9ubHkgZHluYW1pY1Njb3BlOiBEeW5hbWljU2NvcGU7XG4gIHJlYWRvbmx5IHN0YWNrOiB1bmtub3duW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVzdW1hYmxlVk1TdGF0ZSB7XG4gIHJlc3VtZShydW50aW1lOiBSdW50aW1lQ29udGV4dCwgYnVpbGRlcjogRWxlbWVudEJ1aWxkZXIpOiBJbnRlcm5hbFZNO1xufVxuXG5leHBvcnQgY2xhc3MgUmVzdW1hYmxlVk1TdGF0ZUltcGwgaW1wbGVtZW50cyBSZXN1bWFibGVWTVN0YXRlIHtcbiAgY29uc3RydWN0b3IocmVhZG9ubHkgc3RhdGU6IFZNU3RhdGUsIHByaXZhdGUgcmVzdW1lQ2FsbGJhY2s6IFZtSW5pdENhbGxiYWNrKSB7fVxuXG4gIHJlc3VtZShydW50aW1lOiBSdW50aW1lQ29udGV4dCwgYnVpbGRlcjogRWxlbWVudEJ1aWxkZXIpOiBJbnRlcm5hbFZNIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bWVDYWxsYmFjayhydW50aW1lLCB0aGlzLnN0YXRlLCBidWlsZGVyKTtcbiAgfVxufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmxvY2tPcGNvZGUgaW1wbGVtZW50cyBVcGRhdGluZ09wY29kZSwgQm91bmRzIHtcbiAgcHVibGljIGNoaWxkcmVuOiBVcGRhdGluZ09wY29kZVtdO1xuXG4gIHByb3RlY3RlZCByZWFkb25seSBib3VuZHM6IExpdmVCbG9jaztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgc3RhdGU6IFJlc3VtYWJsZVZNU3RhdGUsXG4gICAgcHJvdGVjdGVkIHJ1bnRpbWU6IFJ1bnRpbWVDb250ZXh0LFxuICAgIGJvdW5kczogTGl2ZUJsb2NrLFxuICAgIGNoaWxkcmVuOiBVcGRhdGluZ09wY29kZVtdXG4gICkge1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB0aGlzLmJvdW5kcyA9IGJvdW5kcztcbiAgfVxuXG4gIHBhcmVudEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm91bmRzLnBhcmVudEVsZW1lbnQoKTtcbiAgfVxuXG4gIGZpcnN0Tm9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ib3VuZHMuZmlyc3ROb2RlKCk7XG4gIH1cblxuICBsYXN0Tm9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ib3VuZHMubGFzdE5vZGUoKTtcbiAgfVxuXG4gIGV2YWx1YXRlKHZtOiBVcGRhdGluZ1ZNSW1wbCkge1xuICAgIHZtLnRyeSh0aGlzLmNoaWxkcmVuLCBudWxsKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVHJ5T3Bjb2RlIGV4dGVuZHMgQmxvY2tPcGNvZGUgaW1wbGVtZW50cyBFeGNlcHRpb25IYW5kbGVyIHtcbiAgcHVibGljIHR5cGUgPSAndHJ5JztcblxuICBwcm90ZWN0ZWQgYm91bmRzITogVXBkYXRhYmxlQmxvY2s7IC8vIEhpZGVzIHByb3BlcnR5IG9uIGJhc2UgY2xhc3NcblxuICBldmFsdWF0ZSh2bTogVXBkYXRpbmdWTUltcGwpIHtcbiAgICB2bS50cnkodGhpcy5jaGlsZHJlbiwgdGhpcyk7XG4gIH1cblxuICBoYW5kbGVFeGNlcHRpb24oKSB7XG4gICAgbGV0IHsgc3RhdGUsIGJvdW5kcywgcnVudGltZSB9ID0gdGhpcztcblxuICAgIGRlc3Ryb3lDaGlsZHJlbih0aGlzKTtcblxuICAgIGxldCBlbGVtZW50U3RhY2sgPSBOZXdFbGVtZW50QnVpbGRlci5yZXN1bWUocnVudGltZS5lbnYsIGJvdW5kcyk7XG4gICAgbGV0IHZtID0gc3RhdGUucmVzdW1lKHJ1bnRpbWUsIGVsZW1lbnRTdGFjayk7XG5cbiAgICBsZXQgdXBkYXRpbmc6IFVwZGF0aW5nT3Bjb2RlW10gPSBbXTtcbiAgICBsZXQgY2hpbGRyZW4gPSAodGhpcy5jaGlsZHJlbiA9IFtdKTtcblxuICAgIGxldCByZXN1bHQgPSB2bS5leGVjdXRlKCh2bSkgPT4ge1xuICAgICAgdm0ucHVzaFVwZGF0aW5nKHVwZGF0aW5nKTtcbiAgICAgIHZtLnVwZGF0ZVdpdGgodGhpcyk7XG4gICAgICB2bS5wdXNoVXBkYXRpbmcoY2hpbGRyZW4pO1xuICAgIH0pO1xuXG4gICAgYXNzb2NpYXRlRGVzdHJveWFibGVDaGlsZCh0aGlzLCByZXN1bHQuZHJvcCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIExpc3RJdGVtT3Bjb2RlIGV4dGVuZHMgVHJ5T3Bjb2RlIHtcbiAgcHVibGljIHJldGFpbmVkID0gZmFsc2U7XG4gIHB1YmxpYyBpbmRleCA9IC0xO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHN0YXRlOiBSZXN1bWFibGVWTVN0YXRlLFxuICAgIHJ1bnRpbWU6IFJ1bnRpbWVDb250ZXh0LFxuICAgIGJvdW5kczogVXBkYXRhYmxlQmxvY2ssXG4gICAgcHVibGljIGtleTogdW5rbm93bixcbiAgICBwdWJsaWMgbWVtbzogUmVmZXJlbmNlLFxuICAgIHB1YmxpYyB2YWx1ZTogUmVmZXJlbmNlXG4gICkge1xuICAgIHN1cGVyKHN0YXRlLCBydW50aW1lLCBib3VuZHMsIFtdKTtcbiAgfVxuXG4gIHVwZGF0ZVJlZmVyZW5jZXMoaXRlbTogT3BhcXVlSXRlcmF0aW9uSXRlbSkge1xuICAgIHRoaXMucmV0YWluZWQgPSB0cnVlO1xuICAgIHVwZGF0ZVJlZih0aGlzLnZhbHVlLCBpdGVtLnZhbHVlKTtcbiAgICB1cGRhdGVSZWYodGhpcy5tZW1vLCBpdGVtLm1lbW8pO1xuICB9XG5cbiAgc2hvdWxkUmVtb3ZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhdGhpcy5yZXRhaW5lZDtcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIHRoaXMucmV0YWluZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTGlzdEJsb2NrT3Bjb2RlIGV4dGVuZHMgQmxvY2tPcGNvZGUge1xuICBwdWJsaWMgdHlwZSA9ICdsaXN0LWJsb2NrJztcbiAgcHVibGljIGNoaWxkcmVuITogTGlzdEl0ZW1PcGNvZGVbXTtcblxuICBwcml2YXRlIG9wY29kZU1hcCA9IG5ldyBNYXA8dW5rbm93biwgTGlzdEl0ZW1PcGNvZGU+KCk7XG4gIHByaXZhdGUgbWFya2VyOiBTaW1wbGVDb21tZW50IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgbGFzdEl0ZXJhdG9yOiBPcGFxdWVJdGVyYXRvcjtcblxuICBwcm90ZWN0ZWQgcmVhZG9ubHkgYm91bmRzITogTGl2ZUJsb2NrTGlzdDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBzdGF0ZTogUmVzdW1hYmxlVk1TdGF0ZSxcbiAgICBydW50aW1lOiBSdW50aW1lQ29udGV4dCxcbiAgICBib3VuZHM6IExpdmVCbG9ja0xpc3QsXG4gICAgY2hpbGRyZW46IExpc3RJdGVtT3Bjb2RlW10sXG4gICAgcHJpdmF0ZSBpdGVyYWJsZVJlZjogUmVmZXJlbmNlPE9wYXF1ZUl0ZXJhdG9yPlxuICApIHtcbiAgICBzdXBlcihzdGF0ZSwgcnVudGltZSwgYm91bmRzLCBjaGlsZHJlbik7XG4gICAgdGhpcy5sYXN0SXRlcmF0b3IgPSB2YWx1ZUZvclJlZihpdGVyYWJsZVJlZik7XG4gIH1cblxuICBpbml0aWFsaXplQ2hpbGQob3Bjb2RlOiBMaXN0SXRlbU9wY29kZSkge1xuICAgIG9wY29kZS5pbmRleCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICB0aGlzLm9wY29kZU1hcC5zZXQob3Bjb2RlLmtleSwgb3Bjb2RlKTtcbiAgfVxuXG4gIGV2YWx1YXRlKHZtOiBVcGRhdGluZ1ZNSW1wbCkge1xuICAgIGxldCBpdGVyYXRvciA9IHZhbHVlRm9yUmVmKHRoaXMuaXRlcmFibGVSZWYpO1xuXG4gICAgaWYgKHRoaXMubGFzdEl0ZXJhdG9yICE9PSBpdGVyYXRvcikge1xuICAgICAgbGV0IHsgYm91bmRzIH0gPSB0aGlzO1xuICAgICAgbGV0IHsgZG9tIH0gPSB2bTtcblxuICAgICAgbGV0IG1hcmtlciA9ICh0aGlzLm1hcmtlciA9IGRvbS5jcmVhdGVDb21tZW50KCcnKSk7XG4gICAgICBkb20uaW5zZXJ0QWZ0ZXIoXG4gICAgICAgIGJvdW5kcy5wYXJlbnRFbGVtZW50KCksXG4gICAgICAgIG1hcmtlcixcbiAgICAgICAgZXhwZWN0KGJvdW5kcy5sYXN0Tm9kZSgpLCBcImNhbid0IGluc2VydCBhZnRlciBhbiBlbXB0eSBib3VuZHNcIilcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuc3luYyhpdGVyYXRvcik7XG5cbiAgICAgIHRoaXMucGFyZW50RWxlbWVudCgpLnJlbW92ZUNoaWxkKG1hcmtlcik7XG4gICAgICB0aGlzLm1hcmtlciA9IG51bGw7XG4gICAgICB0aGlzLmxhc3RJdGVyYXRvciA9IGl0ZXJhdG9yO1xuICAgIH1cblxuICAgIC8vIFJ1biBub3ctdXBkYXRlZCB1cGRhdGluZyBvcGNvZGVzXG4gICAgc3VwZXIuZXZhbHVhdGUodm0pO1xuICB9XG5cbiAgcHJpdmF0ZSBzeW5jKGl0ZXJhdG9yOiBPcGFxdWVJdGVyYXRvcikge1xuICAgIGxldCB7IG9wY29kZU1hcDogaXRlbU1hcCwgY2hpbGRyZW4gfSA9IHRoaXM7XG5cbiAgICBsZXQgY3VycmVudE9wY29kZUluZGV4ID0gMDtcbiAgICBsZXQgc2VlbkluZGV4ID0gMDtcblxuICAgIHRoaXMuY2hpbGRyZW4gPSB0aGlzLmJvdW5kcy5ib3VuZExpc3QgPSBbXTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBsZXQgaXRlbSA9IGl0ZXJhdG9yLm5leHQoKTtcblxuICAgICAgaWYgKGl0ZW0gPT09IG51bGwpIGJyZWFrO1xuXG4gICAgICBsZXQgb3Bjb2RlID0gY2hpbGRyZW5bY3VycmVudE9wY29kZUluZGV4XTtcbiAgICAgIGxldCB7IGtleSB9ID0gaXRlbTtcblxuICAgICAgLy8gSXRlbXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBmb3VuZCBhbmQgbW92ZWQgd2lsbCBhbHJlYWR5IGJlIHJldGFpbmVkLFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHVudGlsIHdlIGZpbmQgdGhlIG5leHQgdW5yZXRhaW5lZCBpdGVtXG4gICAgICB3aGlsZSAob3Bjb2RlICE9PSB1bmRlZmluZWQgJiYgb3Bjb2RlLnJldGFpbmVkID09PSB0cnVlKSB7XG4gICAgICAgIG9wY29kZSA9IGNoaWxkcmVuWysrY3VycmVudE9wY29kZUluZGV4XTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wY29kZSAhPT0gdW5kZWZpbmVkICYmIG9wY29kZS5rZXkgPT09IGtleSkge1xuICAgICAgICB0aGlzLnJldGFpbkl0ZW0ob3Bjb2RlLCBpdGVtKTtcbiAgICAgICAgY3VycmVudE9wY29kZUluZGV4Kys7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW1NYXAuaGFzKGtleSkpIHtcbiAgICAgICAgbGV0IGl0ZW1PcGNvZGUgPSBpdGVtTWFwLmdldChrZXkpITtcblxuICAgICAgICAvLyBUaGUgaXRlbSBvcGNvZGUgd2FzIHNlZW4gYWxyZWFkeSwgc28gd2Ugc2hvdWxkIG1vdmUgaXQuXG4gICAgICAgIGlmIChpdGVtT3Bjb2RlLmluZGV4IDwgc2VlbkluZGV4KSB7XG4gICAgICAgICAgdGhpcy5tb3ZlSXRlbShpdGVtT3Bjb2RlLCBpdGVtLCBvcGNvZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgc2VlbiBpbmRleCwgd2UgYXJlIGdvaW5nIHRvIGJlIG1vdmluZyB0aGlzIGl0ZW0gYXJvdW5kXG4gICAgICAgICAgLy8gc28gYW55IG90aGVyIGl0ZW1zIHRoYXQgY29tZSBiZWZvcmUgaXQgd2lsbCBsaWtlbHkgbmVlZCB0byBtb3ZlIGFzXG4gICAgICAgICAgLy8gd2VsbC5cbiAgICAgICAgICBzZWVuSW5kZXggPSBpdGVtT3Bjb2RlLmluZGV4O1xuXG4gICAgICAgICAgbGV0IHNlZW5VbnJldGFpbmVkID0gZmFsc2U7XG5cbiAgICAgICAgICAvLyBpdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBvcGNvZGVzIGJldHdlZW4gdGhlIGN1cnJlbnQgcG9zaXRpb24gYW5kXG4gICAgICAgICAgLy8gdGhlIHBvc2l0aW9uIG9mIHRoZSBpdGVtJ3Mgb3Bjb2RlLCBhbmQgZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGFsbFxuICAgICAgICAgIC8vIHJldGFpbmVkLlxuICAgICAgICAgIGZvciAobGV0IGkgPSBjdXJyZW50T3Bjb2RlSW5kZXggKyAxOyBpIDwgc2VlbkluZGV4OyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbltpXS5yZXRhaW5lZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgc2VlblVucmV0YWluZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB3ZSBoYXZlIHNlZW4gb25seSByZXRhaW5lZCBvcGNvZGVzIGJldHdlZW4gdGhpcyBhbmQgdGhlIG1hdGNoaW5nXG4gICAgICAgICAgLy8gb3Bjb2RlLCBpdCBtZWFucyB0aGF0IGFsbCB0aGUgb3Bjb2RlcyBpbiBiZXR3ZWVuIGhhdmUgYmVlbiBtb3ZlZFxuICAgICAgICAgIC8vIGFscmVhZHksIGFuZCB3ZSBjYW4gc2FmZWx5IHJldGFpbiB0aGlzIGl0ZW0ncyBvcGNvZGUuXG4gICAgICAgICAgaWYgKHNlZW5VbnJldGFpbmVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5yZXRhaW5JdGVtKGl0ZW1PcGNvZGUsIGl0ZW0pO1xuICAgICAgICAgICAgY3VycmVudE9wY29kZUluZGV4ID0gc2VlbkluZGV4ICsgMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tb3ZlSXRlbShpdGVtT3Bjb2RlLCBpdGVtLCBvcGNvZGUpO1xuICAgICAgICAgICAgY3VycmVudE9wY29kZUluZGV4Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmluc2VydEl0ZW0oaXRlbSwgb3Bjb2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgb3Bjb2RlID0gY2hpbGRyZW5baV07XG5cbiAgICAgIGlmIChvcGNvZGUucmV0YWluZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZGVsZXRlSXRlbShvcGNvZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3Bjb2RlLnJlc2V0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSByZXRhaW5JdGVtKG9wY29kZTogTGlzdEl0ZW1PcGNvZGUsIGl0ZW06IE9wYXF1ZUl0ZXJhdGlvbkl0ZW0pIHtcbiAgICBpZiAoTE9DQUxfREVCVUcpIHtcbiAgICAgIGxvZ1N0ZXAhKCdsaXN0LXVwZGF0ZXMnLCBbJ3JldGFpbicsIGl0ZW0ua2V5XSk7XG4gICAgfVxuXG4gICAgbGV0IHsgY2hpbGRyZW4gfSA9IHRoaXM7XG5cbiAgICB1cGRhdGVSZWYob3Bjb2RlLm1lbW8sIGl0ZW0ubWVtbyk7XG4gICAgdXBkYXRlUmVmKG9wY29kZS52YWx1ZSwgaXRlbS52YWx1ZSk7XG4gICAgb3Bjb2RlLnJldGFpbmVkID0gdHJ1ZTtcblxuICAgIG9wY29kZS5pbmRleCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBjaGlsZHJlbi5wdXNoKG9wY29kZSk7XG4gIH1cblxuICBwcml2YXRlIGluc2VydEl0ZW0oaXRlbTogT3BhcXVlSXRlcmF0aW9uSXRlbSwgYmVmb3JlOiBMaXN0SXRlbU9wY29kZSkge1xuICAgIGlmIChMT0NBTF9ERUJVRykge1xuICAgICAgbG9nU3RlcCEoJ2xpc3QtdXBkYXRlcycsIFsnaW5zZXJ0JywgaXRlbS5rZXldKTtcbiAgICB9XG5cbiAgICBsZXQgeyBvcGNvZGVNYXAsIGJvdW5kcywgc3RhdGUsIHJ1bnRpbWUsIGNoaWxkcmVuIH0gPSB0aGlzO1xuICAgIGxldCB7IGtleSB9ID0gaXRlbTtcbiAgICBsZXQgbmV4dFNpYmxpbmcgPSBiZWZvcmUgPT09IHVuZGVmaW5lZCA/IHRoaXMubWFya2VyIDogYmVmb3JlLmZpcnN0Tm9kZSgpO1xuXG4gICAgbGV0IGVsZW1lbnRTdGFjayA9IE5ld0VsZW1lbnRCdWlsZGVyLmZvckluaXRpYWxSZW5kZXIocnVudGltZS5lbnYsIHtcbiAgICAgIGVsZW1lbnQ6IGJvdW5kcy5wYXJlbnRFbGVtZW50KCksXG4gICAgICBuZXh0U2libGluZyxcbiAgICB9KTtcblxuICAgIGxldCB2bSA9IHN0YXRlLnJlc3VtZShydW50aW1lLCBlbGVtZW50U3RhY2spO1xuXG4gICAgdm0uZXhlY3V0ZSgodm0pID0+IHtcbiAgICAgIHZtLnB1c2hVcGRhdGluZygpO1xuICAgICAgbGV0IG9wY29kZSA9IHZtLmVudGVySXRlbShpdGVtKTtcblxuICAgICAgb3Bjb2RlLmluZGV4ID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgY2hpbGRyZW4ucHVzaChvcGNvZGUpO1xuICAgICAgb3Bjb2RlTWFwLnNldChrZXksIG9wY29kZSk7XG4gICAgICBhc3NvY2lhdGVEZXN0cm95YWJsZUNoaWxkKHRoaXMsIG9wY29kZSk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIG1vdmVJdGVtKG9wY29kZTogTGlzdEl0ZW1PcGNvZGUsIGl0ZW06IE9wYXF1ZUl0ZXJhdGlvbkl0ZW0sIGJlZm9yZTogTGlzdEl0ZW1PcGNvZGUpIHtcbiAgICBsZXQgeyBjaGlsZHJlbiB9ID0gdGhpcztcblxuICAgIHVwZGF0ZVJlZihvcGNvZGUubWVtbywgaXRlbS5tZW1vKTtcbiAgICB1cGRhdGVSZWYob3Bjb2RlLnZhbHVlLCBpdGVtLnZhbHVlKTtcbiAgICBvcGNvZGUucmV0YWluZWQgPSB0cnVlO1xuXG4gICAgbGV0IGN1cnJlbnRTaWJsaW5nLCBuZXh0U2libGluZztcblxuICAgIGlmIChiZWZvcmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbW92ZUJvdW5kcyhvcGNvZGUsIHRoaXMubWFya2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudFNpYmxpbmcgPSBvcGNvZGUubGFzdE5vZGUoKS5uZXh0U2libGluZztcbiAgICAgIG5leHRTaWJsaW5nID0gYmVmb3JlLmZpcnN0Tm9kZSgpO1xuXG4gICAgICAvLyBJdGVtcyBhcmUgbW92ZWQgdGhyb3VnaG91dCB0aGUgYWxnb3JpdGhtLCBzbyB0aGVyZSBhcmUgY2FzZXMgd2hlcmUgdGhlXG4gICAgICAvLyB0aGUgaXRlbXMgYWxyZWFkeSBoYXBwZW4gdG8gYmUgc2libGluZ3MgKGUuZy4gYW4gaXRlbSBpbiBiZXR3ZWVuIHdhc1xuICAgICAgLy8gbW92ZWQgYmVmb3JlIHRoaXMgbW92ZSBoYXBwZW5lZCkuIENoZWNrIHRvIHNlZSBpZiB0aGV5IGFyZSBzaWJsaW5nc1xuICAgICAgLy8gZmlyc3QgYmVmb3JlIGRvaW5nIHRoZSBtb3ZlLlxuICAgICAgaWYgKGN1cnJlbnRTaWJsaW5nICE9PSBuZXh0U2libGluZykge1xuICAgICAgICBtb3ZlQm91bmRzKG9wY29kZSwgbmV4dFNpYmxpbmcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG9wY29kZS5pbmRleCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBjaGlsZHJlbi5wdXNoKG9wY29kZSk7XG5cbiAgICBpZiAoTE9DQUxfREVCVUcpIHtcbiAgICAgIGxldCB0eXBlID0gY3VycmVudFNpYmxpbmcgJiYgY3VycmVudFNpYmxpbmcgPT09IG5leHRTaWJsaW5nID8gJ21vdmUtcmV0YWluJyA6ICdtb3ZlJztcbiAgICAgIGxvZ1N0ZXAhKCdsaXN0LXVwZGF0ZXMnLCBbdHlwZSwgaXRlbS5rZXldKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGRlbGV0ZUl0ZW0ob3Bjb2RlOiBMaXN0SXRlbU9wY29kZSkge1xuICAgIGlmIChMT0NBTF9ERUJVRykge1xuICAgICAgbG9nU3RlcCEoJ2xpc3QtdXBkYXRlcycsIFsnZGVsZXRlJywgb3Bjb2RlLmtleV0pO1xuICAgIH1cblxuICAgIGRlc3Ryb3kob3Bjb2RlKTtcbiAgICBjbGVhcihvcGNvZGUpO1xuICAgIHRoaXMub3Bjb2RlTWFwLmRlbGV0ZShvcGNvZGUua2V5KTtcbiAgfVxufVxuXG5jbGFzcyBVcGRhdGluZ1ZNRnJhbWUge1xuICBwcml2YXRlIGN1cnJlbnQgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgb3BzOiBVcGRhdGluZ09wY29kZVtdLCBwcml2YXRlIGV4Y2VwdGlvbkhhbmRsZXI6IE9wdGlvbjxFeGNlcHRpb25IYW5kbGVyPikge31cblxuICBnb3RvKGluZGV4OiBudW1iZXIpIHtcbiAgICB0aGlzLmN1cnJlbnQgPSBpbmRleDtcbiAgfVxuXG4gIG5leHRTdGF0ZW1lbnQoKTogVXBkYXRpbmdPcGNvZGUgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLm9wc1t0aGlzLmN1cnJlbnQrK107XG4gIH1cblxuICBoYW5kbGVFeGNlcHRpb24oKSB7XG4gICAgaWYgKHRoaXMuZXhjZXB0aW9uSGFuZGxlcikge1xuICAgICAgdGhpcy5leGNlcHRpb25IYW5kbGVyLmhhbmRsZUV4Y2VwdGlvbigpO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgRW52aXJvbm1lbnQsIFJlbmRlclJlc3VsdCwgTGl2ZUJsb2NrLCBVcGRhdGluZ09wY29kZSB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgYXNzb2NpYXRlRGVzdHJveWFibGVDaGlsZCwgcmVnaXN0ZXJEZXN0cnVjdG9yIH0gZnJvbSAnQGdsaW1tZXIvZGVzdHJveWFibGUnO1xuaW1wb3J0IHsgU2ltcGxlRWxlbWVudCwgU2ltcGxlTm9kZSB9IGZyb20gJ0BzaW1wbGUtZG9tL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBjbGVhciB9IGZyb20gJy4uL2JvdW5kcyc7XG5pbXBvcnQgVXBkYXRpbmdWTUltcGwgZnJvbSAnLi91cGRhdGUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJSZXN1bHRJbXBsIGltcGxlbWVudHMgUmVuZGVyUmVzdWx0IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgcHJpdmF0ZSB1cGRhdGluZzogVXBkYXRpbmdPcGNvZGVbXSxcbiAgICBwcml2YXRlIGJvdW5kczogTGl2ZUJsb2NrLFxuICAgIHJlYWRvbmx5IGRyb3A6IG9iamVjdFxuICApIHtcbiAgICBhc3NvY2lhdGVEZXN0cm95YWJsZUNoaWxkKHRoaXMsIGRyb3ApO1xuICAgIHJlZ2lzdGVyRGVzdHJ1Y3Rvcih0aGlzLCAoKSA9PiBjbGVhcih0aGlzLmJvdW5kcykpO1xuICB9XG5cbiAgcmVyZW5kZXIoeyBhbHdheXNSZXZhbGlkYXRlID0gZmFsc2UgfSA9IHsgYWx3YXlzUmV2YWxpZGF0ZTogZmFsc2UgfSkge1xuICAgIGxldCB7IGVudiwgdXBkYXRpbmcgfSA9IHRoaXM7XG4gICAgbGV0IHZtID0gbmV3IFVwZGF0aW5nVk1JbXBsKGVudiwgeyBhbHdheXNSZXZhbGlkYXRlIH0pO1xuICAgIHZtLmV4ZWN1dGUodXBkYXRpbmcsIHRoaXMpO1xuICB9XG5cbiAgcGFyZW50RWxlbWVudCgpOiBTaW1wbGVFbGVtZW50IHtcbiAgICByZXR1cm4gdGhpcy5ib3VuZHMucGFyZW50RWxlbWVudCgpO1xuICB9XG5cbiAgZmlyc3ROb2RlKCk6IFNpbXBsZU5vZGUge1xuICAgIHJldHVybiB0aGlzLmJvdW5kcy5maXJzdE5vZGUoKTtcbiAgfVxuXG4gIGxhc3ROb2RlKCk6IFNpbXBsZU5vZGUge1xuICAgIHJldHVybiB0aGlzLmJvdW5kcy5sYXN0Tm9kZSgpO1xuICB9XG5cbiAgaGFuZGxlRXhjZXB0aW9uKCkge1xuICAgIHRocm93ICd0aGlzIHNob3VsZCBuZXZlciBoYXBwZW4nO1xuICB9XG59XG4iLCJpbXBvcnQgeyBMT0NBTF9ERUJVRyB9IGZyb20gJ0BnbGltbWVyL2xvY2FsLWRlYnVnLWZsYWdzJztcbmltcG9ydCB7ICRmcCwgJHNwLCBNYWNoaW5lUmVnaXN0ZXIgfSBmcm9tICdAZ2xpbW1lci92bSc7XG5pbXBvcnQgeyBSRUdJU1RFUlMgfSBmcm9tICcuLi9zeW1ib2xzJztcbmltcG9ydCB7IGluaXRpYWxpemVSZWdpc3RlcnNXaXRoU1AsIExvd0xldmVsUmVnaXN0ZXJzIH0gZnJvbSAnLi9sb3ctbGV2ZWwnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEV2YWx1YXRpb25TdGFjayB7XG4gIFtSRUdJU1RFUlNdOiBMb3dMZXZlbFJlZ2lzdGVycztcblxuICBwdXNoKHZhbHVlOiB1bmtub3duKTogdm9pZDtcbiAgZHVwKHBvc2l0aW9uPzogTWFjaGluZVJlZ2lzdGVyKTogdm9pZDtcbiAgY29weShmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIpOiB2b2lkO1xuICBwb3A8VD4obj86IG51bWJlcik6IFQ7XG4gIHBlZWs8VD4ob2Zmc2V0PzogbnVtYmVyKTogVDtcbiAgZ2V0PFQ+KG9mZnNldDogbnVtYmVyLCBiYXNlPzogbnVtYmVyKTogVDtcbiAgc2V0KHZhbHVlOiB1bmtub3duLCBvZmZzZXQ6IG51bWJlciwgYmFzZT86IG51bWJlcik6IHZvaWQ7XG4gIHNsaWNlPFQgPSB1bmtub3duPihzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcik6IFRbXTtcbiAgY2FwdHVyZShpdGVtczogbnVtYmVyKTogdW5rbm93bltdO1xuICByZXNldCgpOiB2b2lkO1xuICB0b0FycmF5KCk6IHVua25vd25bXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZhbHVhdGlvblN0YWNrSW1wbCBpbXBsZW1lbnRzIEV2YWx1YXRpb25TdGFjayB7XG4gIHN0YXRpYyByZXN0b3JlKHNuYXBzaG90OiB1bmtub3duW10pOiBFdmFsdWF0aW9uU3RhY2tJbXBsIHtcbiAgICByZXR1cm4gbmV3IHRoaXMoc25hcHNob3Quc2xpY2UoKSwgaW5pdGlhbGl6ZVJlZ2lzdGVyc1dpdGhTUChzbmFwc2hvdC5sZW5ndGggLSAxKSk7XG4gIH1cblxuICByZWFkb25seSBbUkVHSVNURVJTXTogTG93TGV2ZWxSZWdpc3RlcnM7XG5cbiAgLy8gZnAgLT4gc3BcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBzdGFjazogdW5rbm93bltdID0gW10sIHJlZ2lzdGVyczogTG93TGV2ZWxSZWdpc3RlcnMpIHtcbiAgICB0aGlzW1JFR0lTVEVSU10gPSByZWdpc3RlcnM7XG5cbiAgICBpZiAoTE9DQUxfREVCVUcpIHtcbiAgICAgIE9iamVjdC5zZWFsKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIHB1c2godmFsdWU6IHVua25vd24pOiB2b2lkIHtcbiAgICB0aGlzLnN0YWNrWysrdGhpc1tSRUdJU1RFUlNdWyRzcF1dID0gdmFsdWU7XG4gIH1cblxuICBkdXAocG9zaXRpb24gPSB0aGlzW1JFR0lTVEVSU11bJHNwXSk6IHZvaWQge1xuICAgIHRoaXMuc3RhY2tbKyt0aGlzW1JFR0lTVEVSU11bJHNwXV0gPSB0aGlzLnN0YWNrW3Bvc2l0aW9uXTtcbiAgfVxuXG4gIGNvcHkoZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5zdGFja1t0b10gPSB0aGlzLnN0YWNrW2Zyb21dO1xuICB9XG5cbiAgcG9wPFQ+KG4gPSAxKTogVCB7XG4gICAgbGV0IHRvcCA9IHRoaXMuc3RhY2tbdGhpc1tSRUdJU1RFUlNdWyRzcF1dIGFzIFQ7XG4gICAgdGhpc1tSRUdJU1RFUlNdWyRzcF0gLT0gbjtcbiAgICByZXR1cm4gdG9wO1xuICB9XG5cbiAgcGVlazxUPihvZmZzZXQgPSAwKTogVCB7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2tbdGhpc1tSRUdJU1RFUlNdWyRzcF0gLSBvZmZzZXRdIGFzIFQ7XG4gIH1cblxuICBnZXQ8VD4ob2Zmc2V0OiBudW1iZXIsIGJhc2UgPSB0aGlzW1JFR0lTVEVSU11bJGZwXSk6IFQge1xuICAgIHJldHVybiB0aGlzLnN0YWNrW2Jhc2UgKyBvZmZzZXRdIGFzIFQ7XG4gIH1cblxuICBzZXQodmFsdWU6IHVua25vd24sIG9mZnNldDogbnVtYmVyLCBiYXNlID0gdGhpc1tSRUdJU1RFUlNdWyRmcF0pIHtcbiAgICB0aGlzLnN0YWNrW2Jhc2UgKyBvZmZzZXRdID0gdmFsdWU7XG4gIH1cblxuICBzbGljZTxUID0gdW5rbm93bj4oc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpOiBUW10ge1xuICAgIHJldHVybiB0aGlzLnN0YWNrLnNsaWNlKHN0YXJ0LCBlbmQpIGFzIFRbXTtcbiAgfVxuXG4gIGNhcHR1cmUoaXRlbXM6IG51bWJlcik6IHVua25vd25bXSB7XG4gICAgbGV0IGVuZCA9IHRoaXNbUkVHSVNURVJTXVskc3BdICsgMTtcbiAgICBsZXQgc3RhcnQgPSBlbmQgLSBpdGVtcztcbiAgICByZXR1cm4gdGhpcy5zdGFjay5zbGljZShzdGFydCwgZW5kKTtcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuc3RhY2subGVuZ3RoID0gMDtcbiAgfVxuXG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2suc2xpY2UodGhpc1tSRUdJU1RFUlNdWyRmcF0sIHRoaXNbUkVHSVNURVJTXVskc3BdICsgMSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7IGFzc2VydEdsb2JhbENvbnRleHRXYXNTZXQgfSBmcm9tICdAZ2xpbW1lci9nbG9iYWwtY29udGV4dCc7XG5pbXBvcnQge1xuICBDb21waWxhYmxlVGVtcGxhdGUsXG4gIERlc3Ryb3lhYmxlLFxuICBEeW5hbWljU2NvcGUsXG4gIEVsZW1lbnRCdWlsZGVyLFxuICBFbnZpcm9ubWVudCxcbiAgT3B0aW9uLFxuICBQYXJ0aWFsU2NvcGUsXG4gIFJlbmRlclJlc3VsdCxcbiAgUmljaEl0ZXJhdG9yUmVzdWx0LFxuICBSdW50aW1lQ29uc3RhbnRzLFxuICBSdW50aW1lQ29udGV4dCxcbiAgUnVudGltZUhlYXAsXG4gIFJ1bnRpbWVQcm9ncmFtLFxuICBTY29wZSxcbiAgQ29tcGlsZVRpbWVDb21waWxhdGlvbkNvbnRleHQsXG4gIFZNIGFzIFB1YmxpY1ZNLFxuICBSZXNvbHV0aW9uVGltZUNvbnN0YW50cyxcbiAgT3duZXIsXG4gIFVwZGF0aW5nT3Bjb2RlLFxufSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IExPQ0FMX1NIT1VMRF9MT0cgfSBmcm9tICdAZ2xpbW1lci9sb2NhbC1kZWJ1Zy1mbGFncyc7XG5pbXBvcnQgeyBSdW50aW1lT3BJbXBsIH0gZnJvbSAnQGdsaW1tZXIvcHJvZ3JhbSc7XG5pbXBvcnQge1xuICBjcmVhdGVJdGVyYXRvckl0ZW1SZWYsXG4gIE9wYXF1ZUl0ZXJhdGlvbkl0ZW0sXG4gIE9wYXF1ZUl0ZXJhdG9yLFxuICBSZWZlcmVuY2UsXG4gIFVOREVGSU5FRF9SRUZFUkVOQ0UsXG59IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQgeyBhc3NlcnQsIGV4cGVjdCwgTE9DQUxfTE9HR0VSLCBTdGFjaywgdW53cmFwSGFuZGxlIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyBiZWdpblRyYWNrRnJhbWUsIGVuZFRyYWNrRnJhbWUsIHJlc2V0VHJhY2tpbmcgfSBmcm9tICdAZ2xpbW1lci92YWxpZGF0b3InO1xuaW1wb3J0IHtcbiAgJGZwLFxuICAkcGMsXG4gICRzMCxcbiAgJHMxLFxuICAkc3AsXG4gICR0MCxcbiAgJHQxLFxuICAkdjAsXG4gIGlzTG93TGV2ZWxSZWdpc3RlcixcbiAgTWFjaGluZVJlZ2lzdGVyLFxuICBSZWdpc3RlcixcbiAgU3lzY2FsbFJlZ2lzdGVyLFxufSBmcm9tICdAZ2xpbW1lci92bSc7XG5pbXBvcnQgeyBhc3NvY2lhdGVEZXN0cm95YWJsZUNoaWxkIH0gZnJvbSAnQGdsaW1tZXIvZGVzdHJveWFibGUnO1xuaW1wb3J0IHtcbiAgQmVnaW5UcmFja0ZyYW1lT3Bjb2RlLFxuICBFbmRUcmFja0ZyYW1lT3Bjb2RlLFxuICBKdW1wSWZOb3RNb2RpZmllZE9wY29kZSxcbn0gZnJvbSAnLi4vY29tcGlsZWQvb3Bjb2Rlcy92bSc7XG5pbXBvcnQgeyBBUFBFTkRfT1BDT0RFUywgRGVidWdTdGF0ZSB9IGZyb20gJy4uL29wY29kZXMnO1xuaW1wb3J0IHsgUGFydGlhbFNjb3BlSW1wbCB9IGZyb20gJy4uL3Njb3BlJztcbmltcG9ydCB7IEFSR1MsIENPTlNUQU5UUywgREVTVFJPWUFCTEVfU1RBQ0ssIEhFQVAsIElOTkVSX1ZNLCBSRUdJU1RFUlMsIFNUQUNLUyB9IGZyb20gJy4uL3N5bWJvbHMnO1xuaW1wb3J0IHsgVk1Bcmd1bWVudHNJbXBsIH0gZnJvbSAnLi9hcmd1bWVudHMnO1xuaW1wb3J0IHsgTGl2ZUJsb2NrTGlzdCB9IGZyb20gJy4vZWxlbWVudC1idWlsZGVyJztcbmltcG9ydCBMb3dMZXZlbFZNIGZyb20gJy4vbG93LWxldmVsJztcbmltcG9ydCBSZW5kZXJSZXN1bHRJbXBsIGZyb20gJy4vcmVuZGVyLXJlc3VsdCc7XG5pbXBvcnQgRXZhbHVhdGlvblN0YWNrSW1wbCwgeyBFdmFsdWF0aW9uU3RhY2sgfSBmcm9tICcuL3N0YWNrJztcbmltcG9ydCB7XG4gIEJsb2NrT3Bjb2RlLFxuICBMaXN0QmxvY2tPcGNvZGUsXG4gIExpc3RJdGVtT3Bjb2RlLFxuICBSZXN1bWFibGVWTVN0YXRlLFxuICBSZXN1bWFibGVWTVN0YXRlSW1wbCxcbiAgVHJ5T3Bjb2RlLFxuICBWTVN0YXRlLFxufSBmcm9tICcuL3VwZGF0ZSc7XG5cbi8qKlxuICogVGhpcyBpbnRlcmZhY2UgaXMgdXNlZCBieSBpbnRlcm5hbCBvcGNvZGVzLCBhbmQgaXMgbW9yZSBzdGFibGUgdGhhblxuICogdGhlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBBcHBlbmQgVk0gaXRzZWxmLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEludGVybmFsVk0ge1xuICByZWFkb25seSBbQ09OU1RBTlRTXTogUnVudGltZUNvbnN0YW50cyAmIFJlc29sdXRpb25UaW1lQ29uc3RhbnRzO1xuICByZWFkb25seSBbQVJHU106IFZNQXJndW1lbnRzSW1wbDtcblxuICByZWFkb25seSBlbnY6IEVudmlyb25tZW50O1xuICByZWFkb25seSBzdGFjazogRXZhbHVhdGlvblN0YWNrO1xuICByZWFkb25seSBydW50aW1lOiBSdW50aW1lQ29udGV4dDtcbiAgcmVhZG9ubHkgY29udGV4dDogQ29tcGlsZVRpbWVDb21waWxhdGlvbkNvbnRleHQ7XG5cbiAgbG9hZFZhbHVlKHJlZ2lzdGVyOiBNYWNoaW5lUmVnaXN0ZXIsIHZhbHVlOiBudW1iZXIpOiB2b2lkO1xuICBsb2FkVmFsdWUocmVnaXN0ZXI6IFJlZ2lzdGVyLCB2YWx1ZTogdW5rbm93bik6IHZvaWQ7XG4gIGxvYWRWYWx1ZShyZWdpc3RlcjogUmVnaXN0ZXIgfCBNYWNoaW5lUmVnaXN0ZXIsIHZhbHVlOiB1bmtub3duKTogdm9pZDtcblxuICBmZXRjaFZhbHVlKHJlZ2lzdGVyOiBNYWNoaW5lUmVnaXN0ZXIucmEgfCBNYWNoaW5lUmVnaXN0ZXIucGMpOiBudW1iZXI7XG4gIC8vIFRPRE86IFNvbWV0aGluZyBiZXR0ZXIgdGhhbiBhIHR5cGUgYXNzZXJ0aW9uP1xuICBmZXRjaFZhbHVlPFQ+KHJlZ2lzdGVyOiBSZWdpc3Rlcik6IFQ7XG4gIGZldGNoVmFsdWUocmVnaXN0ZXI6IFJlZ2lzdGVyKTogdW5rbm93bjtcblxuICBsb2FkKHJlZ2lzdGVyOiBSZWdpc3Rlcik6IHZvaWQ7XG4gIGZldGNoKHJlZ2lzdGVyOiBSZWdpc3Rlcik6IHZvaWQ7XG5cbiAgY29tcGlsZShibG9jazogQ29tcGlsYWJsZVRlbXBsYXRlKTogbnVtYmVyO1xuXG4gIHNjb3BlKCk6IFNjb3BlO1xuICBlbGVtZW50cygpOiBFbGVtZW50QnVpbGRlcjtcblxuICBnZXRPd25lcigpOiBPd25lcjtcbiAgZ2V0U2VsZigpOiBSZWZlcmVuY2U7XG5cbiAgdXBkYXRlV2l0aChvcGNvZGU6IFVwZGF0aW5nT3Bjb2RlKTogdm9pZDtcblxuICBhc3NvY2lhdGVEZXN0cm95YWJsZShkOiBEZXN0cm95YWJsZSk6IHZvaWQ7XG5cbiAgYmVnaW5DYWNoZUdyb3VwKG5hbWU/OiBzdHJpbmcpOiB2b2lkO1xuICBjb21taXRDYWNoZUdyb3VwKCk6IHZvaWQ7XG5cbiAgLy8vIEl0ZXJhdGlvbiAvLy9cblxuICBlbnRlckxpc3QoaXRlcmFibGVSZWY6IFJlZmVyZW5jZTxPcGFxdWVJdGVyYXRvcj4sIG9mZnNldDogbnVtYmVyKTogdm9pZDtcbiAgZXhpdExpc3QoKTogdm9pZDtcbiAgZW50ZXJJdGVtKGl0ZW06IE9wYXF1ZUl0ZXJhdGlvbkl0ZW0pOiBMaXN0SXRlbU9wY29kZTtcbiAgcmVnaXN0ZXJJdGVtKGl0ZW06IExpc3RJdGVtT3Bjb2RlKTogdm9pZDtcblxuICBwdXNoUm9vdFNjb3BlKHNpemU6IG51bWJlciwgb3duZXI6IE93bmVyKTogUGFydGlhbFNjb3BlO1xuICBwdXNoQ2hpbGRTY29wZSgpOiB2b2lkO1xuICBwb3BTY29wZSgpOiB2b2lkO1xuICBwdXNoU2NvcGUoc2NvcGU6IFNjb3BlKTogdm9pZDtcblxuICBkeW5hbWljU2NvcGUoKTogRHluYW1pY1Njb3BlO1xuICBiaW5kRHluYW1pY1Njb3BlKG5hbWVzOiBzdHJpbmdbXSk6IHZvaWQ7XG4gIHB1c2hEeW5hbWljU2NvcGUoKTogdm9pZDtcbiAgcG9wRHluYW1pY1Njb3BlKCk6IHZvaWQ7XG5cbiAgZW50ZXIoYXJnczogbnVtYmVyKTogdm9pZDtcbiAgZXhpdCgpOiB2b2lkO1xuXG4gIGdvdG8ocGM6IG51bWJlcik6IHZvaWQ7XG4gIGNhbGwoaGFuZGxlOiBudW1iZXIpOiB2b2lkO1xuICBwdXNoRnJhbWUoKTogdm9pZDtcblxuICByZWZlcmVuY2VGb3JTeW1ib2woc3ltYm9sOiBudW1iZXIpOiBSZWZlcmVuY2U7XG5cbiAgZXhlY3V0ZShpbml0aWFsaXplPzogKHZtOiB0aGlzKSA9PiB2b2lkKTogUmVuZGVyUmVzdWx0O1xuICBwdXNoVXBkYXRpbmcobGlzdD86IFVwZGF0aW5nT3Bjb2RlW10pOiB2b2lkO1xuICBuZXh0KCk6IFJpY2hJdGVyYXRvclJlc3VsdDxudWxsLCBSZW5kZXJSZXN1bHQ+O1xufVxuXG5jbGFzcyBTdGFja3Mge1xuICByZWFkb25seSBzY29wZSA9IG5ldyBTdGFjazxTY29wZT4oKTtcbiAgcmVhZG9ubHkgZHluYW1pY1Njb3BlID0gbmV3IFN0YWNrPER5bmFtaWNTY29wZT4oKTtcbiAgcmVhZG9ubHkgdXBkYXRpbmcgPSBuZXcgU3RhY2s8VXBkYXRpbmdPcGNvZGVbXT4oKTtcbiAgcmVhZG9ubHkgY2FjaGUgPSBuZXcgU3RhY2s8SnVtcElmTm90TW9kaWZpZWRPcGNvZGU+KCk7XG4gIHJlYWRvbmx5IGxpc3QgPSBuZXcgU3RhY2s8TGlzdEJsb2NrT3Bjb2RlPigpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWTSBpbXBsZW1lbnRzIFB1YmxpY1ZNLCBJbnRlcm5hbFZNIHtcbiAgcHJpdmF0ZSByZWFkb25seSBbU1RBQ0tTXSA9IG5ldyBTdGFja3MoKTtcbiAgcHJpdmF0ZSByZWFkb25seSBbSEVBUF06IFJ1bnRpbWVIZWFwO1xuICBwcml2YXRlIHJlYWRvbmx5IGRlc3RydWN0b3I6IG9iamVjdDtcbiAgcHJpdmF0ZSByZWFkb25seSBbREVTVFJPWUFCTEVfU1RBQ0tdID0gbmV3IFN0YWNrPG9iamVjdD4oKTtcbiAgcmVhZG9ubHkgW0NPTlNUQU5UU106IFJ1bnRpbWVDb25zdGFudHMgJiBSZXNvbHV0aW9uVGltZUNvbnN0YW50cztcbiAgcmVhZG9ubHkgW0FSR1NdOiBWTUFyZ3VtZW50c0ltcGw7XG4gIHJlYWRvbmx5IFtJTk5FUl9WTV06IExvd0xldmVsVk07XG5cbiAgZ2V0IHN0YWNrKCk6IEV2YWx1YXRpb25TdGFjayB7XG4gICAgcmV0dXJuIHRoaXNbSU5ORVJfVk1dLnN0YWNrIGFzIEV2YWx1YXRpb25TdGFjaztcbiAgfVxuXG4gIC8qIFJlZ2lzdGVycyAqL1xuXG4gIGdldCBwYygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzW0lOTkVSX1ZNXS5mZXRjaFJlZ2lzdGVyKCRwYyk7XG4gIH1cblxuICBwdWJsaWMgczA6IHVua25vd24gPSBudWxsO1xuICBwdWJsaWMgczE6IHVua25vd24gPSBudWxsO1xuICBwdWJsaWMgdDA6IHVua25vd24gPSBudWxsO1xuICBwdWJsaWMgdDE6IHVua25vd24gPSBudWxsO1xuICBwdWJsaWMgdjA6IHVua25vd24gPSBudWxsO1xuXG4gIC8vIEZldGNoIGEgdmFsdWUgZnJvbSBhIHJlZ2lzdGVyIG9udG8gdGhlIHN0YWNrXG4gIGZldGNoKHJlZ2lzdGVyOiBTeXNjYWxsUmVnaXN0ZXIpOiB2b2lkIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLmZldGNoVmFsdWUocmVnaXN0ZXIpO1xuXG4gICAgdGhpcy5zdGFjay5wdXNoKHZhbHVlKTtcbiAgfVxuXG4gIC8vIExvYWQgYSB2YWx1ZSBmcm9tIHRoZSBzdGFjayBpbnRvIGEgcmVnaXN0ZXJcbiAgbG9hZChyZWdpc3RlcjogU3lzY2FsbFJlZ2lzdGVyKSB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5zdGFjay5wb3AoKTtcblxuICAgIHRoaXMubG9hZFZhbHVlKHJlZ2lzdGVyLCB2YWx1ZSk7XG4gIH1cblxuICAvLyBGZXRjaCBhIHZhbHVlIGZyb20gYSByZWdpc3RlclxuICBmZXRjaFZhbHVlKHJlZ2lzdGVyOiBNYWNoaW5lUmVnaXN0ZXIpOiBudW1iZXI7XG4gIGZldGNoVmFsdWU8VD4ocmVnaXN0ZXI6IFJlZ2lzdGVyKTogVDtcbiAgZmV0Y2hWYWx1ZShyZWdpc3RlcjogUmVnaXN0ZXIgfCBNYWNoaW5lUmVnaXN0ZXIpOiB1bmtub3duIHtcbiAgICBpZiAoaXNMb3dMZXZlbFJlZ2lzdGVyKHJlZ2lzdGVyKSkge1xuICAgICAgcmV0dXJuIHRoaXNbSU5ORVJfVk1dLmZldGNoUmVnaXN0ZXIocmVnaXN0ZXIpO1xuICAgIH1cblxuICAgIHN3aXRjaCAocmVnaXN0ZXIpIHtcbiAgICAgIGNhc2UgJHMwOlxuICAgICAgICByZXR1cm4gdGhpcy5zMDtcbiAgICAgIGNhc2UgJHMxOlxuICAgICAgICByZXR1cm4gdGhpcy5zMTtcbiAgICAgIGNhc2UgJHQwOlxuICAgICAgICByZXR1cm4gdGhpcy50MDtcbiAgICAgIGNhc2UgJHQxOlxuICAgICAgICByZXR1cm4gdGhpcy50MTtcbiAgICAgIGNhc2UgJHYwOlxuICAgICAgICByZXR1cm4gdGhpcy52MDtcbiAgICB9XG4gIH1cblxuICAvLyBMb2FkIGEgdmFsdWUgaW50byBhIHJlZ2lzdGVyXG5cbiAgbG9hZFZhbHVlPFQ+KHJlZ2lzdGVyOiBSZWdpc3RlciB8IE1hY2hpbmVSZWdpc3RlciwgdmFsdWU6IFQpOiB2b2lkIHtcbiAgICBpZiAoaXNMb3dMZXZlbFJlZ2lzdGVyKHJlZ2lzdGVyKSkge1xuICAgICAgdGhpc1tJTk5FUl9WTV0ubG9hZFJlZ2lzdGVyKHJlZ2lzdGVyLCAodmFsdWUgYXMgYW55KSBhcyBudW1iZXIpO1xuICAgIH1cblxuICAgIHN3aXRjaCAocmVnaXN0ZXIpIHtcbiAgICAgIGNhc2UgJHMwOlxuICAgICAgICB0aGlzLnMwID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAkczE6XG4gICAgICAgIHRoaXMuczEgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICR0MDpcbiAgICAgICAgdGhpcy50MCA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJHQxOlxuICAgICAgICB0aGlzLnQxID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAkdjA6XG4gICAgICAgIHRoaXMudjAgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1pZ3JhdGVkIHRvIElubmVyXG4gICAqL1xuXG4gIC8vIFN0YXJ0IGEgbmV3IGZyYW1lIGFuZCBzYXZlICRyYSBhbmQgJGZwIG9uIHRoZSBzdGFja1xuICBwdXNoRnJhbWUoKSB7XG4gICAgdGhpc1tJTk5FUl9WTV0ucHVzaEZyYW1lKCk7XG4gIH1cblxuICAvLyBSZXN0b3JlICRyYSwgJHNwIGFuZCAkZnBcbiAgcG9wRnJhbWUoKSB7XG4gICAgdGhpc1tJTk5FUl9WTV0ucG9wRnJhbWUoKTtcbiAgfVxuXG4gIC8vIEp1bXAgdG8gYW4gYWRkcmVzcyBpbiBgcHJvZ3JhbWBcbiAgZ290byhvZmZzZXQ6IG51bWJlcikge1xuICAgIHRoaXNbSU5ORVJfVk1dLmdvdG8ob2Zmc2V0KTtcbiAgfVxuXG4gIC8vIFNhdmUgJHBjIGludG8gJHJhLCB0aGVuIGp1bXAgdG8gYSBuZXcgYWRkcmVzcyBpbiBgcHJvZ3JhbWAgKGphbCBpbiBNSVBTKVxuICBjYWxsKGhhbmRsZTogbnVtYmVyKSB7XG4gICAgdGhpc1tJTk5FUl9WTV0uY2FsbChoYW5kbGUpO1xuICB9XG5cbiAgLy8gUHV0IGEgc3BlY2lmaWMgYHByb2dyYW1gIGFkZHJlc3MgaW4gJHJhXG4gIHJldHVyblRvKG9mZnNldDogbnVtYmVyKSB7XG4gICAgdGhpc1tJTk5FUl9WTV0ucmV0dXJuVG8ob2Zmc2V0KTtcbiAgfVxuXG4gIC8vIFJldHVybiB0byB0aGUgYHByb2dyYW1gIGFkZHJlc3Mgc3RvcmVkIGluICRyYVxuICByZXR1cm4oKSB7XG4gICAgdGhpc1tJTk5FUl9WTV0ucmV0dXJuKCk7XG4gIH1cblxuICAvKipcbiAgICogRW5kIG9mIG1pZ3JhdGVkLlxuICAgKi9cblxuICBjb25zdHJ1Y3RvcihcbiAgICByZWFkb25seSBydW50aW1lOiBSdW50aW1lQ29udGV4dCxcbiAgICB7IHBjLCBzY29wZSwgZHluYW1pY1Njb3BlLCBzdGFjayB9OiBWTVN0YXRlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZWxlbWVudFN0YWNrOiBFbGVtZW50QnVpbGRlcixcbiAgICByZWFkb25seSBjb250ZXh0OiBDb21waWxlVGltZUNvbXBpbGF0aW9uQ29udGV4dFxuICApIHtcbiAgICBpZiAoREVCVUcpIHtcbiAgICAgIGFzc2VydEdsb2JhbENvbnRleHRXYXNTZXQhKCk7XG4gICAgfVxuXG4gICAgbGV0IGV2YWxTdGFjayA9IEV2YWx1YXRpb25TdGFja0ltcGwucmVzdG9yZShzdGFjayk7XG5cbiAgICBhc3NlcnQodHlwZW9mIHBjID09PSAnbnVtYmVyJywgJ3BjIGlzIGEgbnVtYmVyJyk7XG5cbiAgICBldmFsU3RhY2tbUkVHSVNURVJTXVskcGNdID0gcGM7XG4gICAgZXZhbFN0YWNrW1JFR0lTVEVSU11bJHNwXSA9IHN0YWNrLmxlbmd0aCAtIDE7XG4gICAgZXZhbFN0YWNrW1JFR0lTVEVSU11bJGZwXSA9IC0xO1xuXG4gICAgdGhpc1tIRUFQXSA9IHRoaXMucHJvZ3JhbS5oZWFwO1xuICAgIHRoaXNbQ09OU1RBTlRTXSA9IHRoaXMucHJvZ3JhbS5jb25zdGFudHM7XG4gICAgdGhpcy5lbGVtZW50U3RhY2sgPSBlbGVtZW50U3RhY2s7XG4gICAgdGhpc1tTVEFDS1NdLnNjb3BlLnB1c2goc2NvcGUpO1xuICAgIHRoaXNbU1RBQ0tTXS5keW5hbWljU2NvcGUucHVzaChkeW5hbWljU2NvcGUpO1xuICAgIHRoaXNbQVJHU10gPSBuZXcgVk1Bcmd1bWVudHNJbXBsKCk7XG4gICAgdGhpc1tJTk5FUl9WTV0gPSBuZXcgTG93TGV2ZWxWTShcbiAgICAgIGV2YWxTdGFjayxcbiAgICAgIHRoaXNbSEVBUF0sXG4gICAgICBydW50aW1lLnByb2dyYW0sXG4gICAgICB7XG4gICAgICAgIGRlYnVnQmVmb3JlOiAob3Bjb2RlOiBSdW50aW1lT3BJbXBsKTogRGVidWdTdGF0ZSA9PiB7XG4gICAgICAgICAgcmV0dXJuIEFQUEVORF9PUENPREVTLmRlYnVnQmVmb3JlKHRoaXMsIG9wY29kZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVidWdBZnRlcjogKHN0YXRlOiBEZWJ1Z1N0YXRlKTogdm9pZCA9PiB7XG4gICAgICAgICAgQVBQRU5EX09QQ09ERVMuZGVidWdBZnRlcih0aGlzLCBzdGF0ZSk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgZXZhbFN0YWNrW1JFR0lTVEVSU11cbiAgICApO1xuXG4gICAgdGhpcy5kZXN0cnVjdG9yID0ge307XG4gICAgdGhpc1tERVNUUk9ZQUJMRV9TVEFDS10ucHVzaCh0aGlzLmRlc3RydWN0b3IpO1xuICB9XG5cbiAgc3RhdGljIGluaXRpYWwoXG4gICAgcnVudGltZTogUnVudGltZUNvbnRleHQsXG4gICAgY29udGV4dDogQ29tcGlsZVRpbWVDb21waWxhdGlvbkNvbnRleHQsXG4gICAgeyBoYW5kbGUsIHNlbGYsIGR5bmFtaWNTY29wZSwgdHJlZUJ1aWxkZXIsIG51bVN5bWJvbHMsIG93bmVyIH06IEluaXRPcHRpb25zXG4gICkge1xuICAgIGxldCBzY29wZSA9IFBhcnRpYWxTY29wZUltcGwucm9vdChzZWxmLCBudW1TeW1ib2xzLCBvd25lcik7XG4gICAgbGV0IHN0YXRlID0gdm1TdGF0ZShydW50aW1lLnByb2dyYW0uaGVhcC5nZXRhZGRyKGhhbmRsZSksIHNjb3BlLCBkeW5hbWljU2NvcGUpO1xuICAgIGxldCB2bSA9IGluaXRWTShjb250ZXh0KShydW50aW1lLCBzdGF0ZSwgdHJlZUJ1aWxkZXIpO1xuICAgIHZtLnB1c2hVcGRhdGluZygpO1xuICAgIHJldHVybiB2bTtcbiAgfVxuXG4gIHN0YXRpYyBlbXB0eShcbiAgICBydW50aW1lOiBSdW50aW1lQ29udGV4dCxcbiAgICB7IGhhbmRsZSwgdHJlZUJ1aWxkZXIsIGR5bmFtaWNTY29wZSwgb3duZXIgfTogTWluaW1hbEluaXRPcHRpb25zLFxuICAgIGNvbnRleHQ6IENvbXBpbGVUaW1lQ29tcGlsYXRpb25Db250ZXh0XG4gICkge1xuICAgIGxldCB2bSA9IGluaXRWTShjb250ZXh0KShcbiAgICAgIHJ1bnRpbWUsXG4gICAgICB2bVN0YXRlKFxuICAgICAgICBydW50aW1lLnByb2dyYW0uaGVhcC5nZXRhZGRyKGhhbmRsZSksXG4gICAgICAgIFBhcnRpYWxTY29wZUltcGwucm9vdChVTkRFRklORURfUkVGRVJFTkNFLCAwLCBvd25lciksXG4gICAgICAgIGR5bmFtaWNTY29wZVxuICAgICAgKSxcbiAgICAgIHRyZWVCdWlsZGVyXG4gICAgKTtcbiAgICB2bS5wdXNoVXBkYXRpbmcoKTtcbiAgICByZXR1cm4gdm07XG4gIH1cblxuICBwcml2YXRlIHJlc3VtZTogVm1Jbml0Q2FsbGJhY2sgPSBpbml0Vk0odGhpcy5jb250ZXh0KTtcblxuICBjb21waWxlKGJsb2NrOiBDb21waWxhYmxlVGVtcGxhdGUpOiBudW1iZXIge1xuICAgIGxldCBoYW5kbGUgPSB1bndyYXBIYW5kbGUoYmxvY2suY29tcGlsZSh0aGlzLmNvbnRleHQpKTtcblxuICAgIHJldHVybiBoYW5kbGU7XG4gIH1cblxuICBnZXQgcHJvZ3JhbSgpOiBSdW50aW1lUHJvZ3JhbSB7XG4gICAgcmV0dXJuIHRoaXMucnVudGltZS5wcm9ncmFtO1xuICB9XG5cbiAgZ2V0IGVudigpOiBFbnZpcm9ubWVudCB7XG4gICAgcmV0dXJuIHRoaXMucnVudGltZS5lbnY7XG4gIH1cblxuICBjYXB0dXJlU3RhdGUoYXJnczogbnVtYmVyLCBwYyA9IHRoaXNbSU5ORVJfVk1dLmZldGNoUmVnaXN0ZXIoJHBjKSk6IFZNU3RhdGUge1xuICAgIHJldHVybiB7XG4gICAgICBwYyxcbiAgICAgIHNjb3BlOiB0aGlzLnNjb3BlKCksXG4gICAgICBkeW5hbWljU2NvcGU6IHRoaXMuZHluYW1pY1Njb3BlKCksXG4gICAgICBzdGFjazogdGhpcy5zdGFjay5jYXB0dXJlKGFyZ3MpLFxuICAgIH07XG4gIH1cblxuICBjYXB0dXJlKGFyZ3M6IG51bWJlciwgcGMgPSB0aGlzW0lOTkVSX1ZNXS5mZXRjaFJlZ2lzdGVyKCRwYykpOiBSZXN1bWFibGVWTVN0YXRlIHtcbiAgICByZXR1cm4gbmV3IFJlc3VtYWJsZVZNU3RhdGVJbXBsKHRoaXMuY2FwdHVyZVN0YXRlKGFyZ3MsIHBjKSwgdGhpcy5yZXN1bWUpO1xuICB9XG5cbiAgYmVnaW5DYWNoZUdyb3VwKG5hbWU/OiBzdHJpbmcpIHtcbiAgICBsZXQgb3Bjb2RlcyA9IHRoaXMudXBkYXRpbmcoKTtcbiAgICBsZXQgZ3VhcmQgPSBuZXcgSnVtcElmTm90TW9kaWZpZWRPcGNvZGUoKTtcblxuICAgIG9wY29kZXMucHVzaChndWFyZCk7XG4gICAgb3Bjb2Rlcy5wdXNoKG5ldyBCZWdpblRyYWNrRnJhbWVPcGNvZGUobmFtZSkpO1xuICAgIHRoaXNbU1RBQ0tTXS5jYWNoZS5wdXNoKGd1YXJkKTtcblxuICAgIGJlZ2luVHJhY2tGcmFtZShuYW1lKTtcbiAgfVxuXG4gIGNvbW1pdENhY2hlR3JvdXAoKSB7XG4gICAgbGV0IG9wY29kZXMgPSB0aGlzLnVwZGF0aW5nKCk7XG4gICAgbGV0IGd1YXJkID0gZXhwZWN0KHRoaXNbU1RBQ0tTXS5jYWNoZS5wb3AoKSwgJ1ZNIEJVRzogRXhwZWN0ZWQgYSBjYWNoZSBncm91cCcpO1xuXG4gICAgbGV0IHRhZyA9IGVuZFRyYWNrRnJhbWUoKTtcbiAgICBvcGNvZGVzLnB1c2gobmV3IEVuZFRyYWNrRnJhbWVPcGNvZGUoZ3VhcmQpKTtcblxuICAgIGd1YXJkLmZpbmFsaXplKHRhZywgb3Bjb2Rlcy5sZW5ndGgpO1xuICB9XG5cbiAgZW50ZXIoYXJnczogbnVtYmVyKSB7XG4gICAgbGV0IHVwZGF0aW5nOiBVcGRhdGluZ09wY29kZVtdID0gW107XG5cbiAgICBsZXQgc3RhdGUgPSB0aGlzLmNhcHR1cmUoYXJncyk7XG4gICAgbGV0IGJsb2NrID0gdGhpcy5lbGVtZW50cygpLnB1c2hVcGRhdGFibGVCbG9jaygpO1xuXG4gICAgbGV0IHRyeU9wY29kZSA9IG5ldyBUcnlPcGNvZGUoc3RhdGUsIHRoaXMucnVudGltZSwgYmxvY2ssIHVwZGF0aW5nKTtcblxuICAgIHRoaXMuZGlkRW50ZXIodHJ5T3Bjb2RlKTtcbiAgfVxuXG4gIGVudGVySXRlbSh7IGtleSwgdmFsdWUsIG1lbW8gfTogT3BhcXVlSXRlcmF0aW9uSXRlbSk6IExpc3RJdGVtT3Bjb2RlIHtcbiAgICBsZXQgeyBzdGFjayB9ID0gdGhpcztcblxuICAgIGxldCB2YWx1ZVJlZiA9IGNyZWF0ZUl0ZXJhdG9ySXRlbVJlZih2YWx1ZSk7XG4gICAgbGV0IG1lbW9SZWYgPSBjcmVhdGVJdGVyYXRvckl0ZW1SZWYobWVtbyk7XG5cbiAgICBzdGFjay5wdXNoKHZhbHVlUmVmKTtcbiAgICBzdGFjay5wdXNoKG1lbW9SZWYpO1xuXG4gICAgbGV0IHN0YXRlID0gdGhpcy5jYXB0dXJlKDIpO1xuICAgIGxldCBibG9jayA9IHRoaXMuZWxlbWVudHMoKS5wdXNoVXBkYXRhYmxlQmxvY2soKTtcblxuICAgIGxldCBvcGNvZGUgPSBuZXcgTGlzdEl0ZW1PcGNvZGUoc3RhdGUsIHRoaXMucnVudGltZSwgYmxvY2ssIGtleSwgbWVtb1JlZiwgdmFsdWVSZWYpO1xuICAgIHRoaXMuZGlkRW50ZXIob3Bjb2RlKTtcblxuICAgIHJldHVybiBvcGNvZGU7XG4gIH1cblxuICByZWdpc3Rlckl0ZW0ob3Bjb2RlOiBMaXN0SXRlbU9wY29kZSkge1xuICAgIHRoaXMubGlzdEJsb2NrKCkuaW5pdGlhbGl6ZUNoaWxkKG9wY29kZSk7XG4gIH1cblxuICBlbnRlckxpc3QoaXRlcmFibGVSZWY6IFJlZmVyZW5jZTxPcGFxdWVJdGVyYXRvcj4sIG9mZnNldDogbnVtYmVyKSB7XG4gICAgbGV0IHVwZGF0aW5nOiBMaXN0SXRlbU9wY29kZVtdID0gW107XG5cbiAgICBsZXQgYWRkciA9IHRoaXNbSU5ORVJfVk1dLnRhcmdldChvZmZzZXQpO1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuY2FwdHVyZSgwLCBhZGRyKTtcbiAgICBsZXQgbGlzdCA9IHRoaXMuZWxlbWVudHMoKS5wdXNoQmxvY2tMaXN0KHVwZGF0aW5nKSBhcyBMaXZlQmxvY2tMaXN0O1xuXG4gICAgbGV0IG9wY29kZSA9IG5ldyBMaXN0QmxvY2tPcGNvZGUoc3RhdGUsIHRoaXMucnVudGltZSwgbGlzdCwgdXBkYXRpbmcsIGl0ZXJhYmxlUmVmKTtcblxuICAgIHRoaXNbU1RBQ0tTXS5saXN0LnB1c2gob3Bjb2RlKTtcblxuICAgIHRoaXMuZGlkRW50ZXIob3Bjb2RlKTtcbiAgfVxuXG4gIHByaXZhdGUgZGlkRW50ZXIob3Bjb2RlOiBCbG9ja09wY29kZSkge1xuICAgIHRoaXMuYXNzb2NpYXRlRGVzdHJveWFibGUob3Bjb2RlKTtcbiAgICB0aGlzW0RFU1RST1lBQkxFX1NUQUNLXS5wdXNoKG9wY29kZSk7XG4gICAgdGhpcy51cGRhdGVXaXRoKG9wY29kZSk7XG4gICAgdGhpcy5wdXNoVXBkYXRpbmcob3Bjb2RlLmNoaWxkcmVuKTtcbiAgfVxuXG4gIGV4aXQoKSB7XG4gICAgdGhpc1tERVNUUk9ZQUJMRV9TVEFDS10ucG9wKCk7XG4gICAgdGhpcy5lbGVtZW50cygpLnBvcEJsb2NrKCk7XG4gICAgdGhpcy5wb3BVcGRhdGluZygpO1xuICB9XG5cbiAgZXhpdExpc3QoKSB7XG4gICAgdGhpcy5leGl0KCk7XG4gICAgdGhpc1tTVEFDS1NdLmxpc3QucG9wKCk7XG4gIH1cblxuICBwdXNoVXBkYXRpbmcobGlzdDogVXBkYXRpbmdPcGNvZGVbXSA9IFtdKTogdm9pZCB7XG4gICAgdGhpc1tTVEFDS1NdLnVwZGF0aW5nLnB1c2gobGlzdCk7XG4gIH1cblxuICBwb3BVcGRhdGluZygpOiBVcGRhdGluZ09wY29kZVtdIHtcbiAgICByZXR1cm4gZXhwZWN0KHRoaXNbU1RBQ0tTXS51cGRhdGluZy5wb3AoKSwgXCJjYW4ndCBwb3AgYW4gZW1wdHkgc3RhY2tcIik7XG4gIH1cblxuICB1cGRhdGVXaXRoKG9wY29kZTogVXBkYXRpbmdPcGNvZGUpIHtcbiAgICB0aGlzLnVwZGF0aW5nKCkucHVzaChvcGNvZGUpO1xuICB9XG5cbiAgbGlzdEJsb2NrKCk6IExpc3RCbG9ja09wY29kZSB7XG4gICAgcmV0dXJuIGV4cGVjdCh0aGlzW1NUQUNLU10ubGlzdC5jdXJyZW50LCAnZXhwZWN0ZWQgYSBsaXN0IGJsb2NrJyk7XG4gIH1cblxuICBhc3NvY2lhdGVEZXN0cm95YWJsZShjaGlsZDogRGVzdHJveWFibGUpOiB2b2lkIHtcbiAgICBsZXQgcGFyZW50ID0gZXhwZWN0KHRoaXNbREVTVFJPWUFCTEVfU1RBQ0tdLmN1cnJlbnQsICdFeHBlY3RlZCBkZXN0cnVjdG9yIHBhcmVudCcpO1xuICAgIGFzc29jaWF0ZURlc3Ryb3lhYmxlQ2hpbGQocGFyZW50LCBjaGlsZCk7XG4gIH1cblxuICB0cnlVcGRhdGluZygpOiBPcHRpb248VXBkYXRpbmdPcGNvZGVbXT4ge1xuICAgIHJldHVybiB0aGlzW1NUQUNLU10udXBkYXRpbmcuY3VycmVudDtcbiAgfVxuXG4gIHVwZGF0aW5nKCk6IFVwZGF0aW5nT3Bjb2RlW10ge1xuICAgIHJldHVybiBleHBlY3QoXG4gICAgICB0aGlzW1NUQUNLU10udXBkYXRpbmcuY3VycmVudCxcbiAgICAgICdleHBlY3RlZCB1cGRhdGluZyBvcGNvZGUgb24gdGhlIHVwZGF0aW5nIG9wY29kZSBzdGFjaydcbiAgICApO1xuICB9XG5cbiAgZWxlbWVudHMoKTogRWxlbWVudEJ1aWxkZXIge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRTdGFjaztcbiAgfVxuXG4gIHNjb3BlKCk6IFNjb3BlIHtcbiAgICByZXR1cm4gZXhwZWN0KHRoaXNbU1RBQ0tTXS5zY29wZS5jdXJyZW50LCAnZXhwZWN0ZWQgc2NvcGUgb24gdGhlIHNjb3BlIHN0YWNrJyk7XG4gIH1cblxuICBkeW5hbWljU2NvcGUoKTogRHluYW1pY1Njb3BlIHtcbiAgICByZXR1cm4gZXhwZWN0KFxuICAgICAgdGhpc1tTVEFDS1NdLmR5bmFtaWNTY29wZS5jdXJyZW50LFxuICAgICAgJ2V4cGVjdGVkIGR5bmFtaWMgc2NvcGUgb24gdGhlIGR5bmFtaWMgc2NvcGUgc3RhY2snXG4gICAgKTtcbiAgfVxuXG4gIHB1c2hDaGlsZFNjb3BlKCkge1xuICAgIHRoaXNbU1RBQ0tTXS5zY29wZS5wdXNoKHRoaXMuc2NvcGUoKS5jaGlsZCgpKTtcbiAgfVxuXG4gIHB1c2hEeW5hbWljU2NvcGUoKTogRHluYW1pY1Njb3BlIHtcbiAgICBsZXQgY2hpbGQgPSB0aGlzLmR5bmFtaWNTY29wZSgpLmNoaWxkKCk7XG4gICAgdGhpc1tTVEFDS1NdLmR5bmFtaWNTY29wZS5wdXNoKGNoaWxkKTtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH1cblxuICBwdXNoUm9vdFNjb3BlKHNpemU6IG51bWJlciwgb3duZXI6IE93bmVyKTogUGFydGlhbFNjb3BlIHtcbiAgICBsZXQgc2NvcGUgPSBQYXJ0aWFsU2NvcGVJbXBsLnNpemVkKHNpemUsIG93bmVyKTtcbiAgICB0aGlzW1NUQUNLU10uc2NvcGUucHVzaChzY29wZSk7XG4gICAgcmV0dXJuIHNjb3BlO1xuICB9XG5cbiAgcHVzaFNjb3BlKHNjb3BlOiBTY29wZSkge1xuICAgIHRoaXNbU1RBQ0tTXS5zY29wZS5wdXNoKHNjb3BlKTtcbiAgfVxuXG4gIHBvcFNjb3BlKCkge1xuICAgIHRoaXNbU1RBQ0tTXS5zY29wZS5wb3AoKTtcbiAgfVxuXG4gIHBvcER5bmFtaWNTY29wZSgpIHtcbiAgICB0aGlzW1NUQUNLU10uZHluYW1pY1Njb3BlLnBvcCgpO1xuICB9XG5cbiAgLy8vIFNDT1BFIEhFTFBFUlNcblxuICBnZXRPd25lcigpOiBPd25lciB7XG4gICAgcmV0dXJuIHRoaXMuc2NvcGUoKS5vd25lcjtcbiAgfVxuXG4gIGdldFNlbGYoKTogUmVmZXJlbmNlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLnNjb3BlKCkuZ2V0U2VsZigpO1xuICB9XG5cbiAgcmVmZXJlbmNlRm9yU3ltYm9sKHN5bWJvbDogbnVtYmVyKTogUmVmZXJlbmNlIHtcbiAgICByZXR1cm4gdGhpcy5zY29wZSgpLmdldFN5bWJvbChzeW1ib2wpO1xuICB9XG5cbiAgLy8vIEVYRUNVVElPTlxuXG4gIGV4ZWN1dGUoaW5pdGlhbGl6ZT86ICh2bTogdGhpcykgPT4gdm9pZCk6IFJlbmRlclJlc3VsdCB7XG4gICAgaWYgKERFQlVHKSB7XG4gICAgICBsZXQgaGFzRXJyb3JlZCA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLl9leGVjdXRlKGluaXRpYWxpemUpO1xuXG4gICAgICAgIC8vIHVzaW5nIGEgYm9vbGVhbiBoZXJlIHRvIGF2b2lkIGJyZWFraW5nIGVyZ29ub21pY3Mgb2YgXCJwYXVzZSBvbiB1bmNhdWdodCBleGNlcHRpb25zXCJcbiAgICAgICAgLy8gd2hpY2ggd291bGQgaGFwcGVuIHdpdGggYSBgY2F0Y2hgICsgYHRocm93YFxuICAgICAgICBoYXNFcnJvcmVkID0gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGhhc0Vycm9yZWQpIHtcbiAgICAgICAgICAvLyBJZiBhbnkgZXhpc3RpbmcgYmxvY2tzIGFyZSBvcGVuLCBkdWUgdG8gYW4gZXJyb3Igb3Igc29tZXRoaW5nIGxpa2VcbiAgICAgICAgICAvLyB0aGF0LCB3ZSBuZWVkIHRvIGNsb3NlIHRoZW0gYWxsIGFuZCBjbGVhbiB0aGluZ3MgdXAgcHJvcGVybHkuXG4gICAgICAgICAgbGV0IGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cygpO1xuXG4gICAgICAgICAgd2hpbGUgKGVsZW1lbnRzLmhhc0Jsb2Nrcykge1xuICAgICAgICAgICAgZWxlbWVudHMucG9wQmxvY2soKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFxcblxcbkVycm9yIG9jY3VycmVkOlxcblxcbiR7cmVzZXRUcmFja2luZygpfVxcblxcbmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9leGVjdXRlKGluaXRpYWxpemUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2V4ZWN1dGUoaW5pdGlhbGl6ZT86ICh2bTogdGhpcykgPT4gdm9pZCk6IFJlbmRlclJlc3VsdCB7XG4gICAgaWYgKExPQ0FMX1NIT1VMRF9MT0cpIHtcbiAgICAgIExPQ0FMX0xPR0dFUi5sb2coYEVYRUNVVElORyBGUk9NICR7dGhpc1tJTk5FUl9WTV0uZmV0Y2hSZWdpc3RlcigkcGMpfWApO1xuICAgIH1cblxuICAgIGlmIChpbml0aWFsaXplKSBpbml0aWFsaXplKHRoaXMpO1xuXG4gICAgbGV0IHJlc3VsdDogUmljaEl0ZXJhdG9yUmVzdWx0PG51bGwsIFJlbmRlclJlc3VsdD47XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5uZXh0KCk7XG4gICAgICBpZiAocmVzdWx0LmRvbmUpIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gIH1cblxuICBuZXh0KCk6IFJpY2hJdGVyYXRvclJlc3VsdDxudWxsLCBSZW5kZXJSZXN1bHQ+IHtcbiAgICBsZXQgeyBlbnYsIGVsZW1lbnRTdGFjayB9ID0gdGhpcztcbiAgICBsZXQgb3Bjb2RlID0gdGhpc1tJTk5FUl9WTV0ubmV4dFN0YXRlbWVudCgpO1xuICAgIGxldCByZXN1bHQ6IFJpY2hJdGVyYXRvclJlc3VsdDxudWxsLCBSZW5kZXJSZXN1bHQ+O1xuICAgIGlmIChvcGNvZGUgIT09IG51bGwpIHtcbiAgICAgIHRoaXNbSU5ORVJfVk1dLmV2YWx1YXRlT3V0ZXIob3Bjb2RlLCB0aGlzKTtcbiAgICAgIHJlc3VsdCA9IHsgZG9uZTogZmFsc2UsIHZhbHVlOiBudWxsIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVubG9hZCB0aGUgc3RhY2tcbiAgICAgIHRoaXMuc3RhY2sucmVzZXQoKTtcblxuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICB2YWx1ZTogbmV3IFJlbmRlclJlc3VsdEltcGwoXG4gICAgICAgICAgZW52LFxuICAgICAgICAgIHRoaXMucG9wVXBkYXRpbmcoKSxcbiAgICAgICAgICBlbGVtZW50U3RhY2sucG9wQmxvY2soKSxcbiAgICAgICAgICB0aGlzLmRlc3RydWN0b3JcbiAgICAgICAgKSxcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBiaW5kRHluYW1pY1Njb3BlKG5hbWVzOiBzdHJpbmdbXSkge1xuICAgIGxldCBzY29wZSA9IHRoaXMuZHluYW1pY1Njb3BlKCk7XG5cbiAgICBmb3IgKGxldCBpID0gbmFtZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGxldCBuYW1lID0gbmFtZXNbaV07XG4gICAgICBzY29wZS5zZXQobmFtZSwgdGhpcy5zdGFjay5wb3A8UmVmZXJlbmNlPHVua25vd24+PigpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdm1TdGF0ZShwYzogbnVtYmVyLCBzY29wZTogU2NvcGUsIGR5bmFtaWNTY29wZTogRHluYW1pY1Njb3BlKSB7XG4gIHJldHVybiB7XG4gICAgcGMsXG4gICAgc2NvcGUsXG4gICAgZHluYW1pY1Njb3BlLFxuICAgIHN0YWNrOiBbXSxcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNaW5pbWFsSW5pdE9wdGlvbnMge1xuICBoYW5kbGU6IG51bWJlcjtcbiAgdHJlZUJ1aWxkZXI6IEVsZW1lbnRCdWlsZGVyO1xuICBkeW5hbWljU2NvcGU6IER5bmFtaWNTY29wZTtcbiAgb3duZXI6IE93bmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEluaXRPcHRpb25zIGV4dGVuZHMgTWluaW1hbEluaXRPcHRpb25zIHtcbiAgc2VsZjogUmVmZXJlbmNlO1xuICBudW1TeW1ib2xzOiBudW1iZXI7XG59XG5cbmV4cG9ydCB0eXBlIFZtSW5pdENhbGxiYWNrID0gKFxuICB0aGlzOiB2b2lkLFxuICBydW50aW1lOiBSdW50aW1lQ29udGV4dCxcbiAgc3RhdGU6IFZNU3RhdGUsXG4gIGJ1aWxkZXI6IEVsZW1lbnRCdWlsZGVyXG4pID0+IEludGVybmFsVk07XG5cbmZ1bmN0aW9uIGluaXRWTShjb250ZXh0OiBDb21waWxlVGltZUNvbXBpbGF0aW9uQ29udGV4dCk6IFZtSW5pdENhbGxiYWNrIHtcbiAgcmV0dXJuIChydW50aW1lLCBzdGF0ZSwgYnVpbGRlcikgPT4gbmV3IFZNKHJ1bnRpbWUsIHN0YXRlLCBidWlsZGVyLCBjb250ZXh0KTtcbn1cbiIsImltcG9ydCB7XG4gIER5bmFtaWNTY29wZSxcbiAgRW52aXJvbm1lbnQsXG4gIFJlbmRlclJlc3VsdCxcbiAgUmljaEl0ZXJhdG9yUmVzdWx0LFxuICBUZW1wbGF0ZUl0ZXJhdG9yLFxuICBSdW50aW1lQ29udGV4dCxcbiAgRWxlbWVudEJ1aWxkZXIsXG4gIENvbXBpbGFibGVQcm9ncmFtLFxuICBDb21waWxlVGltZUNvbXBpbGF0aW9uQ29udGV4dCxcbiAgQ29tcG9uZW50RGVmaW5pdGlvblN0YXRlLFxuICBPd25lcixcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBjaGlsZFJlZkZvciwgY3JlYXRlQ29uc3RSZWYsIFJlZmVyZW5jZSB9IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQgeyBleHBlY3QsIHVud3JhcEhhbmRsZSB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgQVJHUywgQ09OU1RBTlRTIH0gZnJvbSAnLi9zeW1ib2xzJztcbmltcG9ydCBWTSwgeyBJbnRlcm5hbFZNIH0gZnJvbSAnLi92bS9hcHBlbmQnO1xuaW1wb3J0IHsgRHluYW1pY1Njb3BlSW1wbCB9IGZyb20gJy4vc2NvcGUnO1xuaW1wb3J0IHsgaW5UcmFuc2FjdGlvbiB9IGZyb20gJy4vZW52aXJvbm1lbnQnO1xuaW1wb3J0IHsgREVCVUcgfSBmcm9tICdAZ2xpbW1lci9lbnYnO1xuaW1wb3J0IHsgcnVuSW5UcmFja2luZ1RyYW5zYWN0aW9uIH0gZnJvbSAnQGdsaW1tZXIvdmFsaWRhdG9yJztcblxuY2xhc3MgVGVtcGxhdGVJdGVyYXRvckltcGwgaW1wbGVtZW50cyBUZW1wbGF0ZUl0ZXJhdG9yIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSB2bTogSW50ZXJuYWxWTSkge31cbiAgbmV4dCgpOiBSaWNoSXRlcmF0b3JSZXN1bHQ8bnVsbCwgUmVuZGVyUmVzdWx0PiB7XG4gICAgcmV0dXJuIHRoaXMudm0ubmV4dCgpO1xuICB9XG5cbiAgc3luYygpOiBSZW5kZXJSZXN1bHQge1xuICAgIGlmIChERUJVRykge1xuICAgICAgcmV0dXJuIHJ1bkluVHJhY2tpbmdUcmFuc2FjdGlvbiEoKCkgPT4gdGhpcy52bS5leGVjdXRlKCksICctIFdoaWxlIHJlbmRlcmluZzonKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMudm0uZXhlY3V0ZSgpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyU3luYyhlbnY6IEVudmlyb25tZW50LCBpdGVyYXRvcjogVGVtcGxhdGVJdGVyYXRvcik6IFJlbmRlclJlc3VsdCB7XG4gIGxldCByZXN1bHQ6IFJlbmRlclJlc3VsdDtcblxuICBpblRyYW5zYWN0aW9uKGVudiwgKCkgPT4gKHJlc3VsdCA9IGl0ZXJhdG9yLnN5bmMoKSkpO1xuXG4gIHJldHVybiByZXN1bHQhO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyTWFpbihcbiAgcnVudGltZTogUnVudGltZUNvbnRleHQsXG4gIGNvbnRleHQ6IENvbXBpbGVUaW1lQ29tcGlsYXRpb25Db250ZXh0LFxuICBvd25lcjogT3duZXIsXG4gIHNlbGY6IFJlZmVyZW5jZSxcbiAgdHJlZUJ1aWxkZXI6IEVsZW1lbnRCdWlsZGVyLFxuICBsYXlvdXQ6IENvbXBpbGFibGVQcm9ncmFtLFxuICBkeW5hbWljU2NvcGU6IER5bmFtaWNTY29wZSA9IG5ldyBEeW5hbWljU2NvcGVJbXBsKClcbik6IFRlbXBsYXRlSXRlcmF0b3Ige1xuICBsZXQgaGFuZGxlID0gdW53cmFwSGFuZGxlKGxheW91dC5jb21waWxlKGNvbnRleHQpKTtcbiAgbGV0IG51bVN5bWJvbHMgPSBsYXlvdXQuc3ltYm9sVGFibGUuc3ltYm9scy5sZW5ndGg7XG4gIGxldCB2bSA9IFZNLmluaXRpYWwocnVudGltZSwgY29udGV4dCwge1xuICAgIHNlbGYsXG4gICAgZHluYW1pY1Njb3BlLFxuICAgIHRyZWVCdWlsZGVyLFxuICAgIGhhbmRsZSxcbiAgICBudW1TeW1ib2xzLFxuICAgIG93bmVyLFxuICB9KTtcbiAgcmV0dXJuIG5ldyBUZW1wbGF0ZUl0ZXJhdG9ySW1wbCh2bSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckludm9jYXRpb24oXG4gIHZtOiBJbnRlcm5hbFZNLFxuICBjb250ZXh0OiBDb21waWxlVGltZUNvbXBpbGF0aW9uQ29udGV4dCxcbiAgb3duZXI6IE93bmVyLFxuICBkZWZpbml0aW9uOiBDb21wb25lbnREZWZpbml0aW9uU3RhdGUsXG4gIGFyZ3M6IFJlY29yZDxzdHJpbmcsIFJlZmVyZW5jZT5cbik6IFRlbXBsYXRlSXRlcmF0b3Ige1xuICAvLyBHZXQgYSBsaXN0IG9mIHR1cGxlcyBvZiBhcmd1bWVudCBuYW1lcyBhbmQgcmVmZXJlbmNlcywgbGlrZVxuICAvLyBbWyd0aXRsZScsIHJlZmVyZW5jZV0sIFsnbmFtZScsIHJlZmVyZW5jZV1dXG4gIGNvbnN0IGFyZ0xpc3QgPSBPYmplY3Qua2V5cyhhcmdzKS5tYXAoKGtleSkgPT4gW2tleSwgYXJnc1trZXldXSk7XG5cbiAgY29uc3QgYmxvY2tOYW1lcyA9IFsnbWFpbicsICdlbHNlJywgJ2F0dHJzJ107XG4gIC8vIFByZWZpeCBhcmd1bWVudCBuYW1lcyB3aXRoIGBAYCBzeW1ib2xcbiAgY29uc3QgYXJnTmFtZXMgPSBhcmdMaXN0Lm1hcCgoW25hbWVdKSA9PiBgQCR7bmFtZX1gKTtcblxuICBsZXQgcmVpZmllZCA9IHZtW0NPTlNUQU5UU10uY29tcG9uZW50KGRlZmluaXRpb24sIG93bmVyKTtcblxuICB2bS5wdXNoRnJhbWUoKTtcblxuICAvLyBQdXNoIGJsb2NrcyBvbiB0byB0aGUgc3RhY2ssIHRocmVlIHN0YWNrIHZhbHVlcyBwZXIgYmxvY2tcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAzICogYmxvY2tOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZtLnN0YWNrLnB1c2gobnVsbCk7XG4gIH1cblxuICB2bS5zdGFjay5wdXNoKG51bGwpO1xuXG4gIC8vIEZvciBlYWNoIGFyZ3VtZW50LCBwdXNoIGl0cyBiYWNraW5nIHJlZmVyZW5jZSBvbiB0byB0aGUgc3RhY2tcbiAgYXJnTGlzdC5mb3JFYWNoKChbLCByZWZlcmVuY2VdKSA9PiB7XG4gICAgdm0uc3RhY2sucHVzaChyZWZlcmVuY2UpO1xuICB9KTtcblxuICAvLyBDb25maWd1cmUgVk0gYmFzZWQgb24gYmxvY2tzIGFuZCBhcmdzIGp1c3QgcHVzaGVkIG9uIHRvIHRoZSBzdGFjay5cbiAgdm1bQVJHU10uc2V0dXAodm0uc3RhY2ssIGFyZ05hbWVzLCBibG9ja05hbWVzLCAwLCB0cnVlKTtcblxuICBjb25zdCBjb21waWxhYmxlID0gZXhwZWN0KFxuICAgIHJlaWZpZWQuY29tcGlsYWJsZSxcbiAgICAnQlVHOiBFeHBlY3RlZCB0aGUgcm9vdCBjb21wb25lbnQgcmVuZGVyZWQgd2l0aCByZW5kZXJDb21wb25lbnQgdG8gaGF2ZSBhbiBhc3NvY2lhdGVkIHRlbXBsYXRlLCBzZXQgd2l0aCBzZXRDb21wb25lbnRUZW1wbGF0ZSdcbiAgKTtcbiAgY29uc3QgbGF5b3V0SGFuZGxlID0gdW53cmFwSGFuZGxlKGNvbXBpbGFibGUuY29tcGlsZShjb250ZXh0KSk7XG4gIGNvbnN0IGludm9jYXRpb24gPSB7IGhhbmRsZTogbGF5b3V0SGFuZGxlLCBzeW1ib2xUYWJsZTogY29tcGlsYWJsZS5zeW1ib2xUYWJsZSB9O1xuXG4gIC8vIE5lZWRlZCBmb3IgdGhlIE9wLk1haW4gb3Bjb2RlOiBhcmd1bWVudHMsIGNvbXBvbmVudCBpbnZvY2F0aW9uIG9iamVjdCwgYW5kXG4gIC8vIGNvbXBvbmVudCBkZWZpbml0aW9uLlxuICB2bS5zdGFjay5wdXNoKHZtW0FSR1NdKTtcbiAgdm0uc3RhY2sucHVzaChpbnZvY2F0aW9uKTtcbiAgdm0uc3RhY2sucHVzaChyZWlmaWVkKTtcblxuICByZXR1cm4gbmV3IFRlbXBsYXRlSXRlcmF0b3JJbXBsKHZtKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlckNvbXBvbmVudChcbiAgcnVudGltZTogUnVudGltZUNvbnRleHQsXG4gIHRyZWVCdWlsZGVyOiBFbGVtZW50QnVpbGRlcixcbiAgY29udGV4dDogQ29tcGlsZVRpbWVDb21waWxhdGlvbkNvbnRleHQsXG4gIG93bmVyOiBPd25lcixcbiAgZGVmaW5pdGlvbjogQ29tcG9uZW50RGVmaW5pdGlvblN0YXRlLFxuICBhcmdzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHt9LFxuICBkeW5hbWljU2NvcGU6IER5bmFtaWNTY29wZSA9IG5ldyBEeW5hbWljU2NvcGVJbXBsKClcbik6IFRlbXBsYXRlSXRlcmF0b3Ige1xuICBsZXQgdm0gPSBWTS5lbXB0eShcbiAgICBydW50aW1lLFxuICAgIHsgdHJlZUJ1aWxkZXIsIGhhbmRsZTogY29udGV4dC5zdGRsaWIubWFpbiwgZHluYW1pY1Njb3BlLCBvd25lciB9LFxuICAgIGNvbnRleHRcbiAgKTtcbiAgcmV0dXJuIHJlbmRlckludm9jYXRpb24odm0sIGNvbnRleHQsIG93bmVyLCBkZWZpbml0aW9uLCByZWNvcmRUb1JlZmVyZW5jZShhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIHJlY29yZFRvUmVmZXJlbmNlKHJlY29yZDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBSZWNvcmQ8c3RyaW5nLCBSZWZlcmVuY2U+IHtcbiAgY29uc3Qgcm9vdCA9IGNyZWF0ZUNvbnN0UmVmKHJlY29yZCwgJ2FyZ3MnKTtcblxuICByZXR1cm4gT2JqZWN0LmtleXMocmVjb3JkKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgYWNjW2tleV0gPSBjaGlsZFJlZkZvcihyb290LCBrZXkpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9IGFzIFJlY29yZDxzdHJpbmcsIFJlZmVyZW5jZT4pO1xufVxuIiwiaW1wb3J0IHsgQm91bmRzLCBFbGVtZW50QnVpbGRlciwgRW52aXJvbm1lbnQsIE9wdGlvbiwgTWF5YmUgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGFzc2VydCwgY2FzdFRvQnJvd3NlciwgY2FzdFRvU2ltcGxlLCBleHBlY3QsIFN0YWNrIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQge1xuICBBdHRyTmFtZXNwYWNlLFxuICBOYW1lc3BhY2UsXG4gIE5vZGVUeXBlLFxuICBTaW1wbGVBdHRyLFxuICBTaW1wbGVDb21tZW50LFxuICBTaW1wbGVFbGVtZW50LFxuICBTaW1wbGVOb2RlLFxuICBTaW1wbGVUZXh0LFxufSBmcm9tICdAc2ltcGxlLWRvbS9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgQ29uY3JldGVCb3VuZHMsIEN1cnNvckltcGwgfSBmcm9tICcuLi9ib3VuZHMnO1xuaW1wb3J0IHsgQ1VSU09SX1NUQUNLLCBOZXdFbGVtZW50QnVpbGRlciwgUmVtb3RlTGl2ZUJsb2NrIH0gZnJvbSAnLi9lbGVtZW50LWJ1aWxkZXInO1xuXG5leHBvcnQgY29uc3QgU0VSSUFMSVpBVElPTl9GSVJTVF9OT0RFX1NUUklORyA9ICclK2I6MCUnO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNTZXJpYWxpemF0aW9uRmlyc3ROb2RlKG5vZGU6IFNpbXBsZU5vZGUpOiBib29sZWFuIHtcbiAgcmV0dXJuIG5vZGUubm9kZVZhbHVlID09PSBTRVJJQUxJWkFUSU9OX0ZJUlNUX05PREVfU1RSSU5HO1xufVxuXG5leHBvcnQgY2xhc3MgUmVoeWRyYXRpbmdDdXJzb3IgZXh0ZW5kcyBDdXJzb3JJbXBsIHtcbiAgY2FuZGlkYXRlOiBPcHRpb248U2ltcGxlTm9kZT4gPSBudWxsO1xuICBvcGVuQmxvY2tEZXB0aDogbnVtYmVyO1xuICBpbmplY3RlZE9taXR0ZWROb2RlID0gZmFsc2U7XG4gIGNvbnN0cnVjdG9yKFxuICAgIGVsZW1lbnQ6IFNpbXBsZUVsZW1lbnQsXG4gICAgbmV4dFNpYmxpbmc6IE9wdGlvbjxTaW1wbGVOb2RlPixcbiAgICBwdWJsaWMgcmVhZG9ubHkgc3RhcnRpbmdCbG9ja0RlcHRoOiBudW1iZXJcbiAgKSB7XG4gICAgc3VwZXIoZWxlbWVudCwgbmV4dFNpYmxpbmcpO1xuICAgIHRoaXMub3BlbkJsb2NrRGVwdGggPSBzdGFydGluZ0Jsb2NrRGVwdGggLSAxO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBSZWh5ZHJhdGVCdWlsZGVyIGV4dGVuZHMgTmV3RWxlbWVudEJ1aWxkZXIgaW1wbGVtZW50cyBFbGVtZW50QnVpbGRlciB7XG4gIHByaXZhdGUgdW5tYXRjaGVkQXR0cmlidXRlczogT3B0aW9uPFNpbXBsZUF0dHJbXT4gPSBudWxsO1xuICBbQ1VSU09SX1NUQUNLXSE6IFN0YWNrPFJlaHlkcmF0aW5nQ3Vyc29yPjsgLy8gSGlkZXMgcHJvcGVydHkgb24gYmFzZSBjbGFzc1xuICBibG9ja0RlcHRoID0gMDtcbiAgc3RhcnRpbmdCbG9ja09mZnNldDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKGVudjogRW52aXJvbm1lbnQsIHBhcmVudE5vZGU6IFNpbXBsZUVsZW1lbnQsIG5leHRTaWJsaW5nOiBPcHRpb248U2ltcGxlTm9kZT4pIHtcbiAgICBzdXBlcihlbnYsIHBhcmVudE5vZGUsIG5leHRTaWJsaW5nKTtcbiAgICBpZiAobmV4dFNpYmxpbmcpIHRocm93IG5ldyBFcnJvcignUmVoeWRyYXRpb24gd2l0aCBuZXh0U2libGluZyBub3Qgc3VwcG9ydGVkJyk7XG5cbiAgICBsZXQgbm9kZSA9IHRoaXMuY3VycmVudEN1cnNvciEuZWxlbWVudC5maXJzdENoaWxkO1xuXG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChpc09wZW5CbG9jayhub2RlKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cblxuICAgIGFzc2VydChub2RlLCAnTXVzdCBoYXZlIG9wZW5pbmcgY29tbWVudCBmb3IgcmVoeWRyYXRpb24uJyk7XG4gICAgdGhpcy5jYW5kaWRhdGUgPSBub2RlO1xuICAgIGNvbnN0IHN0YXJ0aW5nQmxvY2tPZmZzZXQgPSBnZXRCbG9ja0RlcHRoKG5vZGUgYXMgU2ltcGxlQ29tbWVudCk7XG4gICAgaWYgKHN0YXJ0aW5nQmxvY2tPZmZzZXQgIT09IDApIHtcbiAgICAgIC8vIFdlIGFyZSByZWh5ZHJhdGluZyBmcm9tIGEgcGFydGlhbCB0cmVlIGFuZCBub3QgdGhlIHJvb3QgY29tcG9uZW50XG4gICAgICAvLyBXZSBuZWVkIHRvIGFkZCBhbiBleHRyYSBibG9jayBiZWZvcmUgdGhlIGZpcnN0IGJsb2NrIHRvIHJlaHlkcmF0ZSBjb3JyZWN0bHlcbiAgICAgIC8vIFRoZSBleHRyYSBibG9jayBpcyBuZWVkZWQgc2luY2UgdGhlIHJlbmRlckNvbXBvbmVudCBBUEkgY3JlYXRlcyBhIHN5bnRoZXRpYyBjb21wb25lbnQgaW52b2NhdGlvbiB3aGljaCBnZW5lcmF0ZXMgdGhlIGV4dHJhIGJsb2NrXG4gICAgICBjb25zdCBuZXdCbG9ja0RlcHRoID0gc3RhcnRpbmdCbG9ja09mZnNldCAtIDE7XG4gICAgICBjb25zdCBuZXdDYW5kaWRhdGUgPSB0aGlzLmRvbS5jcmVhdGVDb21tZW50KGAlK2I6JHtuZXdCbG9ja0RlcHRofSVgKTtcblxuICAgICAgbm9kZSEucGFyZW50Tm9kZSEuaW5zZXJ0QmVmb3JlKG5ld0NhbmRpZGF0ZSwgdGhpcy5jYW5kaWRhdGUpO1xuICAgICAgbGV0IGNsb3NpbmdOb2RlID0gbm9kZSEubmV4dFNpYmxpbmc7XG4gICAgICB3aGlsZSAoY2xvc2luZ05vZGUgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzQ2xvc2VCbG9jayhjbG9zaW5nTm9kZSkgJiYgZ2V0QmxvY2tEZXB0aChjbG9zaW5nTm9kZSkgPT09IHN0YXJ0aW5nQmxvY2tPZmZzZXQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjbG9zaW5nTm9kZSA9IGNsb3NpbmdOb2RlLm5leHRTaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICBhc3NlcnQoY2xvc2luZ05vZGUsICdNdXN0IGhhdmUgY2xvc2luZyBjb21tZW50IGZvciBzdGFydGluZyBibG9jayBjb21tZW50Jyk7XG4gICAgICBjb25zdCBuZXdDbG9zaW5nQmxvY2sgPSB0aGlzLmRvbS5jcmVhdGVDb21tZW50KGAlLWI6JHtuZXdCbG9ja0RlcHRofSVgKTtcbiAgICAgIG5vZGUhLnBhcmVudE5vZGUhLmluc2VydEJlZm9yZShuZXdDbG9zaW5nQmxvY2ssIGNsb3NpbmdOb2RlIS5uZXh0U2libGluZyk7XG4gICAgICB0aGlzLmNhbmRpZGF0ZSA9IG5ld0NhbmRpZGF0ZTtcbiAgICAgIHRoaXMuc3RhcnRpbmdCbG9ja09mZnNldCA9IG5ld0Jsb2NrRGVwdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhcnRpbmdCbG9ja09mZnNldCA9IDA7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGN1cnJlbnRDdXJzb3IoKTogT3B0aW9uPFJlaHlkcmF0aW5nQ3Vyc29yPiB7XG4gICAgcmV0dXJuIHRoaXNbQ1VSU09SX1NUQUNLXS5jdXJyZW50O1xuICB9XG5cbiAgZ2V0IGNhbmRpZGF0ZSgpOiBPcHRpb248U2ltcGxlTm9kZT4ge1xuICAgIGlmICh0aGlzLmN1cnJlbnRDdXJzb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRDdXJzb3IuY2FuZGlkYXRlITtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHNldCBjYW5kaWRhdGUobm9kZTogT3B0aW9uPFNpbXBsZU5vZGU+KSB7XG4gICAgbGV0IGN1cnJlbnRDdXJzb3IgPSB0aGlzLmN1cnJlbnRDdXJzb3IhO1xuXG4gICAgY3VycmVudEN1cnNvci5jYW5kaWRhdGUgPSBub2RlO1xuICB9XG5cbiAgZGlzYWJsZVJlaHlkcmF0aW9uKG5leHRTaWJsaW5nOiBPcHRpb248U2ltcGxlTm9kZT4pIHtcbiAgICBsZXQgY3VycmVudEN1cnNvciA9IHRoaXMuY3VycmVudEN1cnNvciE7XG5cbiAgICAvLyByZWh5ZHJhdGlvbiB3aWxsIGJlIGRpc2FibGVkIHVudGlsIHdlIGVpdGhlcjpcbiAgICAvLyAqIGhpdCBwb3BFbGVtZW50IChhbmQgcmV0dXJuIHRvIHVzaW5nIHRoZSBwYXJlbnQgZWxlbWVudHMgY3Vyc29yKVxuICAgIC8vICogaGl0IGNsb3NlQmxvY2sgYW5kIHRoZSBuZXh0IHNpYmxpbmcgaXMgYSBjbG9zZSBibG9jayBjb21tZW50XG4gICAgLy8gICBtYXRjaGluZyB0aGUgZXhwZWN0ZWQgb3BlbkJsb2NrRGVwdGhcbiAgICBjdXJyZW50Q3Vyc29yLmNhbmRpZGF0ZSA9IG51bGw7XG4gICAgY3VycmVudEN1cnNvci5uZXh0U2libGluZyA9IG5leHRTaWJsaW5nO1xuICB9XG5cbiAgZW5hYmxlUmVoeWRyYXRpb24oY2FuZGlkYXRlOiBPcHRpb248U2ltcGxlTm9kZT4pIHtcbiAgICBsZXQgY3VycmVudEN1cnNvciA9IHRoaXMuY3VycmVudEN1cnNvciE7XG5cbiAgICBjdXJyZW50Q3Vyc29yLmNhbmRpZGF0ZSA9IGNhbmRpZGF0ZTtcbiAgICBjdXJyZW50Q3Vyc29yLm5leHRTaWJsaW5nID0gbnVsbDtcbiAgfVxuXG4gIHB1c2hFbGVtZW50KFxuICAgIC8qKiBjYWxsZWQgZnJvbSBwYXJlbnQgY29uc3RydWN0b3IgYmVmb3JlIHdlIGluaXRpYWxpemUgdGhpcyAqL1xuICAgIHRoaXM6XG4gICAgICB8IFJlaHlkcmF0ZUJ1aWxkZXJcbiAgICAgIHwgKE5ld0VsZW1lbnRCdWlsZGVyICYgUGFydGlhbDxQaWNrPFJlaHlkcmF0ZUJ1aWxkZXIsICdibG9ja0RlcHRoJyB8ICdjYW5kaWRhdGUnPj4pLFxuICAgIGVsZW1lbnQ6IFNpbXBsZUVsZW1lbnQsXG4gICAgbmV4dFNpYmxpbmc6IE1heWJlPFNpbXBsZU5vZGU+ID0gbnVsbFxuICApIHtcbiAgICBsZXQgY3Vyc29yID0gbmV3IFJlaHlkcmF0aW5nQ3Vyc29yKGVsZW1lbnQsIG5leHRTaWJsaW5nLCB0aGlzLmJsb2NrRGVwdGggfHwgMCk7XG5cbiAgICAvKipcbiAgICAgKiA8ZGl2PiAgIDwtLS0tLS0tLS0tLS0tLS0gIGN1cnJlbnRDdXJzb3IuZWxlbWVudFxuICAgICAqICAgPCEtLSUrYjoxJS0tPiA8LS0tLS0tLSAgd291bGQgaGF2ZSBiZWVuIHJlbW92ZWQgZHVyaW5nIG9wZW5CbG9ja1xuICAgICAqICAgPGRpdj4gPC0tLS0tLS0tLS0tLS0tLSAgY3VycmVudEN1cnNvci5jYW5kaWRhdGUgLT4gY3Vyc29yLmVsZW1lbnRcbiAgICAgKiAgICAgPCEtLSUrYjoyJS0tPiA8LS0tLS0gIGN1cnJlbnRDdXJzb3IuY2FuZGlkYXRlLmZpcnN0Q2hpbGQgLT4gY3Vyc29yLmNhbmRpZGF0ZVxuICAgICAqICAgICBGb29cbiAgICAgKiAgICAgPCEtLSUtYjoyJS0tPlxuICAgICAqICAgPC9kaXY+XG4gICAgICogICA8IS0tJS1iOjElLS0+ICA8LS0tLS0tICBiZWNvbWVzIGN1cnJlbnRDdXJzb3IuY2FuZGlkYXRlXG4gICAgICovXG4gICAgaWYgKHRoaXMuY2FuZGlkYXRlICE9PSBudWxsKSB7XG4gICAgICBjdXJzb3IuY2FuZGlkYXRlID0gZWxlbWVudC5maXJzdENoaWxkO1xuICAgICAgdGhpcy5jYW5kaWRhdGUgPSBlbGVtZW50Lm5leHRTaWJsaW5nO1xuICAgIH1cblxuICAgIHRoaXNbQ1VSU09SX1NUQUNLXS5wdXNoKGN1cnNvcik7XG4gIH1cblxuICAvLyBjbGVhcnMgdW50aWwgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBjb250YWluZXJcbiAgLy8gZWl0aGVyIHRoZSBjdXJyZW50IG9wZW4gYmxvY2sgb3IgaGlnaGVyXG4gIHByaXZhdGUgY2xlYXJNaXNtYXRjaChjYW5kaWRhdGU6IFNpbXBsZU5vZGUpIHtcbiAgICBsZXQgY3VycmVudDogT3B0aW9uPFNpbXBsZU5vZGU+ID0gY2FuZGlkYXRlO1xuICAgIGxldCBjdXJyZW50Q3Vyc29yID0gdGhpcy5jdXJyZW50Q3Vyc29yO1xuICAgIGlmIChjdXJyZW50Q3Vyc29yICE9PSBudWxsKSB7XG4gICAgICBsZXQgb3BlbkJsb2NrRGVwdGggPSBjdXJyZW50Q3Vyc29yLm9wZW5CbG9ja0RlcHRoO1xuICAgICAgaWYgKG9wZW5CbG9ja0RlcHRoID49IGN1cnJlbnRDdXJzb3Iuc3RhcnRpbmdCbG9ja0RlcHRoKSB7XG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgaWYgKGlzQ2xvc2VCbG9jayhjdXJyZW50KSkge1xuICAgICAgICAgICAgbGV0IGNsb3NlQmxvY2tEZXB0aCA9IGdldEJsb2NrRGVwdGhXaXRoT2Zmc2V0KGN1cnJlbnQsIHRoaXMuc3RhcnRpbmdCbG9ja09mZnNldCk7XG4gICAgICAgICAgICBpZiAob3BlbkJsb2NrRGVwdGggPj0gY2xvc2VCbG9ja0RlcHRoKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50ID0gdGhpcy5yZW1vdmUoY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgY3VycmVudCA9IHRoaXMucmVtb3ZlKGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBjdXJyZW50IGN1cnNvciBwYXJlbnROb2RlIHNob3VsZCBiZSBvcGVuQ2FuZGlkYXRlIGlmIGVsZW1lbnRcbiAgICAgIC8vIG9yIG9wZW5DYW5kaWRhdGUucGFyZW50Tm9kZSBpZiBjb21tZW50XG4gICAgICB0aGlzLmRpc2FibGVSZWh5ZHJhdGlvbihjdXJyZW50KTtcbiAgICB9XG4gIH1cblxuICBfX29wZW5CbG9jaygpOiB2b2lkIHtcbiAgICBsZXQgeyBjdXJyZW50Q3Vyc29yIH0gPSB0aGlzO1xuICAgIGlmIChjdXJyZW50Q3Vyc29yID09PSBudWxsKSByZXR1cm47XG5cbiAgICBsZXQgYmxvY2tEZXB0aCA9IHRoaXMuYmxvY2tEZXB0aDtcblxuICAgIHRoaXMuYmxvY2tEZXB0aCsrO1xuXG4gICAgbGV0IHsgY2FuZGlkYXRlIH0gPSBjdXJyZW50Q3Vyc29yO1xuICAgIGlmIChjYW5kaWRhdGUgPT09IG51bGwpIHJldHVybjtcblxuICAgIGxldCB7IHRhZ05hbWUgfSA9IGN1cnJlbnRDdXJzb3IuZWxlbWVudDtcblxuICAgIGlmIChcbiAgICAgIGlzT3BlbkJsb2NrKGNhbmRpZGF0ZSkgJiZcbiAgICAgIGdldEJsb2NrRGVwdGhXaXRoT2Zmc2V0KGNhbmRpZGF0ZSwgdGhpcy5zdGFydGluZ0Jsb2NrT2Zmc2V0KSA9PT0gYmxvY2tEZXB0aFxuICAgICkge1xuICAgICAgdGhpcy5jYW5kaWRhdGUgPSB0aGlzLnJlbW92ZShjYW5kaWRhdGUpO1xuICAgICAgY3VycmVudEN1cnNvci5vcGVuQmxvY2tEZXB0aCA9IGJsb2NrRGVwdGg7XG4gICAgfSBlbHNlIGlmICh0YWdOYW1lICE9PSAnVElUTEUnICYmIHRhZ05hbWUgIT09ICdTQ1JJUFQnICYmIHRhZ05hbWUgIT09ICdTVFlMRScpIHtcbiAgICAgIHRoaXMuY2xlYXJNaXNtYXRjaChjYW5kaWRhdGUpO1xuICAgIH1cbiAgfVxuXG4gIF9fY2xvc2VCbG9jaygpOiB2b2lkIHtcbiAgICBsZXQgeyBjdXJyZW50Q3Vyc29yIH0gPSB0aGlzO1xuICAgIGlmIChjdXJyZW50Q3Vyc29yID09PSBudWxsKSByZXR1cm47XG5cbiAgICAvLyBvcGVuQmxvY2sgaXMgdGhlIGxhc3QgcmVoeWRyYXRlZCBvcGVuIGJsb2NrXG4gICAgbGV0IG9wZW5CbG9ja0RlcHRoID0gY3VycmVudEN1cnNvci5vcGVuQmxvY2tEZXB0aDtcblxuICAgIC8vIHRoaXMgY3VycmVudGx5IGlzIHRoZSBleHBlY3RlZCBuZXh0IG9wZW4gYmxvY2sgZGVwdGhcbiAgICB0aGlzLmJsb2NrRGVwdGgtLTtcblxuICAgIGxldCB7IGNhbmRpZGF0ZSB9ID0gY3VycmVudEN1cnNvcjtcblxuICAgIGxldCBpc1JlaHlkcmF0aW5nID0gZmFsc2U7XG5cbiAgICBpZiAoY2FuZGlkYXRlICE9PSBudWxsKSB7XG4gICAgICBpc1JlaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgIC8vYXNzZXJ0KFxuICAgICAgLy8gIG9wZW5CbG9ja0RlcHRoID09PSB0aGlzLmJsb2NrRGVwdGgsXG4gICAgICAvLyAgJ3doZW4gcmVoeWRyYXRpbmcsIG9wZW5CbG9ja0RlcHRoIHNob3VsZCBtYXRjaCB0aGlzLmJsb2NrRGVwdGggaGVyZSdcbiAgICAgIC8vKTtcblxuICAgICAgaWYgKFxuICAgICAgICBpc0Nsb3NlQmxvY2soY2FuZGlkYXRlKSAmJlxuICAgICAgICBnZXRCbG9ja0RlcHRoV2l0aE9mZnNldChjYW5kaWRhdGUsIHRoaXMuc3RhcnRpbmdCbG9ja09mZnNldCkgPT09IG9wZW5CbG9ja0RlcHRoXG4gICAgICApIHtcbiAgICAgICAgbGV0IG5leHRTaWJsaW5nID0gdGhpcy5yZW1vdmUoY2FuZGlkYXRlKTtcbiAgICAgICAgdGhpcy5jYW5kaWRhdGUgPSBuZXh0U2libGluZztcbiAgICAgICAgY3VycmVudEN1cnNvci5vcGVuQmxvY2tEZXB0aC0tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY2xvc2UgdGhlIGJsb2NrIGFuZCBjbGVhciBtaXNtYXRjaCBpbiBwYXJlbnQgY29udGFpbmVyXG4gICAgICAgIC8vIHdlIHdpbGwgYmUgZWl0aGVyIGF0IHRoZSBlbmQgb2YgdGhlIGVsZW1lbnRcbiAgICAgICAgLy8gb3IgYXQgdGhlIGVuZCBvZiBvdXIgY29udGFpbmluZyBibG9ja1xuICAgICAgICB0aGlzLmNsZWFyTWlzbWF0Y2goY2FuZGlkYXRlKTtcbiAgICAgICAgaXNSZWh5ZHJhdGluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc1JlaHlkcmF0aW5nID09PSBmYWxzZSkge1xuICAgICAgLy8gY2hlY2sgaWYgbmV4dFNpYmxpbmcgbWF0Y2hlcyBvdXIgZXhwZWN0ZWQgY2xvc2UgYmxvY2tcbiAgICAgIC8vIGlmIHNvLCB3ZSByZW1vdmUgdGhlIGNsb3NlIGJsb2NrIGNvbW1lbnQgYW5kXG4gICAgICAvLyByZXN0b3JlIHJlaHlkcmF0aW9uIGFmdGVyIGNsZWFyTWlzbWF0Y2ggZGlzYWJsZWRcbiAgICAgIGxldCBuZXh0U2libGluZyA9IGN1cnJlbnRDdXJzb3IubmV4dFNpYmxpbmc7XG4gICAgICBpZiAoXG4gICAgICAgIG5leHRTaWJsaW5nICE9PSBudWxsICYmXG4gICAgICAgIGlzQ2xvc2VCbG9jayhuZXh0U2libGluZykgJiZcbiAgICAgICAgZ2V0QmxvY2tEZXB0aFdpdGhPZmZzZXQobmV4dFNpYmxpbmcsIHRoaXMuc3RhcnRpbmdCbG9ja09mZnNldCkgPT09IHRoaXMuYmxvY2tEZXB0aFxuICAgICAgKSB7XG4gICAgICAgIC8vIHJlc3RvcmUgcmVoeWRyYXRpb24gc3RhdGVcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHRoaXMucmVtb3ZlKG5leHRTaWJsaW5nKTtcbiAgICAgICAgdGhpcy5lbmFibGVSZWh5ZHJhdGlvbihjYW5kaWRhdGUpO1xuXG4gICAgICAgIGN1cnJlbnRDdXJzb3Iub3BlbkJsb2NrRGVwdGgtLTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfX2FwcGVuZE5vZGUobm9kZTogU2ltcGxlTm9kZSk6IFNpbXBsZU5vZGUge1xuICAgIGxldCB7IGNhbmRpZGF0ZSB9ID0gdGhpcztcblxuICAgIC8vIFRoaXMgY29kZSBwYXRoIGlzIG9ubHkgdXNlZCB3aGVuIGluc2VydGluZyBwcmVjaXNlbHkgb25lIG5vZGUuIEl0IG5lZWRzIG1vcmVcbiAgICAvLyBjb21wYXJpc29uIGxvZ2ljLCBidXQgd2UgY2FuIHByb2JhYmx5IGxlYW4gb24gdGhlIGNhc2VzIHdoZXJlIHRoaXMgY29kZSBwYXRoXG4gICAgLy8gaXMgYWN0dWFsbHkgdXNlZC5cbiAgICBpZiAoY2FuZGlkYXRlKSB7XG4gICAgICByZXR1cm4gY2FuZGlkYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3VwZXIuX19hcHBlbmROb2RlKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIF9fYXBwZW5kSFRNTChodG1sOiBzdHJpbmcpOiBCb3VuZHMge1xuICAgIGxldCBjYW5kaWRhdGVCb3VuZHMgPSB0aGlzLm1hcmtlckJvdW5kcygpO1xuXG4gICAgaWYgKGNhbmRpZGF0ZUJvdW5kcykge1xuICAgICAgbGV0IGZpcnN0ID0gY2FuZGlkYXRlQm91bmRzLmZpcnN0Tm9kZSgpITtcbiAgICAgIGxldCBsYXN0ID0gY2FuZGlkYXRlQm91bmRzLmxhc3ROb2RlKCkhO1xuXG4gICAgICBsZXQgbmV3Qm91bmRzID0gbmV3IENvbmNyZXRlQm91bmRzKHRoaXMuZWxlbWVudCwgZmlyc3QubmV4dFNpYmxpbmchLCBsYXN0LnByZXZpb3VzU2libGluZyEpO1xuXG4gICAgICBsZXQgcG9zc2libGVFbXB0eU1hcmtlciA9IHRoaXMucmVtb3ZlKGZpcnN0KTtcbiAgICAgIHRoaXMucmVtb3ZlKGxhc3QpO1xuXG4gICAgICBpZiAocG9zc2libGVFbXB0eU1hcmtlciAhPT0gbnVsbCAmJiBpc0VtcHR5KHBvc3NpYmxlRW1wdHlNYXJrZXIpKSB7XG4gICAgICAgIHRoaXMuY2FuZGlkYXRlID0gdGhpcy5yZW1vdmUocG9zc2libGVFbXB0eU1hcmtlcik7XG5cbiAgICAgICAgaWYgKHRoaXMuY2FuZGlkYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5jbGVhck1pc21hdGNoKHRoaXMuY2FuZGlkYXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3Qm91bmRzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3VwZXIuX19hcHBlbmRIVE1MKGh0bWwpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCByZW1vdmUobm9kZTogU2ltcGxlTm9kZSk6IE9wdGlvbjxTaW1wbGVOb2RlPiB7XG4gICAgbGV0IGVsZW1lbnQgPSBleHBlY3Qobm9kZS5wYXJlbnROb2RlLCBgY2Fubm90IHJlbW92ZSBhIGRldGFjaGVkIG5vZGVgKSBhcyBTaW1wbGVFbGVtZW50O1xuICAgIGxldCBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICBlbGVtZW50LnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgcHJpdmF0ZSBtYXJrZXJCb3VuZHMoKTogT3B0aW9uPEJvdW5kcz4ge1xuICAgIGxldCBfY2FuZGlkYXRlID0gdGhpcy5jYW5kaWRhdGU7XG5cbiAgICBpZiAoX2NhbmRpZGF0ZSAmJiBpc01hcmtlcihfY2FuZGlkYXRlKSkge1xuICAgICAgbGV0IGZpcnN0ID0gX2NhbmRpZGF0ZTtcbiAgICAgIGxldCBsYXN0ID0gZXhwZWN0KGZpcnN0Lm5leHRTaWJsaW5nLCBgQlVHOiBzZXJpYWxpemF0aW9uIG1hcmtlcnMgbXVzdCBiZSBwYWlyZWRgKTtcblxuICAgICAgd2hpbGUgKGxhc3QgJiYgIWlzTWFya2VyKGxhc3QpKSB7XG4gICAgICAgIGxhc3QgPSBleHBlY3QobGFzdC5uZXh0U2libGluZywgYEJVRzogc2VyaWFsaXphdGlvbiBtYXJrZXJzIG11c3QgYmUgcGFpcmVkYCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgQ29uY3JldGVCb3VuZHModGhpcy5lbGVtZW50LCBmaXJzdCwgbGFzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIF9fYXBwZW5kVGV4dChzdHJpbmc6IHN0cmluZyk6IFNpbXBsZVRleHQge1xuICAgIGxldCB7IGNhbmRpZGF0ZSB9ID0gdGhpcztcblxuICAgIGlmIChjYW5kaWRhdGUpIHtcbiAgICAgIGlmIChpc1RleHROb2RlKGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgaWYgKGNhbmRpZGF0ZS5ub2RlVmFsdWUgIT09IHN0cmluZykge1xuICAgICAgICAgIGNhbmRpZGF0ZS5ub2RlVmFsdWUgPSBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW5kaWRhdGUgPSBjYW5kaWRhdGUubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNTZXBhcmF0b3IoY2FuZGlkYXRlKSkge1xuICAgICAgICB0aGlzLmNhbmRpZGF0ZSA9IHRoaXMucmVtb3ZlKGNhbmRpZGF0ZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX19hcHBlbmRUZXh0KHN0cmluZyk7XG4gICAgICB9IGVsc2UgaWYgKGlzRW1wdHkoY2FuZGlkYXRlKSAmJiBzdHJpbmcgPT09ICcnKSB7XG4gICAgICAgIHRoaXMuY2FuZGlkYXRlID0gdGhpcy5yZW1vdmUoY2FuZGlkYXRlKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fX2FwcGVuZFRleHQoc3RyaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2xlYXJNaXNtYXRjaChjYW5kaWRhdGUpO1xuXG4gICAgICAgIHJldHVybiBzdXBlci5fX2FwcGVuZFRleHQoc3RyaW5nKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN1cGVyLl9fYXBwZW5kVGV4dChzdHJpbmcpO1xuICAgIH1cbiAgfVxuXG4gIF9fYXBwZW5kQ29tbWVudChzdHJpbmc6IHN0cmluZyk6IFNpbXBsZUNvbW1lbnQge1xuICAgIGxldCBfY2FuZGlkYXRlID0gdGhpcy5jYW5kaWRhdGU7XG4gICAgaWYgKF9jYW5kaWRhdGUgJiYgaXNDb21tZW50KF9jYW5kaWRhdGUpKSB7XG4gICAgICBpZiAoX2NhbmRpZGF0ZS5ub2RlVmFsdWUgIT09IHN0cmluZykge1xuICAgICAgICBfY2FuZGlkYXRlLm5vZGVWYWx1ZSA9IHN0cmluZztcbiAgICAgIH1cblxuICAgICAgdGhpcy5jYW5kaWRhdGUgPSBfY2FuZGlkYXRlLm5leHRTaWJsaW5nO1xuICAgICAgcmV0dXJuIF9jYW5kaWRhdGU7XG4gICAgfSBlbHNlIGlmIChfY2FuZGlkYXRlKSB7XG4gICAgICB0aGlzLmNsZWFyTWlzbWF0Y2goX2NhbmRpZGF0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLl9fYXBwZW5kQ29tbWVudChzdHJpbmcpO1xuICB9XG5cbiAgX19vcGVuRWxlbWVudCh0YWc6IHN0cmluZyk6IFNpbXBsZUVsZW1lbnQge1xuICAgIGxldCBfY2FuZGlkYXRlID0gdGhpcy5jYW5kaWRhdGU7XG5cbiAgICBpZiAoX2NhbmRpZGF0ZSAmJiBpc0VsZW1lbnQoX2NhbmRpZGF0ZSkgJiYgaXNTYW1lTm9kZVR5cGUoX2NhbmRpZGF0ZSwgdGFnKSkge1xuICAgICAgdGhpcy51bm1hdGNoZWRBdHRyaWJ1dGVzID0gW10uc2xpY2UuY2FsbChfY2FuZGlkYXRlLmF0dHJpYnV0ZXMpO1xuICAgICAgcmV0dXJuIF9jYW5kaWRhdGU7XG4gICAgfSBlbHNlIGlmIChfY2FuZGlkYXRlKSB7XG4gICAgICBpZiAoaXNFbGVtZW50KF9jYW5kaWRhdGUpICYmIF9jYW5kaWRhdGUudGFnTmFtZSA9PT0gJ1RCT0RZJykge1xuICAgICAgICB0aGlzLnB1c2hFbGVtZW50KF9jYW5kaWRhdGUsIG51bGwpO1xuICAgICAgICB0aGlzLmN1cnJlbnRDdXJzb3IhLmluamVjdGVkT21pdHRlZE5vZGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5fX29wZW5FbGVtZW50KHRhZyk7XG4gICAgICB9XG4gICAgICB0aGlzLmNsZWFyTWlzbWF0Y2goX2NhbmRpZGF0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLl9fb3BlbkVsZW1lbnQodGFnKTtcbiAgfVxuXG4gIF9fc2V0QXR0cmlidXRlKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZywgbmFtZXNwYWNlOiBPcHRpb248QXR0ck5hbWVzcGFjZT4pOiB2b2lkIHtcbiAgICBsZXQgdW5tYXRjaGVkID0gdGhpcy51bm1hdGNoZWRBdHRyaWJ1dGVzO1xuXG4gICAgaWYgKHVubWF0Y2hlZCkge1xuICAgICAgbGV0IGF0dHIgPSBmaW5kQnlOYW1lKHVubWF0Y2hlZCwgbmFtZSk7XG4gICAgICBpZiAoYXR0cikge1xuICAgICAgICBpZiAoYXR0ci52YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICBhdHRyLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdW5tYXRjaGVkLnNwbGljZSh1bm1hdGNoZWQuaW5kZXhPZihhdHRyKSwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuX19zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUsIG5hbWVzcGFjZSk7XG4gIH1cblxuICBfX3NldFByb3BlcnR5KG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IHZvaWQge1xuICAgIGxldCB1bm1hdGNoZWQgPSB0aGlzLnVubWF0Y2hlZEF0dHJpYnV0ZXM7XG5cbiAgICBpZiAodW5tYXRjaGVkKSB7XG4gICAgICBsZXQgYXR0ciA9IGZpbmRCeU5hbWUodW5tYXRjaGVkLCBuYW1lKTtcbiAgICAgIGlmIChhdHRyKSB7XG4gICAgICAgIGlmIChhdHRyLnZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgIGF0dHIudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB1bm1hdGNoZWQuc3BsaWNlKHVubWF0Y2hlZC5pbmRleE9mKGF0dHIpLCAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5fX3NldFByb3BlcnR5KG5hbWUsIHZhbHVlKTtcbiAgfVxuXG4gIF9fZmx1c2hFbGVtZW50KHBhcmVudDogU2ltcGxlRWxlbWVudCwgY29uc3RydWN0aW5nOiBTaW1wbGVFbGVtZW50KTogdm9pZCB7XG4gICAgbGV0IHsgdW5tYXRjaGVkQXR0cmlidXRlczogdW5tYXRjaGVkIH0gPSB0aGlzO1xuICAgIGlmICh1bm1hdGNoZWQpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdW5tYXRjaGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0aW5nIS5yZW1vdmVBdHRyaWJ1dGUodW5tYXRjaGVkW2ldLm5hbWUpO1xuICAgICAgfVxuICAgICAgdGhpcy51bm1hdGNoZWRBdHRyaWJ1dGVzID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIuX19mbHVzaEVsZW1lbnQocGFyZW50LCBjb25zdHJ1Y3RpbmcpO1xuICAgIH1cbiAgfVxuXG4gIHdpbGxDbG9zZUVsZW1lbnQoKSB7XG4gICAgbGV0IHsgY2FuZGlkYXRlLCBjdXJyZW50Q3Vyc29yIH0gPSB0aGlzO1xuXG4gICAgaWYgKGNhbmRpZGF0ZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5jbGVhck1pc21hdGNoKGNhbmRpZGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRDdXJzb3IgJiYgY3VycmVudEN1cnNvci5pbmplY3RlZE9taXR0ZWROb2RlKSB7XG4gICAgICB0aGlzLnBvcEVsZW1lbnQoKTtcbiAgICB9XG5cbiAgICBzdXBlci53aWxsQ2xvc2VFbGVtZW50KCk7XG4gIH1cblxuICBnZXRNYXJrZXIoZWxlbWVudDogSFRNTEVsZW1lbnQsIGd1aWQ6IHN0cmluZyk6IE9wdGlvbjxTaW1wbGVOb2RlPiB7XG4gICAgbGV0IG1hcmtlciA9IGVsZW1lbnQucXVlcnlTZWxlY3Rvcihgc2NyaXB0W2dsbXI9XCIke2d1aWR9XCJdYCk7XG4gICAgaWYgKG1hcmtlcikge1xuICAgICAgcmV0dXJuIGNhc3RUb1NpbXBsZShtYXJrZXIpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIF9fcHVzaFJlbW90ZUVsZW1lbnQoXG4gICAgZWxlbWVudDogU2ltcGxlRWxlbWVudCxcbiAgICBjdXJzb3JJZDogc3RyaW5nLFxuICAgIGluc2VydEJlZm9yZTogTWF5YmU8U2ltcGxlTm9kZT5cbiAgKTogT3B0aW9uPFJlbW90ZUxpdmVCbG9jaz4ge1xuICAgIGxldCBtYXJrZXIgPSB0aGlzLmdldE1hcmtlcihjYXN0VG9Ccm93c2VyKGVsZW1lbnQsICdIVE1MJyksIGN1cnNvcklkKTtcblxuICAgIGFzc2VydChcbiAgICAgICFtYXJrZXIgfHwgbWFya2VyLnBhcmVudE5vZGUgPT09IGVsZW1lbnQsXG4gICAgICBgZXhwZWN0ZWQgcmVtb3RlIGVsZW1lbnQgbWFya2VyJ3MgcGFyZW50IG5vZGUgdG8gbWF0Y2ggcmVtb3RlIGVsZW1lbnRgXG4gICAgKTtcblxuICAgIC8vIHdoZW4gaW5zZXJ0QmVmb3JlIGlzIG5vdCBwcmVzZW50LCB3ZSBjbGVhciB0aGUgZWxlbWVudFxuICAgIGlmIChpbnNlcnRCZWZvcmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgd2hpbGUgKGVsZW1lbnQuZmlyc3RDaGlsZCAhPT0gbnVsbCAmJiBlbGVtZW50LmZpcnN0Q2hpbGQgIT09IG1hcmtlcikge1xuICAgICAgICB0aGlzLnJlbW92ZShlbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgaW5zZXJ0QmVmb3JlID0gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgY3Vyc29yID0gbmV3IFJlaHlkcmF0aW5nQ3Vyc29yKGVsZW1lbnQsIG51bGwsIHRoaXMuYmxvY2tEZXB0aCk7XG4gICAgdGhpc1tDVVJTT1JfU1RBQ0tdLnB1c2goY3Vyc29yKTtcblxuICAgIGlmIChtYXJrZXIgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuZGlzYWJsZVJlaHlkcmF0aW9uKGluc2VydEJlZm9yZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2FuZGlkYXRlID0gdGhpcy5yZW1vdmUobWFya2VyKTtcbiAgICB9XG5cbiAgICBsZXQgYmxvY2sgPSBuZXcgUmVtb3RlTGl2ZUJsb2NrKGVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLnB1c2hMaXZlQmxvY2soYmxvY2ssIHRydWUpO1xuICB9XG5cbiAgZGlkQXBwZW5kQm91bmRzKGJvdW5kczogQm91bmRzKTogQm91bmRzIHtcbiAgICBzdXBlci5kaWRBcHBlbmRCb3VuZHMoYm91bmRzKTtcbiAgICBpZiAodGhpcy5jYW5kaWRhdGUpIHtcbiAgICAgIGxldCBsYXN0ID0gYm91bmRzLmxhc3ROb2RlKCk7XG4gICAgICB0aGlzLmNhbmRpZGF0ZSA9IGxhc3QgJiYgbGFzdC5uZXh0U2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIGJvdW5kcztcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlKG5vZGU6IFNpbXBsZU5vZGUpOiBub2RlIGlzIFNpbXBsZVRleHQge1xuICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gMztcbn1cblxuZnVuY3Rpb24gaXNDb21tZW50KG5vZGU6IFNpbXBsZU5vZGUpOiBub2RlIGlzIFNpbXBsZUNvbW1lbnQge1xuICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gODtcbn1cblxuZnVuY3Rpb24gaXNPcGVuQmxvY2sobm9kZTogU2ltcGxlTm9kZSk6IG5vZGUgaXMgU2ltcGxlQ29tbWVudCB7XG4gIHJldHVybiBub2RlLm5vZGVUeXBlID09PSBOb2RlVHlwZS5DT01NRU5UX05PREUgJiYgbm9kZS5ub2RlVmFsdWUubGFzdEluZGV4T2YoJyUrYjonLCAwKSA9PT0gMDtcbn1cblxuZnVuY3Rpb24gaXNDbG9zZUJsb2NrKG5vZGU6IFNpbXBsZU5vZGUpOiBub2RlIGlzIFNpbXBsZUNvbW1lbnQge1xuICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gTm9kZVR5cGUuQ09NTUVOVF9OT0RFICYmIG5vZGUubm9kZVZhbHVlLmxhc3RJbmRleE9mKCclLWI6JywgMCkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGdldEJsb2NrRGVwdGgobm9kZTogU2ltcGxlQ29tbWVudCk6IG51bWJlciB7XG4gIHJldHVybiBwYXJzZUludChub2RlLm5vZGVWYWx1ZS5zbGljZSg0KSwgMTApO1xufVxuXG5mdW5jdGlvbiBnZXRCbG9ja0RlcHRoV2l0aE9mZnNldChub2RlOiBTaW1wbGVDb21tZW50LCBvZmZzZXQ6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiBnZXRCbG9ja0RlcHRoKG5vZGUpIC0gb2Zmc2V0O1xufVxuXG5mdW5jdGlvbiBpc0VsZW1lbnQobm9kZTogU2ltcGxlTm9kZSk6IG5vZGUgaXMgU2ltcGxlRWxlbWVudCB7XG4gIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAxO1xufVxuXG5mdW5jdGlvbiBpc01hcmtlcihub2RlOiBTaW1wbGVOb2RlKTogYm9vbGVhbiB7XG4gIHJldHVybiBub2RlLm5vZGVUeXBlID09PSA4ICYmIG5vZGUubm9kZVZhbHVlID09PSAnJWdsbXIlJztcbn1cblxuZnVuY3Rpb24gaXNTZXBhcmF0b3Iobm9kZTogU2ltcGxlTm9kZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gOCAmJiBub2RlLm5vZGVWYWx1ZSA9PT0gJyV8JSc7XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHkobm9kZTogU2ltcGxlTm9kZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gOCAmJiBub2RlLm5vZGVWYWx1ZSA9PT0gJyUgJSc7XG59XG5cbmZ1bmN0aW9uIGlzU2FtZU5vZGVUeXBlKGNhbmRpZGF0ZTogU2ltcGxlRWxlbWVudCwgdGFnOiBzdHJpbmcpIHtcbiAgaWYgKGNhbmRpZGF0ZS5uYW1lc3BhY2VVUkkgPT09IE5hbWVzcGFjZS5TVkcpIHtcbiAgICByZXR1cm4gY2FuZGlkYXRlLnRhZ05hbWUgPT09IHRhZztcbiAgfVxuICByZXR1cm4gY2FuZGlkYXRlLnRhZ05hbWUgPT09IHRhZy50b1VwcGVyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBmaW5kQnlOYW1lKGFycmF5OiBTaW1wbGVBdHRyW10sIG5hbWU6IHN0cmluZyk6IFNpbXBsZUF0dHIgfCB1bmRlZmluZWQge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGF0dHIgPSBhcnJheVtpXTtcbiAgICBpZiAoYXR0ci5uYW1lID09PSBuYW1lKSByZXR1cm4gYXR0cjtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWh5ZHJhdGlvbkJ1aWxkZXIoZW52OiBFbnZpcm9ubWVudCwgY3Vyc29yOiBDdXJzb3JJbXBsKTogRWxlbWVudEJ1aWxkZXIge1xuICByZXR1cm4gUmVoeWRyYXRlQnVpbGRlci5mb3JJbml0aWFsUmVuZGVyKGVudiwgY3Vyc29yKTtcbn1cbiIsImltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7IENhY2hlLCBjcmVhdGVDYWNoZSwgZ2V0VmFsdWUgfSBmcm9tICdAZ2xpbW1lci92YWxpZGF0b3InO1xuaW1wb3J0IHsgQXJndW1lbnRzLCBJbnRlcm5hbEhlbHBlck1hbmFnZXIgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGRlYnVnVG9TdHJpbmcgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IGdldEludGVybmFsSGVscGVyTWFuYWdlciwgaGFzRGVzdHJveWFibGUsIGhhc1ZhbHVlIH0gZnJvbSAnQGdsaW1tZXIvbWFuYWdlcic7XG5cbmltcG9ydCB7IEVNUFRZX0FSR1MsIEVNUFRZX05BTUVELCBFTVBUWV9QT1NJVElPTkFMIH0gZnJvbSAnLi4vdm0vYXJndW1lbnRzJztcbmltcG9ydCB7IGdldE93bmVyIH0gZnJvbSAnQGdsaW1tZXIvb3duZXInO1xuaW1wb3J0IHsgYXNzb2NpYXRlRGVzdHJveWFibGVDaGlsZCwgaXNEZXN0cm95ZWQsIGlzRGVzdHJveWluZyB9IGZyb20gJ0BnbGltbWVyL2Rlc3Ryb3lhYmxlJztcblxubGV0IEFSR1NfQ0FDSEVTID0gREVCVUcgPyBuZXcgV2Vha01hcDxTaW1wbGVBcmdzUHJveHksIENhY2hlPFBhcnRpYWw8QXJndW1lbnRzPj4+KCkgOiB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGdldEFyZ3MocHJveHk6IFNpbXBsZUFyZ3NQcm94eSk6IFBhcnRpYWw8QXJndW1lbnRzPiB7XG4gIHJldHVybiBnZXRWYWx1ZShERUJVRyA/IEFSR1NfQ0FDSEVTIS5nZXQocHJveHkpISA6IHByb3h5LmFyZ3NDYWNoZSEpITtcbn1cblxuY2xhc3MgU2ltcGxlQXJnc1Byb3h5IHtcbiAgYXJnc0NhY2hlPzogQ2FjaGU8UGFydGlhbDxBcmd1bWVudHM+PjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBjb250ZXh0OiBvYmplY3QsXG4gICAgY29tcHV0ZUFyZ3M6IChjb250ZXh0OiBvYmplY3QpID0+IFBhcnRpYWw8QXJndW1lbnRzPiA9ICgpID0+IEVNUFRZX0FSR1NcbiAgKSB7XG4gICAgbGV0IGFyZ3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCgpID0+IGNvbXB1dGVBcmdzKGNvbnRleHQpKTtcblxuICAgIGlmIChERUJVRykge1xuICAgICAgQVJHU19DQUNIRVMhLnNldCh0aGlzLCBhcmdzQ2FjaGUpO1xuICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hcmdzQ2FjaGUgPSBhcmdzQ2FjaGU7XG4gICAgfVxuICB9XG5cbiAgZ2V0IG5hbWVkKCkge1xuICAgIHJldHVybiBnZXRBcmdzKHRoaXMpLm5hbWVkIHx8IEVNUFRZX05BTUVEO1xuICB9XG5cbiAgZ2V0IHBvc2l0aW9uYWwoKSB7XG4gICAgcmV0dXJuIGdldEFyZ3ModGhpcykucG9zaXRpb25hbCB8fCBFTVBUWV9QT1NJVElPTkFMO1xuICB9XG59XG5cbi8vLy8vLy8vLy8vL1xuXG5leHBvcnQgZnVuY3Rpb24gaW52b2tlSGVscGVyKFxuICBjb250ZXh0OiBvYmplY3QsXG4gIGRlZmluaXRpb246IG9iamVjdCxcbiAgY29tcHV0ZUFyZ3M/OiAoY29udGV4dDogb2JqZWN0KSA9PiBQYXJ0aWFsPEFyZ3VtZW50cz5cbik6IENhY2hlPHVua25vd24+IHtcbiAgaWYgKERFQlVHICYmICh0eXBlb2YgY29udGV4dCAhPT0gJ29iamVjdCcgfHwgY29udGV4dCA9PT0gbnVsbCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgYSBjb250ZXh0IG9iamVjdCB0byBiZSBwYXNzZWQgYXMgdGhlIGZpcnN0IHBhcmFtZXRlciB0byBpbnZva2VIZWxwZXIsIGdvdCAke2NvbnRleHR9YFxuICAgICk7XG4gIH1cblxuICBjb25zdCBvd25lciA9IGdldE93bmVyKGNvbnRleHQpO1xuICBjb25zdCBpbnRlcm5hbE1hbmFnZXIgPSBnZXRJbnRlcm5hbEhlbHBlck1hbmFnZXIoZGVmaW5pdGlvbikhO1xuXG4gIC8vIFRPRE86IGZpZ3VyZSBvdXQgd2h5IGFzc2VydCBpc24ndCB1c2luZyB0aGUgVFMgYXNzZXJ0IHRoaW5nXG4gIGlmIChERUJVRyAmJiAhaW50ZXJuYWxNYW5hZ2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEV4cGVjdGVkIGEgaGVscGVyIGRlZmluaXRpb24gdG8gYmUgcGFzc2VkIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHRvIGludm9rZUhlbHBlciwgYnV0IG5vIGhlbHBlciBtYW5hZ2VyIHdhcyBmb3VuZC4gVGhlIGRlZmluaXRpb24gdmFsdWUgdGhhdCB3YXMgcGFzc2VkIHdhcyBcXGAke2RlYnVnVG9TdHJpbmchKFxuICAgICAgICBkZWZpbml0aW9uXG4gICAgICApfVxcYC4gRGlkIHlvdSB1c2Ugc2V0SGVscGVyTWFuYWdlciB0byBhc3NvY2lhdGUgYSBoZWxwZXIgbWFuYWdlciB3aXRoIHRoaXMgdmFsdWU/YFxuICAgICk7XG4gIH1cblxuICBpZiAoREVCVUcgJiYgdHlwZW9mIGludGVybmFsTWFuYWdlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdGb3VuZCBhIGhlbHBlciBtYW5hZ2VyLCBidXQgaXQgd2FzIGFuIGludGVybmFsIGJ1aWx0LWluIGhlbHBlciBtYW5hZ2VyLiBgaW52b2tlSGVscGVyYCBkb2VzIG5vdCBzdXBwb3J0IGludGVybmFsIGhlbHBlcnMgeWV0LidcbiAgICApO1xuICB9XG5cbiAgY29uc3QgbWFuYWdlciA9IChpbnRlcm5hbE1hbmFnZXIgYXMgSW50ZXJuYWxIZWxwZXJNYW5hZ2VyPG9iamVjdD4pLmdldERlbGVnYXRlRm9yKG93bmVyKTtcbiAgbGV0IGFyZ3MgPSBuZXcgU2ltcGxlQXJnc1Byb3h5KGNvbnRleHQsIGNvbXB1dGVBcmdzKTtcbiAgbGV0IGJ1Y2tldCA9IG1hbmFnZXIuY3JlYXRlSGVscGVyKGRlZmluaXRpb24sIGFyZ3MpO1xuXG4gIGxldCBjYWNoZTogQ2FjaGU8dW5rbm93bj47XG5cbiAgaWYgKGhhc1ZhbHVlKG1hbmFnZXIpKSB7XG4gICAgY2FjaGUgPSBjcmVhdGVDYWNoZSgoKSA9PiB7XG4gICAgICBpZiAoREVCVUcgJiYgKGlzRGVzdHJveWluZyhjYWNoZSkgfHwgaXNEZXN0cm95ZWQoY2FjaGUpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFlvdSBhdHRlbXB0ZWQgdG8gZ2V0IHRoZSB2YWx1ZSBvZiBhIGhlbHBlciBhZnRlciB0aGUgaGVscGVyIHdhcyBkZXN0cm95ZWQsIHdoaWNoIGlzIG5vdCBhbGxvd2VkYFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFuYWdlci5nZXRWYWx1ZShidWNrZXQpO1xuICAgIH0pO1xuXG4gICAgYXNzb2NpYXRlRGVzdHJveWFibGVDaGlsZChjb250ZXh0LCBjYWNoZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUT0RPOiB1bnJlYWNoYWJsZSwgdG8gYmUgaW1wbGVtZW50ZWQgd2l0aCBoYXNTY2hlZHVsZWRFZmZlY3QnKTtcbiAgfVxuXG4gIGlmIChoYXNEZXN0cm95YWJsZShtYW5hZ2VyKSkge1xuICAgIGxldCBkZXN0cm95YWJsZSA9IG1hbmFnZXIuZ2V0RGVzdHJveWFibGUoYnVja2V0KTtcblxuICAgIGFzc29jaWF0ZURlc3Ryb3lhYmxlQ2hpbGQoY2FjaGUsIGRlc3Ryb3lhYmxlKTtcbiAgfVxuXG4gIHJldHVybiBjYWNoZTtcbn1cbiIsImltcG9ydCB7IEhlbHBlciwgSGVscGVyRGVmaW5pdGlvblN0YXRlIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBzZXRJbnRlcm5hbEhlbHBlck1hbmFnZXIgfSBmcm9tICdAZ2xpbW1lci9tYW5hZ2VyJztcblxuZXhwb3J0IGZ1bmN0aW9uIGludGVybmFsSGVscGVyKGhlbHBlcjogSGVscGVyKTogSGVscGVyRGVmaW5pdGlvblN0YXRlIHtcbiAgcmV0dXJuIHNldEludGVybmFsSGVscGVyTWFuYWdlcihoZWxwZXIsIHt9KTtcbn1cbiIsImltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7IENhcHR1cmVkQXJndW1lbnRzIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQge1xuICBjcmVhdGVDb21wdXRlUmVmLFxuICBpc0ludm9rYWJsZVJlZixcbiAgUmVmZXJlbmNlLFxuICB1cGRhdGVSZWYsXG4gIHZhbHVlRm9yUmVmLFxufSBmcm9tICdAZ2xpbW1lci9yZWZlcmVuY2UnO1xuaW1wb3J0IHsgcmVpZnlQb3NpdGlvbmFsIH0gZnJvbSAnQGdsaW1tZXIvcnVudGltZSc7XG5pbXBvcnQgeyBidWlsZFVudG91Y2hhYmxlVGhpcyB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgaW50ZXJuYWxIZWxwZXIgfSBmcm9tICcuL2ludGVybmFsLWhlbHBlcic7XG5cbmNvbnN0IGNvbnRleHQgPSBidWlsZFVudG91Y2hhYmxlVGhpcygnYGZuYCBoZWxwZXInKTtcblxuLyoqXG4gIFRoZSBgZm5gIGhlbHBlciBhbGxvd3MgeW91IHRvIGVuc3VyZSBhIGZ1bmN0aW9uIHRoYXQgeW91IGFyZSBwYXNzaW5nIG9mZlxuICB0byBhbm90aGVyIGNvbXBvbmVudCwgaGVscGVyLCBvciBtb2RpZmllciBoYXMgYWNjZXNzIHRvIGFyZ3VtZW50cyB0aGF0IGFyZVxuICBhdmFpbGFibGUgaW4gdGhlIHRlbXBsYXRlLlxuXG4gIEZvciBleGFtcGxlLCBpZiB5b3UgaGF2ZSBhbiBgZWFjaGAgaGVscGVyIGxvb3Bpbmcgb3ZlciBhIG51bWJlciBvZiBpdGVtcywgeW91XG4gIG1heSBuZWVkIHRvIHBhc3MgYSBmdW5jdGlvbiB0aGF0IGV4cGVjdHMgdG8gcmVjZWl2ZSB0aGUgaXRlbSBhcyBhbiBhcmd1bWVudFxuICB0byBhIGNvbXBvbmVudCBpbnZva2VkIHdpdGhpbiB0aGUgbG9vcC4gSGVyZSdzIGhvdyB5b3UgY291bGQgdXNlIHRoZSBgZm5gXG4gIGhlbHBlciB0byBwYXNzIGJvdGggdGhlIGZ1bmN0aW9uIGFuZCBpdHMgYXJndW1lbnRzIHRvZ2V0aGVyOlxuXG4gICAgYGBgYXBwL3RlbXBsYXRlcy9jb21wb25lbnRzL2l0ZW1zLWxpc3RpbmcuaGJzXG4gIHt7I2VhY2ggQGl0ZW1zIGFzIHxpdGVtfH19XG4gICAgPERpc3BsYXlJdGVtIEBpdGVtPWl0ZW0gQHNlbGVjdD17e2ZuIHRoaXMuaGFuZGxlU2VsZWN0ZWQgaXRlbX19IC8+XG4gIHt7L2VhY2h9fVxuICBgYGBcblxuICBgYGBhcHAvY29tcG9uZW50cy9pdGVtcy1saXN0LmpzXG4gIGltcG9ydCBDb21wb25lbnQgZnJvbSAnQGdsaW1tZXIvY29tcG9uZW50JztcbiAgaW1wb3J0IHsgYWN0aW9uIH0gZnJvbSAnQGVtYmVyL29iamVjdCc7XG5cbiAgZXhwb3J0IGRlZmF1bHQgY2xhc3MgSXRlbXNMaXN0IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBoYW5kbGVTZWxlY3RlZCA9IChpdGVtKSA9PiB7XG4gICAgICAvLyAuLi5zbmlwLi4uXG4gICAgfVxuICB9XG4gIGBgYFxuXG4gIEluIHRoaXMgY2FzZSB0aGUgYGRpc3BsYXktaXRlbWAgY29tcG9uZW50IHdpbGwgcmVjZWl2ZSBhIG5vcm1hbCBmdW5jdGlvblxuICB0aGF0IGl0IGNhbiBpbnZva2UuIFdoZW4gaXQgaW52b2tlcyB0aGUgZnVuY3Rpb24sIHRoZSBgaGFuZGxlU2VsZWN0ZWRgXG4gIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSB0aGUgYGl0ZW1gIGFuZCBhbnkgYXJndW1lbnRzIHBhc3NlZCwgdGhhbmtzIHRvIHRoZVxuICBgZm5gIGhlbHBlci5cblxuICBMZXQncyB0YWtlIGxvb2sgYXQgd2hhdCB0aGF0IG1lYW5zIGluIGEgY291cGxlIGNpcmN1bXN0YW5jZXM6XG5cbiAgLSBXaGVuIGludm9rZWQgYXMgYHRoaXMuYXJncy5zZWxlY3QoKWAgdGhlIGBoYW5kbGVTZWxlY3RlZGAgZnVuY3Rpb24gd2lsbFxuICAgIHJlY2VpdmUgdGhlIGBpdGVtYCBmcm9tIHRoZSBsb29wIGFzIGl0cyBmaXJzdCBhbmQgb25seSBhcmd1bWVudC5cbiAgLSBXaGVuIGludm9rZWQgYXMgYHRoaXMuYXJncy5zZWxlY3QoJ2ZvbycpYCB0aGUgYGhhbmRsZVNlbGVjdGVkYCBmdW5jdGlvblxuICAgIHdpbGwgcmVjZWl2ZSB0aGUgYGl0ZW1gIGZyb20gdGhlIGxvb3AgYXMgaXRzIGZpcnN0IGFyZ3VtZW50IGFuZCB0aGVcbiAgICBzdHJpbmcgYCdmb28nYCBhcyBpdHMgc2Vjb25kIGFyZ3VtZW50LlxuXG4gIEluIHRoZSBleGFtcGxlIGFib3ZlLCB3ZSB1c2VkIGFuIGFycm93IGZ1bmN0aW9uIHRvIGVuc3VyZSB0aGF0XG4gIGBoYW5kbGVTZWxlY3RlZGAgaXMgcHJvcGVybHkgYm91bmQgdG8gdGhlIGBpdGVtcy1saXN0YCwgYnV0IGxldCdzIGV4cGxvcmUgd2hhdFxuICBoYXBwZW5zIGlmIHdlIGxlZnQgb3V0IHRoZSBhcnJvdyBmdW5jdGlvbjpcblxuICBgYGBhcHAvY29tcG9uZW50cy9pdGVtcy1saXN0LmpzXG4gIGltcG9ydCBDb21wb25lbnQgZnJvbSAnQGdsaW1tZXIvY29tcG9uZW50JztcblxuICBleHBvcnQgZGVmYXVsdCBjbGFzcyBJdGVtc0xpc3QgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIGhhbmRsZVNlbGVjdGVkKGl0ZW0pIHtcbiAgICAgIC8vIC4uLnNuaXAuLi5cbiAgICB9XG4gIH1cbiAgYGBgXG5cbiAgSW4gdGhpcyBleGFtcGxlLCB3aGVuIGBoYW5kbGVTZWxlY3RlZGAgaXMgaW52b2tlZCBpbnNpZGUgdGhlIGBkaXNwbGF5LWl0ZW1gXG4gIGNvbXBvbmVudCwgaXQgd2lsbCAqKm5vdCoqIGhhdmUgYWNjZXNzIHRvIHRoZSBjb21wb25lbnQgaW5zdGFuY2UuIEluIG90aGVyXG4gIHdvcmRzLCBpdCB3aWxsIGhhdmUgbm8gYHRoaXNgIGNvbnRleHQsIHNvIHBsZWFzZSBtYWtlIHN1cmUgeW91ciBmdW5jdGlvbnNcbiAgYXJlIGJvdW5kICh2aWEgYW4gYXJyb3cgZnVuY3Rpb24gb3Igb3RoZXIgbWVhbnMpIGJlZm9yZSBwYXNzaW5nIGludG8gYGZuYCFcblxuICBTZWUgYWxzbyBbcGFydGlhbCBhcHBsaWNhdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGFydGlhbF9hcHBsaWNhdGlvbikuXG5cbiAgQG1ldGhvZCBmblxuICBAcHVibGljXG4qL1xuZXhwb3J0IGRlZmF1bHQgaW50ZXJuYWxIZWxwZXIoKHsgcG9zaXRpb25hbCB9OiBDYXB0dXJlZEFyZ3VtZW50cykgPT4ge1xuICBsZXQgY2FsbGJhY2tSZWYgPSBwb3NpdGlvbmFsWzBdO1xuXG4gIGlmIChERUJVRykgYXNzZXJ0Q2FsbGJhY2tJc0ZuKGNhbGxiYWNrUmVmKTtcblxuICByZXR1cm4gY3JlYXRlQ29tcHV0ZVJlZihcbiAgICAoKSA9PiB7XG4gICAgICByZXR1cm4gKC4uLmludm9jYXRpb25BcmdzOiB1bmtub3duW10pID0+IHtcbiAgICAgICAgbGV0IFtmbiwgLi4uYXJnc10gPSByZWlmeVBvc2l0aW9uYWwocG9zaXRpb25hbCk7XG5cbiAgICAgICAgaWYgKERFQlVHKSBhc3NlcnRDYWxsYmFja0lzRm4oY2FsbGJhY2tSZWYpO1xuXG4gICAgICAgIGlmIChpc0ludm9rYWJsZVJlZihjYWxsYmFja1JlZikpIHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBhcmdzLmxlbmd0aCA+IDAgPyBhcmdzWzBdIDogaW52b2NhdGlvbkFyZ3NbMF07XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZVJlZihjYWxsYmFja1JlZiwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAoZm4gYXMgRnVuY3Rpb24pLmNhbGwoY29udGV4dCwgLi4uYXJncywgLi4uaW52b2NhdGlvbkFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgbnVsbCxcbiAgICAnZm4nXG4gICk7XG59KTtcblxuZnVuY3Rpb24gYXNzZXJ0Q2FsbGJhY2tJc0ZuKGNhbGxiYWNrUmVmOiBSZWZlcmVuY2UpIHtcbiAgaWYgKFxuICAgICEoXG4gICAgICBjYWxsYmFja1JlZiAmJlxuICAgICAgKGlzSW52b2thYmxlUmVmKGNhbGxiYWNrUmVmKSB8fCB0eXBlb2YgdmFsdWVGb3JSZWYoY2FsbGJhY2tSZWYpID09PSAnZnVuY3Rpb24nKVxuICAgIClcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFlvdSBtdXN0IHBhc3MgYSBmdW5jdGlvbiBhcyB0aGUgXFxgZm5cXGAgaGVscGVyJ3MgZmlyc3QgYXJndW1lbnQsIHlvdSBwYXNzZWQgJHtcbiAgICAgICAgY2FsbGJhY2tSZWYgPyB2YWx1ZUZvclJlZihjYWxsYmFja1JlZikgOiBjYWxsYmFja1JlZlxuICAgICAgfS4gV2hpbGUgcmVuZGVyaW5nOlxcblxcbiR7Y2FsbGJhY2tSZWY/LmRlYnVnTGFiZWx9YFxuICAgICk7XG4gIH1cbn1cbiIsImltcG9ydCB7IENhcHR1cmVkQXJndW1lbnRzLCBEaWN0IH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBjcmVhdGVDb21wdXRlUmVmLCBSZWZlcmVuY2UgfSBmcm9tICdAZ2xpbW1lci9yZWZlcmVuY2UnO1xuaW1wb3J0IHsgcmVpZnlOYW1lZCB9IGZyb20gJ0BnbGltbWVyL3J1bnRpbWUnO1xuaW1wb3J0IHsgZGVwcmVjYXRlIH0gZnJvbSAnQGdsaW1tZXIvZ2xvYmFsLWNvbnRleHQnO1xuaW1wb3J0IHsgSEFTX05BVElWRV9QUk9YWSB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgaW50ZXJuYWxIZWxwZXIgfSBmcm9tICcuL2ludGVybmFsLWhlbHBlcic7XG5pbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5cbmxldCB3cmFwSGFzaFByb3h5OiAoaGFzaDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pID0+IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuXG5pZiAoREVCVUcpIHtcbiAgd3JhcEhhc2hQcm94eSA9IChoYXNoOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikgPT4ge1xuICAgIHJldHVybiBuZXcgUHJveHkoaGFzaCwge1xuICAgICAgc2V0KHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBkZXByZWNhdGUoXG4gICAgICAgICAgYFlvdSBzZXQgdGhlICcke1N0cmluZyhcbiAgICAgICAgICAgIGtleVxuICAgICAgICAgICl9JyBwcm9wZXJ0eSBvbiBhIHt7aGFzaH19IG9iamVjdC4gU2V0dGluZyBwcm9wZXJ0aWVzIG9uIG9iamVjdHMgZ2VuZXJhdGVkIGJ5IHt7aGFzaH19IGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1cGRhdGUgdG8gdXNlIGFuIG9iamVjdCBjcmVhdGVkIHdpdGggYSB0cmFja2VkIHByb3BlcnR5IG9yIGdldHRlciwgb3Igd2l0aCBhIGN1c3RvbSBoZWxwZXIuYCxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICB7IGlkOiAnc2V0dGluZy1vbi1oYXNoJyB9XG4gICAgICAgICk7XG5cbiAgICAgICAgdGFyZ2V0W2tleSBhcyBzdHJpbmddID0gdmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgIH0pO1xuICB9O1xufVxuXG4vKipcbiAgIFVzZSB0aGUgYHt7aGFzaH19YCBoZWxwZXIgdG8gY3JlYXRlIGEgaGFzaCB0byBwYXNzIGFzIGFuIG9wdGlvbiB0byB5b3VyXG4gICBjb21wb25lbnRzLiBUaGlzIGlzIHNwZWNpYWxseSB1c2VmdWwgZm9yIGNvbnRleHR1YWwgY29tcG9uZW50cyB3aGVyZSB5b3UgY2FuXG4gICBqdXN0IHlpZWxkIGEgaGFzaDpcblxuICAgYGBgaGFuZGxlYmFyc1xuICAge3t5aWVsZCAoaGFzaFxuICAgICAgbmFtZT0nU2FyYWgnXG4gICAgICB0aXRsZT1vZmZpY2VcbiAgICl9fVxuICAgYGBgXG5cbiAgIFdvdWxkIHJlc3VsdCBpbiBhbiBvYmplY3Qgc3VjaCBhczpcblxuICAgYGBganNcbiAgIHsgbmFtZTogJ1NhcmFoJywgdGl0bGU6IHRoaXMuZ2V0KCdvZmZpY2UnKSB9XG4gICBgYGBcblxuICAgV2hlcmUgdGhlIGB0aXRsZWAgaXMgYm91bmQgdG8gdXBkYXRlcyBvZiB0aGUgYG9mZmljZWAgcHJvcGVydHkuXG5cbiAgIE5vdGUgdGhhdCB0aGUgaGFzaCBpcyBhbiBlbXB0eSBvYmplY3Qgd2l0aCBubyBwcm90b3R5cGUgY2hhaW4sIHRoZXJlZm9yZVxuICAgY29tbW9uIG1ldGhvZHMgbGlrZSBgdG9TdHJpbmdgIGFyZSBub3QgYXZhaWxhYmxlIGluIHRoZSByZXN1bHRpbmcgaGFzaC5cbiAgIElmIHlvdSBuZWVkIHRvIHVzZSBzdWNoIGEgbWV0aG9kLCB5b3UgY2FuIHVzZSB0aGUgYGNhbGxgIG9yIGBhcHBseWBcbiAgIGFwcHJvYWNoOlxuXG4gICBgYGBqc1xuICAgZnVuY3Rpb24gdG9TdHJpbmcob2JqKSB7XG4gICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KG9iaik7XG4gICB9XG4gICBgYGBcblxuICAgQG1ldGhvZCBoYXNoXG4gICBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgQHJldHVybiB7T2JqZWN0fSBIYXNoXG4gICBAcHVibGljXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGludGVybmFsSGVscGVyKFxuICAoeyBuYW1lZCB9OiBDYXB0dXJlZEFyZ3VtZW50cyk6IFJlZmVyZW5jZTxEaWN0PHVua25vd24+PiA9PiB7XG4gICAgbGV0IHJlZiA9IGNyZWF0ZUNvbXB1dGVSZWYoXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGxldCBoYXNoID0gcmVpZnlOYW1lZChuYW1lZCk7XG5cbiAgICAgICAgaWYgKERFQlVHICYmIEhBU19OQVRJVkVfUFJPWFkpIHtcbiAgICAgICAgICBoYXNoID0gd3JhcEhhc2hQcm94eShoYXNoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgfSxcbiAgICAgIG51bGwsXG4gICAgICAnaGFzaCdcbiAgICApO1xuXG4gICAgLy8gU2V0dXAgdGhlIGNoaWxkcmVuIHNvIHRoYXQgdGVtcGxhdGVzIGNhbiBieXBhc3MgZ2V0dGluZyB0aGUgdmFsdWUgb2ZcbiAgICAvLyB0aGUgcmVmZXJlbmNlIGFuZCB0cmVhdCBjaGlsZHJlbiBsYXppbHlcbiAgICBsZXQgY2hpbGRyZW4gPSBuZXcgTWFwKCk7XG5cbiAgICBmb3IgKGxldCBuYW1lIGluIG5hbWVkKSB7XG4gICAgICBjaGlsZHJlbi5zZXQobmFtZSwgbmFtZWRbbmFtZV0pO1xuICAgIH1cblxuICAgIHJlZi5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuXG4gICAgcmV0dXJuIHJlZjtcbiAgfVxuKTtcbiIsImltcG9ydCB7IENhcHR1cmVkQXJndW1lbnRzIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBjcmVhdGVDb21wdXRlUmVmLCBSZWZlcmVuY2UgfSBmcm9tICdAZ2xpbW1lci9yZWZlcmVuY2UnO1xuaW1wb3J0IHsgcmVpZnlQb3NpdGlvbmFsIH0gZnJvbSAnQGdsaW1tZXIvcnVudGltZSc7XG5pbXBvcnQgeyBpbnRlcm5hbEhlbHBlciB9IGZyb20gJy4vaW50ZXJuYWwtaGVscGVyJztcblxuLyoqXG4gICBVc2UgdGhlIGB7e2FycmF5fX1gIGhlbHBlciB0byBjcmVhdGUgYW4gYXJyYXkgdG8gcGFzcyBhcyBhbiBvcHRpb24gdG8geW91clxuICAgY29tcG9uZW50cy5cblxuICAgYGBgaGFuZGxlYmFyc1xuICAgPE15Q29tcG9uZW50IEBwZW9wbGU9e3thcnJheVxuICAgICAnVG9tIERhbGUnXG4gICAgICdZZWh1ZGEgS2F0eidcbiAgICAgdGhpcy5teU90aGVyUGVyc29ufX1cbiAgIC8+XG4gICBgYGBcbiAgICBvclxuICAgYGBgaGFuZGxlYmFyc1xuICAge3tteS1jb21wb25lbnQgcGVvcGxlPShhcnJheVxuICAgICAnVG9tIERhbGUnXG4gICAgICdZZWh1ZGEgS2F0eidcbiAgICAgdGhpcy5teU90aGVyUGVyc29uKVxuICAgfX1cbiAgIGBgYFxuXG4gICBXb3VsZCByZXN1bHQgaW4gYW4gb2JqZWN0IHN1Y2ggYXM6XG5cbiAgIGBgYGpzXG4gICBbJ1RvbSBEYWxlJywgJ1llaHVkYSBLYXR6JywgdGhpcy5nZXQoJ215T3RoZXJQZXJzb24nKV1cbiAgIGBgYFxuXG4gICBXaGVyZSB0aGUgM3JkIGl0ZW0gaW4gdGhlIGFycmF5IGlzIGJvdW5kIHRvIHVwZGF0ZXMgb2YgdGhlIGBteU90aGVyUGVyc29uYCBwcm9wZXJ0eS5cblxuICAgQG1ldGhvZCBhcnJheVxuICAgQHBhcmFtIHtBcnJheX0gb3B0aW9uc1xuICAgQHJldHVybiB7QXJyYXl9IEFycmF5XG4gICBAcHVibGljXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgaW50ZXJuYWxIZWxwZXIoXG4gICh7IHBvc2l0aW9uYWwgfTogQ2FwdHVyZWRBcmd1bWVudHMpOiBSZWZlcmVuY2U8dW5rbm93bltdPiA9PiB7XG4gICAgcmV0dXJuIGNyZWF0ZUNvbXB1dGVSZWYoKCkgPT4gcmVpZnlQb3NpdGlvbmFsKHBvc2l0aW9uYWwpLCBudWxsLCAnYXJyYXknKTtcbiAgfVxuKTtcbiIsImltcG9ydCB7IGdldFBhdGgsIHNldFBhdGggfSBmcm9tICdAZ2xpbW1lci9nbG9iYWwtY29udGV4dCc7XG5pbXBvcnQgeyBpc0RpY3QgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IENhcHR1cmVkQXJndW1lbnRzIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBjcmVhdGVDb21wdXRlUmVmLCBVTkRFRklORURfUkVGRVJFTkNFLCB2YWx1ZUZvclJlZiB9IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQgeyBpbnRlcm5hbEhlbHBlciB9IGZyb20gJy4vaW50ZXJuYWwtaGVscGVyJztcblxuLyoqXG4gIER5bmFtaWNhbGx5IGxvb2sgdXAgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuIFRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYHt7Z2V0fX1gXG4gIHNob3VsZCBoYXZlIGEgc3RyaW5nIHZhbHVlLCBhbHRob3VnaCBpdCBjYW4gYmUgYm91bmQuXG5cbiAgRm9yIGV4YW1wbGUsIHRoZXNlIHR3byB1c2FnZXMgYXJlIGVxdWl2YWxlbnQ6XG5cbiAgYGBgYXBwL2NvbXBvbmVudHMvZGV2ZWxvcGVyLWRldGFpbC5qc1xuICBpbXBvcnQgQ29tcG9uZW50IGZyb20gJ0BnbGltbWVyL2NvbXBvbmVudCc7XG4gIGltcG9ydCB7IHRyYWNrZWQgfSBmcm9tICdAZ2xpbW1lci90cmFja2luZyc7XG5cbiAgZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIEB0cmFja2VkIGRldmVsb3BlciA9IHtcbiAgICAgIG5hbWU6IFwiU2FuZGkgTWV0elwiLFxuICAgICAgbGFuZ3VhZ2U6IFwiUnVieVwiXG4gICAgfVxuICB9XG4gIGBgYFxuXG4gIGBgYGhhbmRsZWJhcnNcbiAge3t0aGlzLmRldmVsb3Blci5uYW1lfX1cbiAge3tnZXQgdGhpcy5kZXZlbG9wZXIgXCJuYW1lXCJ9fVxuICBgYGBcblxuICBJZiB0aGVyZSB3ZXJlIHNldmVyYWwgZmFjdHMgYWJvdXQgYSBwZXJzb24sIHRoZSBge3tnZXR9fWAgaGVscGVyIGNhbiBkeW5hbWljYWxseVxuICBwaWNrIG9uZTpcblxuICBgYGBhcHAvdGVtcGxhdGVzL2FwcGxpY2F0aW9uLmhic1xuICA8RGV2ZWxvcGVyRGV0YWlsIEBmYWN0TmFtZT1cImxhbmd1YWdlXCIgLz5cbiAgYGBgXG5cbiAgYGBgaGFuZGxlYmFyc1xuICB7e2dldCB0aGlzLmRldmVsb3BlciBAZmFjdE5hbWV9fVxuICBgYGBcblxuICBGb3IgYSBtb3JlIGNvbXBsZXggZXhhbXBsZSwgdGhpcyB0ZW1wbGF0ZSB3b3VsZCBhbGxvdyB0aGUgdXNlciB0byBzd2l0Y2hcbiAgYmV0d2VlbiBzaG93aW5nIHRoZSB1c2VyJ3MgaGVpZ2h0IGFuZCB3ZWlnaHQgd2l0aCBhIGNsaWNrOlxuXG4gIGBgYGFwcC9jb21wb25lbnRzL2RldmVsb3Blci1kZXRhaWwuanNcbiAgaW1wb3J0IENvbXBvbmVudCBmcm9tICdAZ2xpbW1lci9jb21wb25lbnQnO1xuICBpbXBvcnQgeyB0cmFja2VkIH0gZnJvbSAnQGdsaW1tZXIvdHJhY2tpbmcnO1xuXG4gIGV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBAdHJhY2tlZCBkZXZlbG9wZXIgPSB7XG4gICAgICBuYW1lOiBcIlNhbmRpIE1ldHpcIixcbiAgICAgIGxhbmd1YWdlOiBcIlJ1YnlcIlxuICAgIH1cblxuICAgIEB0cmFja2VkIGN1cnJlbnRGYWN0ID0gJ25hbWUnXG5cbiAgICBzaG93RmFjdCA9IChmYWN0KSA9PiB7XG4gICAgICB0aGlzLmN1cnJlbnRGYWN0ID0gZmFjdDtcbiAgICB9XG4gIH1cbiAgYGBgXG5cbiAgYGBgYXBwL2NvbXBvbmVudHMvZGV2ZWxvcGVyLWRldGFpbC5qc1xuICB7e2dldCB0aGlzLmRldmVsb3BlciB0aGlzLmN1cnJlbnRGYWN0fX1cblxuICA8YnV0dG9uIHt7b24gJ2NsaWNrJyAoZm4gdGhpcy5zaG93RmFjdCBcIm5hbWVcIil9fT5TaG93IG5hbWU8L2J1dHRvbj5cbiAgPGJ1dHRvbiB7e29uICdjbGljaycgKGZuIHRoaXMuc2hvd0ZhY3QgXCJsYW5ndWFnZVwiKX19PlNob3cgbGFuZ3VhZ2U8L2J1dHRvbj5cbiAgYGBgXG5cbiAgVGhlIGB7e2dldH19YCBoZWxwZXIgY2FuIGFsc28gcmVzcGVjdCBtdXRhYmxlIHZhbHVlcyBpdHNlbGYuIEZvciBleGFtcGxlOlxuXG4gIGBgYGFwcC9jb21wb25lbnRzL2RldmVsb3Blci1kZXRhaWwuanNcbiAgPElucHV0IEB2YWx1ZT17e211dCAoZ2V0IHRoaXMucGVyc29uIHRoaXMuY3VycmVudEZhY3QpfX0gLz5cblxuICA8YnV0dG9uIHt7b24gJ2NsaWNrJyAoZm4gdGhpcy5zaG93RmFjdCBcIm5hbWVcIil9fT5TaG93IG5hbWU8L2J1dHRvbj5cbiAgPGJ1dHRvbiB7e29uICdjbGljaycgKGZuIHRoaXMuc2hvd0ZhY3QgXCJsYW5ndWFnZVwiKX19PlNob3cgbGFuZ3VhZ2U8L2J1dHRvbj5cbiAgYGBgXG5cbiAgV291bGQgYWxsb3cgdGhlIHVzZXIgdG8gc3dhcCB3aGF0IGZhY3QgaXMgYmVpbmcgZGlzcGxheWVkLCBhbmQgYWxzbyBlZGl0XG4gIHRoYXQgZmFjdCB2aWEgYSB0d28td2F5IG11dGFibGUgYmluZGluZy5cblxuICBAcHVibGljXG4gIEBtZXRob2QgZ2V0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGludGVybmFsSGVscGVyKCh7IHBvc2l0aW9uYWwgfTogQ2FwdHVyZWRBcmd1bWVudHMpID0+IHtcbiAgbGV0IHNvdXJjZVJlZiA9IHBvc2l0aW9uYWxbMF0gPz8gVU5ERUZJTkVEX1JFRkVSRU5DRTtcbiAgbGV0IHBhdGhSZWYgPSBwb3NpdGlvbmFsWzFdID8/IFVOREVGSU5FRF9SRUZFUkVOQ0U7XG5cbiAgcmV0dXJuIGNyZWF0ZUNvbXB1dGVSZWYoXG4gICAgKCkgPT4ge1xuICAgICAgbGV0IHNvdXJjZSA9IHZhbHVlRm9yUmVmKHNvdXJjZVJlZik7XG5cbiAgICAgIGlmIChpc0RpY3Qoc291cmNlKSkge1xuICAgICAgICByZXR1cm4gZ2V0UGF0aChzb3VyY2UsIFN0cmluZyh2YWx1ZUZvclJlZihwYXRoUmVmKSkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgKHZhbHVlKSA9PiB7XG4gICAgICBsZXQgc291cmNlID0gdmFsdWVGb3JSZWYoc291cmNlUmVmKTtcblxuICAgICAgaWYgKGlzRGljdChzb3VyY2UpKSB7XG4gICAgICAgIHJldHVybiBzZXRQYXRoKHNvdXJjZSwgU3RyaW5nKHZhbHVlRm9yUmVmKHBhdGhSZWYpKSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2dldCdcbiAgKTtcbn0pO1xuIiwiaW1wb3J0IHsgQ2FwdHVyZWRBcmd1bWVudHMgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGNyZWF0ZUNvbXB1dGVSZWYgfSBmcm9tICdAZ2xpbW1lci9yZWZlcmVuY2UnO1xuaW1wb3J0IHsgcmVpZnlQb3NpdGlvbmFsIH0gZnJvbSAnQGdsaW1tZXIvcnVudGltZSc7XG5pbXBvcnQgeyBpbnRlcm5hbEhlbHBlciB9IGZyb20gJy4vaW50ZXJuYWwtaGVscGVyJztcblxuY29uc3QgaXNFbXB0eSA9ICh2YWx1ZTogdW5rbm93bik6IGJvb2xlYW4gPT4ge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgKHZhbHVlIGFzIG9iamVjdCkudG9TdHJpbmcgIT09ICdmdW5jdGlvbic7XG59O1xuXG5jb25zdCBub3JtYWxpemVUZXh0VmFsdWUgPSAodmFsdWU6IHVua25vd24pOiBzdHJpbmcgPT4ge1xuICBpZiAoaXNFbXB0eSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG59O1xuXG4vKipcbiAgQ29uY2F0ZW5hdGVzIHRoZSBnaXZlbiBhcmd1bWVudHMgaW50byBhIHN0cmluZy5cblxuICBFeGFtcGxlOlxuXG4gIGBgYGhhbmRsZWJhcnNcbiAge3tzb21lLWNvbXBvbmVudCBuYW1lPShjb25jYXQgZmlyc3ROYW1lIFwiIFwiIGxhc3ROYW1lKX19XG5cbiAge3shIHdvdWxkIHBhc3MgbmFtZT1cIjxmaXJzdCBuYW1lIHZhbHVlPiA8bGFzdCBuYW1lIHZhbHVlPlwiIHRvIHRoZSBjb21wb25lbnR9fVxuICBgYGBcblxuICBvciBmb3IgYW5nbGUgYnJhY2tldCBpbnZvY2F0aW9uLCB5b3UgYWN0dWFsbHkgZG9uJ3QgbmVlZCBjb25jYXQgYXQgYWxsLlxuXG4gIGBgYGhhbmRsZWJhcnNcbiAgPFNvbWVDb21wb25lbnQgQG5hbWU9XCJ7e2ZpcnN0TmFtZX19IHt7bGFzdE5hbWV9fVwiIC8+XG4gIGBgYFxuXG4gIEBwdWJsaWNcbiAgQG1ldGhvZCBjb25jYXRcbiovXG5leHBvcnQgZGVmYXVsdCBpbnRlcm5hbEhlbHBlcigoeyBwb3NpdGlvbmFsIH06IENhcHR1cmVkQXJndW1lbnRzKSA9PiB7XG4gIHJldHVybiBjcmVhdGVDb21wdXRlUmVmKFxuICAgICgpID0+IHJlaWZ5UG9zaXRpb25hbChwb3NpdGlvbmFsKS5tYXAobm9ybWFsaXplVGV4dFZhbHVlKS5qb2luKCcnKSxcbiAgICBudWxsLFxuICAgICdjb25jYXQnXG4gICk7XG59KTtcbiIsImltcG9ydCB7IHJlZ2lzdGVyRGVzdHJ1Y3RvciB9IGZyb20gJ0BnbGltbWVyL2Rlc3Ryb3lhYmxlJztcbmltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7IENhcHR1cmVkQXJndW1lbnRzLCBJbnRlcm5hbE1vZGlmaWVyTWFuYWdlciwgT3duZXIgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IHNldEludGVybmFsTW9kaWZpZXJNYW5hZ2VyIH0gZnJvbSAnQGdsaW1tZXIvbWFuYWdlcic7XG5pbXBvcnQgeyB2YWx1ZUZvclJlZiB9IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQgeyByZWlmeU5hbWVkIH0gZnJvbSAnQGdsaW1tZXIvcnVudGltZSc7XG5pbXBvcnQgeyBjcmVhdGVVcGRhdGFibGVUYWcsIFVwZGF0YWJsZVRhZyB9IGZyb20gJ0BnbGltbWVyL3ZhbGlkYXRvcic7XG5pbXBvcnQgeyBTaW1wbGVFbGVtZW50IH0gZnJvbSAnQHNpbXBsZS1kb20vaW50ZXJmYWNlJztcbmltcG9ydCB7IGJ1aWxkVW50b3VjaGFibGVUaGlzIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmNvbnN0IHVudG91Y2hhYmxlQ29udGV4dCA9IGJ1aWxkVW50b3VjaGFibGVUaGlzKCdgb25gIG1vZGlmaWVyJyk7XG5cbi8qXG4gIEludGVybmV0IEV4cGxvcmVyIDExIGRvZXMgbm90IHN1cHBvcnQgYG9uY2VgIGFuZCBhbHNvIGRvZXMgbm90IHN1cHBvcnRcbiAgcGFzc2luZyBgZXZlbnRPcHRpb25zYC4gSW4gc29tZSBzaXR1YXRpb25zIGl0IHRoZW4gdGhyb3dzIGEgd2VpcmQgc2NyaXB0XG4gIGVycm9yLCBsaWtlOlxuXG4gIGBgYFxuICBDb3VsZCBub3QgY29tcGxldGUgdGhlIG9wZXJhdGlvbiBkdWUgdG8gZXJyb3IgODAwMjAxMDFcbiAgYGBgXG5cbiAgVGhpcyBmbGFnIGRldGVybWluZXMsIHdoZXRoZXIgYHsgb25jZTogdHJ1ZSB9YCBhbmQgdGh1cyBhbHNvIGV2ZW50IG9wdGlvbnMgaW5cbiAgZ2VuZXJhbCBhcmUgc3VwcG9ydGVkLlxuKi9cbmNvbnN0IFNVUFBPUlRTX0VWRU5UX09QVElPTlMgPSAoKCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGxldCBjb3VudGVyID0gMDtcbiAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiBjb3VudGVyKyssIHsgb25jZTogdHJ1ZSB9KTtcblxuICAgIGxldCBldmVudDtcbiAgICBpZiAodHlwZW9mIEV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBldmVudCA9IG5ldyBFdmVudCgnY2xpY2snKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIGV2ZW50LmluaXRFdmVudCgnY2xpY2snLCB0cnVlLCB0cnVlKTtcbiAgICB9XG5cbiAgICBkaXYuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgZGl2LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXG4gICAgcmV0dXJuIGNvdW50ZXIgPT09IDE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuXG5leHBvcnQgY2xhc3MgT25Nb2RpZmllclN0YXRlIHtcbiAgcHVibGljIHRhZyA9IGNyZWF0ZVVwZGF0YWJsZVRhZygpO1xuICBwdWJsaWMgZWxlbWVudDogRWxlbWVudDtcbiAgcHVibGljIGFyZ3M6IENhcHR1cmVkQXJndW1lbnRzO1xuICBwdWJsaWMgZXZlbnROYW1lITogc3RyaW5nO1xuICBwdWJsaWMgY2FsbGJhY2shOiBFdmVudExpc3RlbmVyO1xuICBwcml2YXRlIHVzZXJQcm92aWRlZENhbGxiYWNrITogRXZlbnRMaXN0ZW5lcjtcbiAgcHVibGljIG9uY2U/OiBib29sZWFuO1xuICBwdWJsaWMgcGFzc2l2ZT86IGJvb2xlYW47XG4gIHB1YmxpYyBjYXB0dXJlPzogYm9vbGVhbjtcbiAgcHVibGljIG9wdGlvbnM/OiBBZGRFdmVudExpc3RlbmVyT3B0aW9ucztcbiAgcHVibGljIHNob3VsZFVwZGF0ZSA9IHRydWU7XG5cbiAgY29uc3RydWN0b3IoZWxlbWVudDogRWxlbWVudCwgYXJnczogQ2FwdHVyZWRBcmd1bWVudHMpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gIH1cblxuICB1cGRhdGVGcm9tQXJncygpOiB2b2lkIHtcbiAgICBsZXQgeyBhcmdzIH0gPSB0aGlzO1xuXG4gICAgbGV0IHsgb25jZSwgcGFzc2l2ZSwgY2FwdHVyZSB9OiBBZGRFdmVudExpc3RlbmVyT3B0aW9ucyA9IHJlaWZ5TmFtZWQoYXJncy5uYW1lZCk7XG4gICAgaWYgKG9uY2UgIT09IHRoaXMub25jZSkge1xuICAgICAgdGhpcy5vbmNlID0gb25jZTtcbiAgICAgIHRoaXMuc2hvdWxkVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAocGFzc2l2ZSAhPT0gdGhpcy5wYXNzaXZlKSB7XG4gICAgICB0aGlzLnBhc3NpdmUgPSBwYXNzaXZlO1xuICAgICAgdGhpcy5zaG91bGRVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChjYXB0dXJlICE9PSB0aGlzLmNhcHR1cmUpIHtcbiAgICAgIHRoaXMuY2FwdHVyZSA9IGNhcHR1cmU7XG4gICAgICB0aGlzLnNob3VsZFVwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgbGV0IG9wdGlvbnM6IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zO1xuICAgIC8vIHdlIHdhbnQgdG8gaGFuZGxlIGJvdGggYHRydWVgIGFuZCBgZmFsc2VgIGJlY2F1c2UgYm90aCBoYXZlIGEgbWVhbmluZzpcbiAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD03NzAyMDhcbiAgICBpZiAob25jZSAhPT0gdW5kZWZpbmVkIHx8IHBhc3NpdmUgIT09IHVuZGVmaW5lZCB8fCBjYXB0dXJlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgPSB7IG9uY2UsIHBhc3NpdmUsIGNhcHR1cmUgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIERFQlVHICYmXG4gICAgICAoYXJncy5wb3NpdGlvbmFsWzBdID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHZhbHVlRm9yUmVmKGFyZ3MucG9zaXRpb25hbFswXSkgIT09ICdzdHJpbmcnKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnWW91IG11c3QgcGFzcyBhIHZhbGlkIERPTSBldmVudCBuYW1lIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgYG9uYCBtb2RpZmllcidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IGV2ZW50TmFtZSA9IHZhbHVlRm9yUmVmKGFyZ3MucG9zaXRpb25hbFswXSkgYXMgc3RyaW5nO1xuICAgIGlmIChldmVudE5hbWUgIT09IHRoaXMuZXZlbnROYW1lKSB7XG4gICAgICB0aGlzLmV2ZW50TmFtZSA9IGV2ZW50TmFtZTtcbiAgICAgIHRoaXMuc2hvdWxkVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBsZXQgdXNlclByb3ZpZGVkQ2FsbGJhY2tSZWZlcmVuY2UgPSBhcmdzLnBvc2l0aW9uYWxbMV07XG5cbiAgICBpZiAoREVCVUcpIHtcbiAgICAgIGlmIChhcmdzLnBvc2l0aW9uYWxbMV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBtdXN0IHBhc3MgYSBmdW5jdGlvbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIHRoZSBcXGBvblxcYCBtb2RpZmllci5gKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHZhbHVlID0gdmFsdWVGb3JSZWYodXNlclByb3ZpZGVkQ2FsbGJhY2tSZWZlcmVuY2UpO1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgWW91IG11c3QgcGFzcyBhIGZ1bmN0aW9uIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gdGhlIFxcYG9uXFxgIG1vZGlmaWVyOyB5b3UgcGFzc2VkICR7XG4gICAgICAgICAgICB2YWx1ZSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiB2YWx1ZVxuICAgICAgICAgIH0uIFdoaWxlIHJlbmRlcmluZzpcXG5cXG4ke3VzZXJQcm92aWRlZENhbGxiYWNrUmVmZXJlbmNlLmRlYnVnTGFiZWx9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCB1c2VyUHJvdmlkZWRDYWxsYmFjayA9IHZhbHVlRm9yUmVmKHVzZXJQcm92aWRlZENhbGxiYWNrUmVmZXJlbmNlKSBhcyBFdmVudExpc3RlbmVyO1xuICAgIGlmICh1c2VyUHJvdmlkZWRDYWxsYmFjayAhPT0gdGhpcy51c2VyUHJvdmlkZWRDYWxsYmFjaykge1xuICAgICAgdGhpcy51c2VyUHJvdmlkZWRDYWxsYmFjayA9IHVzZXJQcm92aWRlZENhbGxiYWNrO1xuICAgICAgdGhpcy5zaG91bGRVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChERUJVRyAmJiBhcmdzLnBvc2l0aW9uYWwubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBZb3UgY2FuIG9ubHkgcGFzcyB0d28gcG9zaXRpb25hbCBhcmd1bWVudHMgKGV2ZW50IG5hbWUgYW5kIGNhbGxiYWNrKSB0byB0aGUgXFxgb25cXGAgbW9kaWZpZXIsIGJ1dCB5b3UgcHJvdmlkZWQgJHthcmdzLnBvc2l0aW9uYWwubGVuZ3RofS4gQ29uc2lkZXIgdXNpbmcgdGhlIFxcYGZuXFxgIGhlbHBlciB0byBwcm92aWRlIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHRoZSBcXGBvblxcYCBjYWxsYmFjay5gXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCBuZWVkc0N1c3RvbUNhbGxiYWNrID1cbiAgICAgIChTVVBQT1JUU19FVkVOVF9PUFRJT05TID09PSBmYWxzZSAmJiBvbmNlKSAvKiBuZWVkcyBtYW51YWwgb25jZSBpbXBsZW1lbnRhdGlvbiAqLyB8fFxuICAgICAgKERFQlVHICYmIHBhc3NpdmUpOyAvKiBuZWVkcyBwYXNzaXZlIGVuZm9yY2VtZW50ICovXG5cbiAgICBpZiAodGhpcy5zaG91bGRVcGRhdGUpIHtcbiAgICAgIGlmIChuZWVkc0N1c3RvbUNhbGxiYWNrKSB7XG4gICAgICAgIGxldCBjYWxsYmFjayA9ICh0aGlzLmNhbGxiYWNrID0gZnVuY3Rpb24gKHRoaXM6IEVsZW1lbnQsIGV2ZW50KSB7XG4gICAgICAgICAgaWYgKERFQlVHICYmIHBhc3NpdmUpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYFlvdSBtYXJrZWQgdGhpcyBsaXN0ZW5lciBhcyAncGFzc2l2ZScsIG1lYW5pbmcgdGhhdCB5b3UgbXVzdCBub3QgY2FsbCAnZXZlbnQucHJldmVudERlZmF1bHQoKSc6IFxcblxcbiR7dXNlclByb3ZpZGVkQ2FsbGJhY2t9YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIVNVUFBPUlRTX0VWRU5UX09QVElPTlMgJiYgb25jZSkge1xuICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLCBldmVudE5hbWUsIGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHVzZXJQcm92aWRlZENhbGxiYWNrLmNhbGwodW50b3VjaGFibGVDb250ZXh0LCBldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChERUJVRykge1xuICAgICAgICAvLyBwcmV2ZW50IHRoZSBjYWxsYmFjayBmcm9tIGJlaW5nIGJvdW5kIHRvIHRoZSBlbGVtZW50XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSB1c2VyUHJvdmlkZWRDYWxsYmFjay5iaW5kKHVudG91Y2hhYmxlQ29udGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gdXNlclByb3ZpZGVkQ2FsbGJhY2s7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmxldCBhZGRzID0gMDtcbmxldCByZW1vdmVzID0gMDtcblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgZWxlbWVudDogRWxlbWVudCxcbiAgZXZlbnROYW1lOiBzdHJpbmcsXG4gIGNhbGxiYWNrOiBFdmVudExpc3RlbmVyLFxuICBvcHRpb25zPzogQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnNcbik6IHZvaWQge1xuICByZW1vdmVzKys7XG5cbiAgaWYgKFNVUFBPUlRTX0VWRU5UX09QVElPTlMpIHtcbiAgICAvLyB3aGVuIG9wdGlvbnMgYXJlIHN1cHBvcnRlZCwgdXNlIHRoZW0gYWNyb3NzIHRoZSBib2FyZFxuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgfSBlbHNlIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5jYXB0dXJlKSB7XG4gICAgLy8gdXNlZCBvbmx5IGluIHRoZSBmb2xsb3dpbmcgY2FzZTpcbiAgICAvL1xuICAgIC8vIGB7IG9uY2U6IHRydWUgfCBmYWxzZSwgcGFzc2l2ZTogdHJ1ZSB8IGZhbHNlLCBjYXB0dXJlOiB0cnVlIH1cbiAgICAvL1xuICAgIC8vIGBvbmNlYCBpcyBoYW5kbGVkIHZpYSBhIGN1c3RvbSBjYWxsYmFjayB0aGF0IHJlbW92ZXMgYWZ0ZXIgZmlyc3RcbiAgICAvLyBpbnZvY2F0aW9uIHNvIHdlIG9ubHkgY2FyZSBhYm91dCBjYXB0dXJlIGhlcmUgYXMgYSBib29sZWFuXG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2ssIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIC8vIHVzZWQgb25seSBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICAgIC8vXG4gICAgLy8gKiB3aGVyZSB0aGVyZSBpcyBubyBvcHRpb25zXG4gICAgLy8gKiBgeyBvbmNlOiB0cnVlIHwgZmFsc2UsIHBhc3NpdmU6IHRydWUgfCBmYWxzZSwgY2FwdHVyZTogZmFsc2UgfVxuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKFxuICBlbGVtZW50OiBFbGVtZW50LFxuICBldmVudE5hbWU6IHN0cmluZyxcbiAgY2FsbGJhY2s6IEV2ZW50TGlzdGVuZXIsXG4gIG9wdGlvbnM/OiBBZGRFdmVudExpc3RlbmVyT3B0aW9uc1xuKTogdm9pZCB7XG4gIGFkZHMrKztcblxuICBpZiAoU1VQUE9SVFNfRVZFTlRfT1BUSU9OUykge1xuICAgIC8vIHdoZW4gb3B0aW9ucyBhcmUgc3VwcG9ydGVkLCB1c2UgdGhlbSBhY3Jvc3MgdGhlIGJvYXJkXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmNhcHR1cmUpIHtcbiAgICAvLyB1c2VkIG9ubHkgaW4gdGhlIGZvbGxvd2luZyBjYXNlOlxuICAgIC8vXG4gICAgLy8gYHsgb25jZTogdHJ1ZSB8IGZhbHNlLCBwYXNzaXZlOiB0cnVlIHwgZmFsc2UsIGNhcHR1cmU6IHRydWUgfVxuICAgIC8vXG4gICAgLy8gYG9uY2VgIGlzIGhhbmRsZWQgdmlhIGEgY3VzdG9tIGNhbGxiYWNrIHRoYXQgcmVtb3ZlcyBhZnRlciBmaXJzdFxuICAgIC8vIGludm9jYXRpb24gc28gd2Ugb25seSBjYXJlIGFib3V0IGNhcHR1cmUgaGVyZSBhcyBhIGJvb2xlYW5cbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjaywgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXNlZCBvbmx5IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gICAgLy9cbiAgICAvLyAqIHdoZXJlIHRoZXJlIGlzIG5vIG9wdGlvbnNcbiAgICAvLyAqIGB7IG9uY2U6IHRydWUgfCBmYWxzZSwgcGFzc2l2ZTogdHJ1ZSB8IGZhbHNlLCBjYXB0dXJlOiBmYWxzZSB9XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICB9XG59XG5cbi8qKlxuICBUaGUgYHt7b259fWAgbW9kaWZpZXIgbGV0cyB5b3UgZWFzaWx5IGFkZCBldmVudCBsaXN0ZW5lcnMgKGl0IHVzZXNcbiAgW0V2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXJdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9hZGRFdmVudExpc3RlbmVyKVxuICBpbnRlcm5hbGx5KS5cblxuICBGb3IgZXhhbXBsZSwgaWYgeW91J2QgbGlrZSB0byBydW4gYSBmdW5jdGlvbiBvbiB5b3VyIGNvbXBvbmVudCB3aGVuIGEgYDxidXR0b24+YFxuICBpbiB0aGUgY29tcG9uZW50cyB0ZW1wbGF0ZSBpcyBjbGlja2VkIHlvdSBtaWdodCBkbyBzb21ldGhpbmcgbGlrZTpcblxuICBgYGBhcHAvY29tcG9uZW50cy9saWtlLXBvc3QuaGJzXG4gIDxidXR0b24ge3tvbiAnY2xpY2snIHRoaXMuc2F2ZUxpa2V9fT5MaWtlIHRoaXMgcG9zdCE8L2J1dHRvbj5cbiAgYGBgXG5cbiAgYGBgYXBwL2NvbXBvbmVudHMvbGlrZS1wb3N0LmpzXG4gIGltcG9ydCBDb21wb25lbnQgZnJvbSAnQGdsaW1tZXIvY29tcG9uZW50JztcbiAgaW1wb3J0IHsgYWN0aW9uIH0gZnJvbSAnQGVtYmVyL29iamVjdCc7XG5cbiAgZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlrZVBvc3RDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHNhdmVMaWtlID0gKCkgPT4ge1xuICAgICAgLy8gc29tZW9uZSBsaWtlcyB5b3VyIHBvc3QhXG4gICAgICAvLyBiZXR0ZXIgc2VuZCBhIHJlcXVlc3Qgb2ZmIHRvIHlvdXIgc2VydmVyLi4uXG4gICAgfVxuICB9XG4gIGBgYFxuXG4gICMjIyBBcmd1bWVudHNcblxuICBge3tvbn19YCBhY2NlcHRzIHR3byBwb3NpdGlvbmFsIGFyZ3VtZW50cywgYW5kIGEgZmV3IG5hbWVkIGFyZ3VtZW50cy5cblxuICBUaGUgcG9zaXRpb25hbCBhcmd1bWVudHMgYXJlOlxuXG4gIC0gYGV2ZW50YCAtLSB0aGUgbmFtZSB0byB1c2Ugd2hlbiBjYWxsaW5nIGBhZGRFdmVudExpc3RlbmVyYFxuICAtIGBjYWxsYmFja2AgLS0gdGhlIGZ1bmN0aW9uIHRvIGJlIHBhc3NlZCB0byBgYWRkRXZlbnRMaXN0ZW5lcmBcblxuICBUaGUgbmFtZWQgYXJndW1lbnRzIGFyZTpcblxuICAtIGNhcHR1cmUgLS0gYSBgdHJ1ZWAgdmFsdWUgaW5kaWNhdGVzIHRoYXQgZXZlbnRzIG9mIHRoaXMgdHlwZSB3aWxsIGJlIGRpc3BhdGNoZWRcbiAgICB0byB0aGUgcmVnaXN0ZXJlZCBsaXN0ZW5lciBiZWZvcmUgYmVpbmcgZGlzcGF0Y2hlZCB0byBhbnkgRXZlbnRUYXJnZXQgYmVuZWF0aCBpdFxuICAgIGluIHRoZSBET00gdHJlZS5cbiAgLSBvbmNlIC0tIGluZGljYXRlcyB0aGF0IHRoZSBsaXN0ZW5lciBzaG91bGQgYmUgaW52b2tlZCBhdCBtb3N0IG9uY2UgYWZ0ZXIgYmVpbmdcbiAgICBhZGRlZC4gSWYgdHJ1ZSwgdGhlIGxpc3RlbmVyIHdvdWxkIGJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCB3aGVuIGludm9rZWQuXG4gIC0gcGFzc2l2ZSAtLSBpZiBgdHJ1ZWAsIGluZGljYXRlcyB0aGF0IHRoZSBmdW5jdGlvbiBzcGVjaWZpZWQgYnkgbGlzdGVuZXIgd2lsbCBuZXZlclxuICAgIGNhbGwgcHJldmVudERlZmF1bHQoKS4gSWYgYSBwYXNzaXZlIGxpc3RlbmVyIGRvZXMgY2FsbCBwcmV2ZW50RGVmYXVsdCgpLCB0aGUgdXNlclxuICAgIGFnZW50IHdpbGwgZG8gbm90aGluZyBvdGhlciB0aGFuIGdlbmVyYXRlIGEgY29uc29sZSB3YXJuaW5nLiBTZWVcbiAgICBbSW1wcm92aW5nIHNjcm9sbGluZyBwZXJmb3JtYW5jZSB3aXRoIHBhc3NpdmUgbGlzdGVuZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lciNJbXByb3Zpbmdfc2Nyb2xsaW5nX3BlcmZvcm1hbmNlX3dpdGhfcGFzc2l2ZV9saXN0ZW5lcnMpXG4gICAgdG8gbGVhcm4gbW9yZS5cblxuICBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gcGFzc2VkIHRvIGB7e29ufX1gIHdpbGwgcmVjZWl2ZSBhbnkgYXJndW1lbnRzIHRoYXQgYXJlIHBhc3NlZFxuICB0byB0aGUgZXZlbnQgaGFuZGxlci4gTW9zdCBjb21tb25seSB0aGlzIHdvdWxkIGJlIHRoZSBgZXZlbnRgIGl0c2VsZi5cblxuICBJZiB5b3Ugd291bGQgbGlrZSB0byBwYXNzIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHRoZSBmdW5jdGlvbiB5b3Ugc2hvdWxkIHVzZVxuICB0aGUgYHt7Zm59fWAgaGVscGVyLlxuXG4gIEZvciBleGFtcGxlLCBpbiBvdXIgZXhhbXBsZSBjYXNlIGFib3ZlIGlmIHlvdSdkIGxpa2UgdG8gcGFzcyBpbiB0aGUgcG9zdCB0aGF0XG4gIHdhcyBiZWluZyBsaWtlZCB3aGVuIHRoZSBidXR0b24gaXMgY2xpY2tlZCB5b3UgY291bGQgZG8gc29tZXRoaW5nIGxpa2U6XG5cbiAgYGBgYXBwL2NvbXBvbmVudHMvbGlrZS1wb3N0Lmhic1xuICA8YnV0dG9uIHt7b24gJ2NsaWNrJyAoZm4gdGhpcy5zYXZlTGlrZSBAcG9zdCl9fT5MaWtlIHRoaXMgcG9zdCE8L2J1dHRvbj5cbiAgYGBgXG5cbiAgSW4gdGhpcyBjYXNlLCB0aGUgYHNhdmVMaWtlYCBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgdHdvIGFyZ3VtZW50czogdGhlIGNsaWNrIGV2ZW50XG4gIGFuZCB0aGUgdmFsdWUgb2YgYEBwb3N0YC5cblxuICAjIyMgRnVuY3Rpb24gQ29udGV4dFxuXG4gIEluIHRoZSBleGFtcGxlIGFib3ZlLCB3ZSB1c2VkIGFuIGFycm93IGZ1bmN0aW9uIHRvIGVuc3VyZSB0aGF0IGBsaWtlUG9zdGAgaXNcbiAgcHJvcGVybHkgYm91bmQgdG8gdGhlIGBpdGVtcy1saXN0YCwgYnV0IGxldCdzIGV4cGxvcmUgd2hhdCBoYXBwZW5zIGlmIHdlXG4gIGxlZnQgb3V0IHRoZSBhcnJvdyBmdW5jdGlvbjpcblxuICBgYGBhcHAvY29tcG9uZW50cy9saWtlLXBvc3QuanNcbiAgaW1wb3J0IENvbXBvbmVudCBmcm9tICdAZ2xpbW1lci9jb21wb25lbnQnO1xuXG4gIGV4cG9ydCBkZWZhdWx0IGNsYXNzIExpa2VQb3N0Q29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzYXZlTGlrZSgpIHtcbiAgICAgIC8vIC4uLnNuaXAuLi5cbiAgICB9XG4gIH1cbiAgYGBgXG5cbiAgSW4gdGhpcyBleGFtcGxlLCB3aGVuIHRoZSBidXR0b24gaXMgY2xpY2tlZCBgc2F2ZUxpa2VgIHdpbGwgYmUgaW52b2tlZCxcbiAgaXQgd2lsbCAqKm5vdCoqIGhhdmUgYWNjZXNzIHRvIHRoZSBjb21wb25lbnQgaW5zdGFuY2UuIEluIG90aGVyXG4gIHdvcmRzLCBpdCB3aWxsIGhhdmUgbm8gYHRoaXNgIGNvbnRleHQsIHNvIHBsZWFzZSBtYWtlIHN1cmUgeW91ciBmdW5jdGlvbnNcbiAgYXJlIGJvdW5kICh2aWEgYW4gYXJyb3cgZnVuY3Rpb24gb3Igb3RoZXIgbWVhbnMpIGJlZm9yZSBwYXNzaW5nIGludG8gYG9uYCFcblxuICBAbWV0aG9kIG9uXG4gIEBwdWJsaWNcbiovXG5jbGFzcyBPbk1vZGlmaWVyTWFuYWdlciBpbXBsZW1lbnRzIEludGVybmFsTW9kaWZpZXJNYW5hZ2VyPE9uTW9kaWZpZXJTdGF0ZSB8IG51bGwsIG9iamVjdD4ge1xuICBwdWJsaWMgU1VQUE9SVFNfRVZFTlRfT1BUSU9OUzogYm9vbGVhbiA9IFNVUFBPUlRTX0VWRU5UX09QVElPTlM7XG5cbiAgZ2V0RGVidWdOYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdvbic7XG4gIH1cblxuICBnZXQgY291bnRlcnMoKTogeyBhZGRzOiBudW1iZXI7IHJlbW92ZXM6IG51bWJlciB9IHtcbiAgICByZXR1cm4geyBhZGRzLCByZW1vdmVzIH07XG4gIH1cblxuICBjcmVhdGUoXG4gICAgX293bmVyOiBPd25lcixcbiAgICBlbGVtZW50OiBTaW1wbGVFbGVtZW50IHwgRWxlbWVudCxcbiAgICBfc3RhdGU6IG9iamVjdCxcbiAgICBhcmdzOiBDYXB0dXJlZEFyZ3VtZW50c1xuICApOiBPbk1vZGlmaWVyU3RhdGUgfCBudWxsIHtcbiAgICByZXR1cm4gbmV3IE9uTW9kaWZpZXJTdGF0ZShlbGVtZW50IGFzIEVsZW1lbnQsIGFyZ3MpO1xuICB9XG5cbiAgZ2V0VGFnKHN0YXRlOiBPbk1vZGlmaWVyU3RhdGUgfCBudWxsKTogVXBkYXRhYmxlVGFnIHwgbnVsbCB7XG4gICAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdGUudGFnO1xuICB9XG5cbiAgaW5zdGFsbChzdGF0ZTogT25Nb2RpZmllclN0YXRlIHwgbnVsbCk6IHZvaWQge1xuICAgIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN0YXRlLnVwZGF0ZUZyb21BcmdzKCk7XG5cbiAgICBsZXQgeyBlbGVtZW50LCBldmVudE5hbWUsIGNhbGxiYWNrLCBvcHRpb25zIH0gPSBzdGF0ZTtcblxuICAgIGFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZXZlbnROYW1lLCBjYWxsYmFjaywgb3B0aW9ucyk7XG5cbiAgICByZWdpc3RlckRlc3RydWN0b3Ioc3RhdGUsICgpID0+IHJlbW92ZUV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZXZlbnROYW1lLCBjYWxsYmFjaywgb3B0aW9ucykpO1xuXG4gICAgc3RhdGUuc2hvdWxkVXBkYXRlID0gZmFsc2U7XG4gIH1cblxuICB1cGRhdGUoc3RhdGU6IE9uTW9kaWZpZXJTdGF0ZSB8IG51bGwpOiB2b2lkIHtcbiAgICBpZiAoc3RhdGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzdGFzaCBwcmlvciBzdGF0ZSBmb3IgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lclxuICAgIGxldCB7IGVsZW1lbnQsIGV2ZW50TmFtZSwgY2FsbGJhY2ssIG9wdGlvbnMgfSA9IHN0YXRlO1xuXG4gICAgc3RhdGUudXBkYXRlRnJvbUFyZ3MoKTtcblxuICAgIGlmICghc3RhdGUuc2hvdWxkVXBkYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gdXNlIHByaW9yIHN0YXRlIHZhbHVlcyBmb3IgcmVtb3ZhbFxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZXZlbnROYW1lLCBjYWxsYmFjaywgb3B0aW9ucyk7XG5cbiAgICAvLyByZWFkIHVwZGF0ZWQgdmFsdWVzIGZyb20gdGhlIHN0YXRlIG9iamVjdFxuICAgIGFkZEV2ZW50TGlzdGVuZXIoc3RhdGUuZWxlbWVudCwgc3RhdGUuZXZlbnROYW1lLCBzdGF0ZS5jYWxsYmFjaywgc3RhdGUub3B0aW9ucyk7XG5cbiAgICBzdGF0ZS5zaG91bGRVcGRhdGUgPSBmYWxzZTtcbiAgfVxuXG4gIGdldERlc3Ryb3lhYmxlKHN0YXRlOiBPbk1vZGlmaWVyU3RhdGUgfCBudWxsKTogT25Nb2RpZmllclN0YXRlIHwgbnVsbCB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNldEludGVybmFsTW9kaWZpZXJNYW5hZ2VyKG5ldyBPbk1vZGlmaWVyTWFuYWdlcigpLCB7fSk7XG4iXSwibmFtZXMiOlsiYXNzaWduIiwiVU5ERUZJTkVEX1JFRkVSRU5DRSIsInN5bWJvbCIsIkRFQlVHIiwid2FybklmU3R5bGVOb3RUcnVzdGVkIiwiU3RhY2siLCJyZWdpc3RlckRlc3RydWN0b3IiLCJkZXN0cm95IiwiZmlsbE51bGxzIiwidm0iLCIkcGMiLCJjcmVhdGVDb21wdXRlUmVmIiwidmFsdWVGb3JSZWYiLCJBUkdTIiwiX1dlYWtTZXQiLCJpc09iamVjdCIsIiRzcCIsImVtcHR5QXJyYXkiLCJFTVBUWV9TVFJJTkdfQVJSQVkiLCJjcmVhdGVEZWJ1Z0FsaWFzUmVmIiwiZGljdCIsIkNPTlNUQU5UX1RBRyIsImRlY29kZUhhbmRsZSIsIiR2MCIsImFzc29jaWF0ZURlc3Ryb3lhYmxlQ2hpbGQiLCJfaGFzRGVzdHJveWFibGVDaGlsZHJlbiIsImRlYnVnVG9TdHJpbmciLCJjaGlsZFJlZkZvciIsIlRSVUVfUkVGRVJFTkNFIiwiRkFMU0VfUkVGRVJFTkNFIiwidG9Cb29sIiwiY3JlYXRlQ29uc3RSZWYiLCJpc0hhbmRsZSIsImRlY29kZUltbWVkaWF0ZSIsIk5VTExfUkVGRVJFTkNFIiwiY3JlYXRlUHJpbWl0aXZlUmVmIiwicmVmZXJlbmNlIiwiaXNDb25zdFJlZiIsIklOSVRJQUwiLCJ2YWxpZGF0ZVRhZyIsImNvbnN1bWVUYWciLCJ2YWx1ZUZvclRhZyIsImJlZ2luVHJhY2tGcmFtZSIsImVuZFRyYWNrRnJhbWUiLCIkdDAiLCJDVVJSRU5UX1RBRyIsImRlc3Ryb3lhYmxlIiwiJHQxIiwibWFuYWdlciIsIm1hbmFnZXJIYXNDYXBhYmlsaXR5IiwidW53cmFwVGVtcGxhdGUiLCJoYXNJbnRlcm5hbENvbXBvbmVudE1hbmFnZXIiLCJoYXNJbnRlcm5hbEhlbHBlck1hbmFnZXIiLCJjcmVhdGVJdGVyYXRvclJlZiIsInNldEludGVybmFsQ29tcG9uZW50TWFuYWdlciIsImNsZWFyRWxlbWVudCIsInNob3VsZEFwcGx5Rml4IiwidHJhY2siLCJ1cGRhdGVUYWciLCJfYSIsIkRlYnVnUmVuZGVyVHJlZSIsIlJ1bnRpbWVQcm9ncmFtSW1wbCIsIiRyYSIsIiRmcCIsInJ1bkluVHJhY2tpbmdUcmFuc2FjdGlvbiIsInJlc2V0VHJhY2tpbmciLCJkZXN0cm95Q2hpbGRyZW4iLCJ1cGRhdGVSZWYiLCJtb3ZlQm91bmRzIiwiYXNzZXJ0R2xvYmFsQ29udGV4dFdhc1NldCIsImlzTG93TGV2ZWxSZWdpc3RlciIsIiRzMCIsIiRzMSIsInVud3JhcEhhbmRsZSIsImNyZWF0ZUl0ZXJhdG9ySXRlbVJlZiIsImlzRW1wdHkiLCJnZXRWYWx1ZSIsImNyZWF0ZUNhY2hlIiwib3duZXIiLCJnZXRPd25lciIsImdldEludGVybmFsSGVscGVyTWFuYWdlciIsImhhc1ZhbHVlIiwiaXNEZXN0cm95aW5nIiwiaXNEZXN0cm95ZWQiLCJoYXNEZXN0cm95YWJsZSIsInNldEludGVybmFsSGVscGVyTWFuYWdlciIsImJ1aWxkVW50b3VjaGFibGVUaGlzIiwicmVpZnlQb3NpdGlvbmFsIiwiaXNJbnZva2FibGVSZWYiLCJkZXByZWNhdGUiLCJyZWlmeU5hbWVkIiwiSEFTX05BVElWRV9QUk9YWSIsImlzRGljdCIsImdldFBhdGgiLCJzZXRQYXRoIiwiY3JlYXRlVXBkYXRhYmxlVGFnIiwic2V0SW50ZXJuYWxNb2RpZmllck1hbmFnZXIiXSwibWFwcGluZ3MiOiI7O01BYU0sZ0JBQU47RUFHRSw0QkFBQSxNQUFBLEVBQW9DO0VBQ2xDLFFBQUEsTUFBQSxFQUFZO0VBQ1YsV0FBQSxNQUFBLEdBQWNBLFdBQU0sQ0FBQSxFQUFBLEVBQXBCLE1BQW9CLENBQXBCO0VBREYsS0FBQSxNQUVPO0VBQ0wsV0FBQSxN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
