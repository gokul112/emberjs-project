{"version":3,"file":"index.js","sources":["../src/legacy-network-handler/legacy-data-fetch.js","../src/legacy-network-handler/legacy-network-handler.ts"],"sourcesContent":["import { assert } from '@ember/debug';\n\nimport { DEBUG } from '@ember-data/env';\n\nimport { iterateData, payloadIsNotBlank } from './legacy-data-utils';\nimport { normalizeResponseHelper } from './serializer-response';\n\nexport function _findHasMany(adapter, store, identifier, link, relationship, options) {\n  let promise = Promise.resolve().then(() => {\n    const snapshot = store._fetchManager.createSnapshot(identifier, options);\n    let useLink = !link || typeof link === 'string';\n    let relatedLink = useLink ? link : link.href;\n    return adapter.findHasMany(store, snapshot, relatedLink, relationship);\n  });\n\n  promise = promise.then(\n    (adapterPayload) => {\n      assert(\n        `You made a 'findHasMany' request for a ${identifier.type}'s '${relationship.key}' relationship, using link '${link}' , but the adapter's response did not have any data`,\n        payloadIsNotBlank(adapterPayload)\n      );\n      const modelClass = store.modelFor(relationship.type);\n\n      let serializer = store.serializerFor(relationship.type);\n      let payload = normalizeResponseHelper(serializer, store, modelClass, adapterPayload, null, 'findHasMany');\n\n      assert(\n        `fetched the hasMany relationship '${relationship.name}' for ${identifier.type}:${identifier.id} with link '${link}', but no data member is present in the response. If no data exists, the response should set { data: [] }`,\n        'data' in payload && Array.isArray(payload.data)\n      );\n\n      payload = syncRelationshipDataFromLink(store, payload, identifier, relationship);\n      return store._push(payload, true);\n    },\n    null,\n    `DS: Extract payload of '${identifier.type}' : hasMany '${relationship.type}'`\n  );\n\n  return promise;\n}\n\nexport function _findBelongsTo(store, identifier, link, relationship, options) {\n  let promise = Promise.resolve().then(() => {\n    let adapter = store.adapterFor(identifier.type);\n    assert(`You tried to load a belongsTo relationship but you have no adapter (for ${identifier.type})`, adapter);\n    assert(\n      `You tried to load a belongsTo relationship from a specified 'link' in the original payload but your adapter does not implement 'findBelongsTo'`,\n      typeof adapter.findBelongsTo === 'function'\n    );\n    let snapshot = store._fetchManager.createSnapshot(identifier, options);\n    let useLink = !link || typeof link === 'string';\n    let relatedLink = useLink ? link : link.href;\n    return adapter.findBelongsTo(store, snapshot, relatedLink, relationship);\n  });\n\n  promise = promise.then(\n    (adapterPayload) => {\n      let modelClass = store.modelFor(relationship.type);\n      let serializer = store.serializerFor(relationship.type);\n      let payload = normalizeResponseHelper(serializer, store, modelClass, adapterPayload, null, 'findBelongsTo');\n\n      assert(\n        `fetched the belongsTo relationship '${relationship.name}' for ${identifier.type}:${identifier.id} with link '${link}', but no data member is present in the response. If no data exists, the response should set { data: null }`,\n        'data' in payload &&\n          (payload.data === null || (typeof payload.data === 'object' && !Array.isArray(payload.data)))\n      );\n\n      if (!payload.data && !payload.links && !payload.meta) {\n        return null;\n      }\n\n      payload = syncRelationshipDataFromLink(store, payload, identifier, relationship);\n\n      return store._push(payload, true);\n    },\n    null,\n    `DS: Extract payload of ${identifier.type} : ${relationship.type}`\n  );\n\n  return promise;\n}\n\n// sync\n// iterate over records in payload.data\n// for each record\n//   assert that record.relationships[inverse] is either undefined (so we can fix it)\n//     or provide a data: {id, type} that matches the record that requested it\n//   return the relationship data for the parent\nfunction syncRelationshipDataFromLink(store, payload, parentIdentifier, relationship) {\n  // ensure the right hand side (incoming payload) points to the parent record that\n  // requested this relationship\n  let relationshipData = payload.data\n    ? iterateData(payload.data, (data, index) => {\n        const { id, type } = data;\n        ensureRelationshipIsSetToParent(data, parentIdentifier, store, relationship, index);\n        return { id, type };\n      })\n    : null;\n\n  const relatedDataHash = {};\n\n  if ('meta' in payload) {\n    relatedDataHash.meta = payload.meta;\n  }\n  if ('links' in payload) {\n    relatedDataHash.links = payload.links;\n  }\n  if ('data' in payload) {\n    relatedDataHash.data = relationshipData;\n  }\n\n  // now, push the left hand side (the parent record) to ensure things are in sync, since\n  // the payload will be pushed with store._push\n  const parentPayload = {\n    id: parentIdentifier.id,\n    type: parentIdentifier.type,\n    relationships: {\n      [relationship.key]: relatedDataHash,\n    },\n  };\n\n  if (!Array.isArray(payload.included)) {\n    payload.included = [];\n  }\n  payload.included.push(parentPayload);\n\n  return payload;\n}\n\nfunction ensureRelationshipIsSetToParent(payload, parentIdentifier, store, parentRelationship, index) {\n  let { id, type } = payload;\n\n  if (!payload.relationships) {\n    payload.relationships = {};\n  }\n  let { relationships } = payload;\n\n  let inverse = getInverse(store, parentIdentifier, parentRelationship, type);\n  if (inverse) {\n    let { inverseKey, kind } = inverse;\n\n    let relationshipData = relationships[inverseKey] && relationships[inverseKey].data;\n\n    if (DEBUG) {\n      if (\n        typeof relationshipData !== 'undefined' &&\n        !relationshipDataPointsToParent(relationshipData, parentIdentifier)\n      ) {\n        let inspect = function inspect(thing) {\n          return `'${JSON.stringify(thing)}'`;\n        };\n        let quotedType = inspect(type);\n        let quotedInverse = inspect(inverseKey);\n        let expected = inspect({\n          id: parentIdentifier.id,\n          type: parentIdentifier.type,\n        });\n        let expectedModel = `${parentIdentifier.type}:${parentIdentifier.id}`;\n        let got = inspect(relationshipData);\n        let prefix = typeof index === 'number' ? `data[${index}]` : `data`;\n        let path = `${prefix}.relationships.${inverseKey}.data`;\n        let other = relationshipData ? `<${relationshipData.type}:${relationshipData.id}>` : null;\n        let relationshipFetched = `${expectedModel}.${parentRelationship.kind}(\"${parentRelationship.name}\")`;\n        let includedRecord = `<${type}:${id}>`;\n        let message = [\n          `Encountered mismatched relationship: Ember Data expected ${path} in the payload from ${relationshipFetched} to include ${expected} but got ${got} instead.\\n`,\n          `The ${includedRecord} record loaded at ${prefix} in the payload specified ${other} as its ${quotedInverse}, but should have specified ${expectedModel} (the record the relationship is being loaded from) as its ${quotedInverse} instead.`,\n          `This could mean that the response for ${relationshipFetched} may have accidentally returned ${quotedType} records that aren't related to ${expectedModel} and could be related to a different ${parentIdentifier.type} record instead.`,\n          `Ember Data has corrected the ${includedRecord} record's ${quotedInverse} relationship to ${expectedModel} so that ${relationshipFetched} will include ${includedRecord}.`,\n          `Please update the response from the server or change your serializer to either ensure that the response for only includes ${quotedType} records that specify ${expectedModel} as their ${quotedInverse}, or omit the ${quotedInverse} relationship from the response.`,\n        ].join('\\n');\n\n        assert(message);\n      }\n    }\n\n    if (kind !== 'hasMany' || typeof relationshipData !== 'undefined') {\n      relationships[inverseKey] = relationships[inverseKey] || {};\n      relationships[inverseKey].data = fixRelationshipData(relationshipData, kind, parentIdentifier);\n    }\n  }\n}\n\nfunction inverseForRelationship(store, identifier, key) {\n  const definition = store.getSchemaDefinitionService().relationshipsDefinitionFor(identifier)[key];\n  if (!definition) {\n    return null;\n  }\n\n  assert(\n    `Expected the relationship defintion to specify the inverse type or null.`,\n    definition.options?.inverse === null ||\n      (typeof definition.options?.inverse === 'string' && definition.options.inverse.length > 0)\n  );\n  return definition.options.inverse;\n}\n\nfunction getInverse(store, parentIdentifier, parentRelationship, type) {\n  let { name: lhs_relationshipName } = parentRelationship;\n  let { type: parentType } = parentIdentifier;\n  let inverseKey = inverseForRelationship(store, { type: parentType }, lhs_relationshipName);\n\n  if (inverseKey) {\n    const definition = store.getSchemaDefinitionService().relationshipsDefinitionFor({ type });\n    let { kind } = definition[inverseKey];\n    return {\n      inverseKey,\n      kind,\n    };\n  }\n}\n\nfunction relationshipDataPointsToParent(relationshipData, identifier) {\n  if (relationshipData === null) {\n    return false;\n  }\n\n  if (Array.isArray(relationshipData)) {\n    if (relationshipData.length === 0) {\n      return false;\n    }\n    for (let i = 0; i < relationshipData.length; i++) {\n      let entry = relationshipData[i];\n      if (validateRelationshipEntry(entry, identifier)) {\n        return true;\n      }\n    }\n  } else {\n    return validateRelationshipEntry(relationshipData, identifier);\n  }\n\n  return false;\n}\n\nfunction fixRelationshipData(relationshipData, relationshipKind, { id, type }) {\n  let parentRelationshipData = {\n    id,\n    type,\n  };\n\n  let payload;\n\n  if (relationshipKind === 'hasMany') {\n    payload = relationshipData || [];\n    if (relationshipData) {\n      // these arrays could be massive so this is better than filter\n      // Note: this is potentially problematic if type/id are not in the\n      // same state of normalization.\n      let found = relationshipData.find((v) => {\n        return v.type === parentRelationshipData.type && v.id === parentRelationshipData.id;\n      });\n      if (!found) {\n        payload.push(parentRelationshipData);\n      }\n    } else {\n      payload.push(parentRelationshipData);\n    }\n  } else {\n    payload = relationshipData || {};\n    Object.assign(payload, parentRelationshipData);\n  }\n\n  return payload;\n}\n\nfunction validateRelationshipEntry({ id }, { id: parentModelID }) {\n  return id && id.toString() === parentModelID;\n}\n","import { assert } from '@ember/debug';\n\nimport { importSync } from '@embroider/macros';\n\nimport { LOG_PAYLOADS } from '@ember-data/debugging';\nimport { DEBUG, TESTING } from '@ember-data/env';\nimport type { Handler, NextFn } from '@ember-data/request/-private/types';\nimport type Store from '@ember-data/store';\nimport type { StoreRequestContext, StoreRequestInfo } from '@ember-data/store/-private/cache-handler';\nimport type { Collection } from '@ember-data/store/-private/record-arrays/identifier-array';\nimport { SingleResourceDataDocument } from '@ember-data/types/cache/document';\nimport type { ModelSchema } from '@ember-data/types/q/ds-model';\nimport type {\n  CollectionResourceDocument,\n  JsonApiDocument,\n  Links,\n  PaginationLinks,\n  SingleResourceDocument,\n} from '@ember-data/types/q/ember-data-json-api';\nimport type { StableExistingRecordIdentifier, StableRecordIdentifier } from '@ember-data/types/q/identifier';\nimport type { MinimumAdapterInterface } from '@ember-data/types/q/minimum-adapter-interface';\nimport type { MinimumSerializerInterface } from '@ember-data/types/q/minimum-serializer-interface';\nimport type { JsonApiError } from '@ember-data/types/q/record-data-json-api';\nimport type { RelationshipSchema } from '@ember-data/types/q/record-data-schemas';\n\nimport FetchManager, { SaveOp } from './fetch-manager';\nimport { assertIdentifierHasId } from './identifier-has-id';\nimport { _findBelongsTo, _findHasMany } from './legacy-data-fetch';\nimport { payloadIsNotBlank } from './legacy-data-utils';\nimport { normalizeResponseHelper } from './serializer-response';\nimport type Snapshot from './snapshot';\nimport SnapshotRecordArray from './snapshot-record-array';\n\ntype AdapterErrors = Error & { errors?: unknown[]; isAdapterError?: true; code?: string };\ntype SerializerWithParseErrors = MinimumSerializerInterface & {\n  extractErrors?(store: Store, modelClass: ModelSchema, error: AdapterErrors, recordId: string | null): unknown;\n};\n\nconst PotentialLegacyOperations = new Set([\n  'findRecord',\n  'findAll',\n  'query',\n  'queryRecord',\n  'findBelongsTo',\n  'findHasMany',\n  'updateRecord',\n  'createRecord',\n  'deleteRecord',\n]);\n\nexport const LegacyNetworkHandler: Handler = {\n  request<T>(context: StoreRequestContext, next: NextFn<T>): Promise<T> {\n    // if we are not a legacy request, move on\n    if (context.request.url || !context.request.op || !PotentialLegacyOperations.has(context.request.op)) {\n      return next(context.request) as unknown as Promise<T>;\n    }\n\n    const { store } = context.request;\n    if (!store._fetchManager) {\n      store._fetchManager = new FetchManager(store);\n    }\n\n    switch (context.request.op) {\n      case 'findRecord':\n        return findRecord(context);\n      case 'findAll':\n        return findAll(context);\n      case 'query':\n        return query(context);\n      case 'queryRecord':\n        return queryRecord(context);\n      case 'findBelongsTo':\n        return findBelongsTo(context);\n      case 'findHasMany':\n        return findHasMany(context);\n      case 'updateRecord':\n        return saveRecord(context);\n      case 'createRecord':\n        return saveRecord(context);\n      case 'deleteRecord':\n        return saveRecord(context);\n      default:\n        return next(context.request) as unknown as Promise<T>;\n    }\n  },\n};\n\nfunction findBelongsTo<T>(context: StoreRequestContext): Promise<T> {\n  const { store, data, records: identifiers } = context.request;\n  const { options, record, links, useLink, field } = data as {\n    record: StableRecordIdentifier;\n    options: Record<string, unknown>;\n    links?: Links;\n    useLink: boolean;\n    field: RelationshipSchema;\n  };\n  const identifier = identifiers?.[0];\n\n  // short circuit if we are already loading\n  let pendingRequest =\n    identifier && store._fetchManager.getPendingFetch(identifier as StableExistingRecordIdentifier, options);\n  if (pendingRequest) {\n    return pendingRequest as Promise<T>;\n  }\n\n  if (useLink) {\n    return _findBelongsTo(store, record, links!.related, field, options) as Promise<T>;\n  }\n\n  assert(`Expected an identifier`, Array.isArray(identifiers) && identifiers.length === 1);\n\n  const manager = store._fetchManager;\n  assertIdentifierHasId(identifier!);\n\n  return options.reload\n    ? (manager.scheduleFetch(identifier, options, context.request) as Promise<T>)\n    : (manager.fetchDataIfNeededForIdentifier(identifier, options, context.request) as Promise<T>);\n}\n\nfunction findHasMany<T>(context: StoreRequestContext): Promise<T> {\n  const { store, data, records: identifiers } = context.request;\n  const { options, record, links, useLink, field } = data as {\n    record: StableRecordIdentifier;\n    options: Record<string, unknown>;\n    links?: PaginationLinks | Links;\n    useLink: boolean;\n    field: RelationshipSchema;\n  };\n\n  // link case\n  if (useLink) {\n    const adapter = store.adapterFor(record.type);\n    /*\n    If a relationship was originally populated by the adapter as a link\n    (as opposed to a list of IDs), this method is called when the\n    relationship is fetched.\n\n    The link (which is usually a URL) is passed through unchanged, so the\n    adapter can make whatever request it wants.\n\n    The usual use-case is for the server to register a URL as a link, and\n    then use that URL in the future to make a request for the relationship.\n  */\n    assert(`You tried to load a hasMany relationship but you have no adapter (for ${record.type})`, adapter);\n    assert(\n      `You tried to load a hasMany relationship from a specified 'link' in the original payload but your adapter does not implement 'findHasMany'`,\n      typeof adapter.findHasMany === 'function'\n    );\n\n    return _findHasMany(adapter, store, record, links!.related, field, options) as Promise<T>;\n  }\n\n  // identifiers case\n\n  const fetches = new Array<globalThis.Promise<StableRecordIdentifier>>(identifiers!.length);\n  const manager = store._fetchManager;\n\n  for (let i = 0; i < identifiers!.length; i++) {\n    let identifier = identifiers![i];\n    // TODO we probably can be lenient here and return from cache for the isNew case\n    assertIdentifierHasId(identifier);\n    fetches[i] = options.reload\n      ? manager.scheduleFetch(identifier, options, context.request)\n      : manager.fetchDataIfNeededForIdentifier(identifier, options, context.request);\n  }\n\n  return Promise.all(fetches) as Promise<T>;\n}\n\nfunction saveRecord<T>(context: StoreRequestContext): Promise<T> {\n  const { store, data, op: operation } = context.request;\n  const { options, record: identifier } = data as { record: StableRecordIdentifier; options: Record<string, unknown> };\n\n  const saveOptions = Object.assign(\n    { [SaveOp]: operation as 'updateRecord' | 'deleteRecord' | 'createRecord' },\n    options\n  );\n  const fetchManagerPromise = store._fetchManager.scheduleSave(identifier, saveOptions);\n\n  return fetchManagerPromise\n    .then((payload) => {\n      if (LOG_PAYLOADS) {\n        try {\n          let payloadCopy: unknown = payload ? JSON.parse(JSON.stringify(payload)) : payload;\n          // eslint-disable-next-line no-console\n          console.log(`EmberData | Payload - ${operation!}`, payloadCopy);\n        } catch (e) {\n          // eslint-disable-next-line no-console\n          console.log(`EmberData | Payload - ${operation!}`, payload);\n        }\n      }\n      let result: SingleResourceDataDocument;\n      /*\n      // TODO @runspired re-evaluate the below claim now that\n      // the save request pipeline is more streamlined.\n\n      Note to future spelunkers hoping to optimize.\n      We rely on this `run` to create a run loop if needed\n      that `store._push` and `store.saveRecord` will both share.\n\n      We use `join` because it is often the case that we\n      have an outer run loop available still from the first\n      call to `store._push`;\n     */\n      store._join(() => {\n        result = store.cache.didCommit(identifier, { request: context.request, content: payload });\n      });\n      return store.peekRecord(result!.data!);\n    })\n    .catch((e: unknown) => {\n      let err = e;\n      if (!e) {\n        err = new Error(`Unknown Error Occurred During Request`);\n      } else if (typeof e === 'string') {\n        err = new Error(e);\n      }\n      adapterDidInvalidate(store, identifier, err as Error);\n      throw err;\n    }) as Promise<T>;\n}\n\nfunction adapterDidInvalidate(\n  store: Store,\n  identifier: StableRecordIdentifier,\n  error: Error & { errors?: JsonApiError[]; isAdapterError?: true; code?: string }\n) {\n  if (error && error.isAdapterError === true && error.code === 'InvalidError') {\n    let serializer = store.serializerFor(identifier.type) as SerializerWithParseErrors;\n\n    // TODO @deprecate extractErrors being called\n    // TODO remove extractErrors from the default serializers.\n    if (serializer && typeof serializer.extractErrors === 'function') {\n      let errorsHash = serializer.extractErrors(store, store.modelFor(identifier.type), error, identifier.id) as Record<\n        string,\n        string | string[]\n      >;\n      error.errors = errorsHashToArray(errorsHash);\n    }\n  }\n  const cache = store.cache;\n\n  if (error.errors) {\n    assert(\n      `Expected the cache in use by resource ${String(\n        identifier\n      )} to have a getErrors(identifier) method for retreiving errors.`,\n      typeof cache.getErrors === 'function'\n    );\n\n    let jsonApiErrors: JsonApiError[] = error.errors;\n    if (jsonApiErrors.length === 0) {\n      jsonApiErrors = [{ title: 'Invalid Error', detail: '', source: { pointer: '/data' } }];\n    }\n    cache.commitWasRejected(identifier, jsonApiErrors);\n  } else {\n    cache.commitWasRejected(identifier);\n  }\n}\n\nfunction makeArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\nconst PRIMARY_ATTRIBUTE_KEY = 'base';\nfunction errorsHashToArray(errors: Record<string, string | string[]>): JsonApiError[] {\n  const out: JsonApiError[] = [];\n\n  if (errors) {\n    Object.keys(errors).forEach((key) => {\n      let messages = makeArray(errors[key]);\n      for (let i = 0; i < messages.length; i++) {\n        let title = 'Invalid Attribute';\n        let pointer = `/data/attributes/${key}`;\n        if (key === PRIMARY_ATTRIBUTE_KEY) {\n          title = 'Invalid Document';\n          pointer = `/data`;\n        }\n        out.push({\n          title: title,\n          detail: messages[i],\n          source: {\n            pointer: pointer,\n          },\n        });\n      }\n    });\n  }\n\n  return out;\n}\n\nfunction findRecord<T>(context: StoreRequestContext): Promise<T> {\n  const { store, data } = context.request;\n  const { record: identifier, options } = data as {\n    record: StableExistingRecordIdentifier;\n    options: { reload?: boolean; backgroundReload?: boolean };\n  };\n  let promise: Promise<StableRecordIdentifier>;\n\n  // if not loaded start loading\n  if (!store._instanceCache.recordIsLoaded(identifier)) {\n    promise = store._fetchManager.fetchDataIfNeededForIdentifier(identifier, options, context.request);\n\n    // Refetch if the reload option is passed\n  } else if (options.reload) {\n    assertIdentifierHasId(identifier);\n\n    promise = store._fetchManager.scheduleFetch(identifier, options, context.request);\n  } else {\n    let snapshot: Snapshot | null = null;\n    let adapter = store.adapterFor(identifier.type);\n\n    // Refetch the record if the adapter thinks the record is stale\n    if (\n      typeof options.reload === 'undefined' &&\n      adapter.shouldReloadRecord &&\n      adapter.shouldReloadRecord(store, (snapshot = store._fetchManager.createSnapshot(identifier, options)))\n    ) {\n      assertIdentifierHasId(identifier);\n      if (DEBUG) {\n        promise = store._fetchManager.scheduleFetch(\n          identifier,\n          Object.assign({}, options, { reload: true }),\n          context.request\n        );\n      } else {\n        options.reload = true;\n        promise = store._fetchManager.scheduleFetch(identifier, options, context.request);\n      }\n    } else {\n      // Trigger the background refetch if backgroundReload option is passed\n      if (\n        options.backgroundReload !== false &&\n        (options.backgroundReload ||\n          !adapter.shouldBackgroundReloadRecord ||\n          adapter.shouldBackgroundReloadRecord(\n            store,\n            (snapshot = snapshot || store._fetchManager.createSnapshot(identifier, options))\n          ))\n      ) {\n        assertIdentifierHasId(identifier);\n\n        if (DEBUG) {\n          void store._fetchManager.scheduleFetch(\n            identifier,\n            Object.assign({}, options, { backgroundReload: true }),\n            context.request\n          );\n        } else {\n          options.backgroundReload = true;\n          void store._fetchManager.scheduleFetch(identifier, options, context.request);\n        }\n      }\n\n      // Return the cached record\n      promise = Promise.resolve(identifier) as Promise<StableRecordIdentifier>;\n    }\n  }\n\n  return promise.then((i: StableRecordIdentifier) => store.peekRecord(i)) as Promise<T>;\n}\n\nfunction findAll<T>(context: StoreRequestContext): Promise<T> {\n  const { store, data } = context.request;\n  const { type, options } = data as {\n    type: string;\n    options: { reload?: boolean; backgroundReload?: boolean };\n  };\n  const adapter = store.adapterFor(type);\n\n  assert(`You tried to load all records but you have no adapter (for ${type})`, adapter);\n  assert(\n    `You tried to load all records but your adapter does not implement 'findAll'`,\n    typeof adapter.findAll === 'function'\n  );\n\n  // avoid initializing the liveArray just to set `isUpdating`\n  const maybeRecordArray = store.recordArrayManager._live.get(type);\n  const snapshotArray = new SnapshotRecordArray(store, type, options);\n\n  const shouldReload =\n    options.reload ||\n    (options.reload !== false &&\n      ((adapter.shouldReloadAll && adapter.shouldReloadAll(store, snapshotArray)) ||\n        (!adapter.shouldReloadAll && snapshotArray.length === 0)));\n\n  let fetch: Promise<T> | undefined;\n  if (shouldReload) {\n    maybeRecordArray && (maybeRecordArray.isUpdating = true);\n    fetch = _findAll(adapter, store, type, snapshotArray, context.request, true);\n  } else {\n    fetch = Promise.resolve(store.peekAll(type)) as Promise<T>;\n\n    if (\n      options.backgroundReload ||\n      (options.backgroundReload !== false &&\n        (!adapter.shouldBackgroundReloadAll || adapter.shouldBackgroundReloadAll(store, snapshotArray)))\n    ) {\n      maybeRecordArray && (maybeRecordArray.isUpdating = true);\n      void _findAll(adapter, store, type, snapshotArray, context.request, false);\n    }\n  }\n\n  return fetch;\n}\n\nfunction _findAll<T>(\n  adapter: MinimumAdapterInterface,\n  store: Store,\n  type: string,\n  snapshotArray: SnapshotRecordArray,\n  request: StoreRequestInfo,\n  isAsyncFlush: boolean\n): Promise<T> {\n  const schema = store.modelFor(type);\n  let promise: Promise<T> = Promise.resolve().then(() =>\n    adapter.findAll(store, schema, null, snapshotArray)\n  ) as Promise<T>;\n\n  promise = promise.then((adapterPayload: T) => {\n    assert(\n      `You made a 'findAll' request for '${type}' records, but the adapter's response did not have any data`,\n      payloadIsNotBlank(adapterPayload)\n    );\n    const serializer = store.serializerFor(type);\n    const payload = normalizeResponseHelper(serializer, store, schema, adapterPayload, null, 'findAll');\n\n    store._push(payload, isAsyncFlush);\n    snapshotArray._recordArray.isUpdating = false;\n\n    if (LOG_PAYLOADS) {\n      // eslint-disable-next-line no-console\n      console.log(`request: findAll<${type}> background reload complete`);\n    }\n    return snapshotArray._recordArray;\n  }) as Promise<T>;\n\n  if (TESTING) {\n    if (!request.disableTestWaiter) {\n      const { waitForPromise } = importSync('@ember/test-waiters') as {\n        waitForPromise: <PT>(promise: Promise<PT>) => Promise<PT>;\n      };\n      promise = waitForPromise(promise);\n    }\n  }\n\n  return promise;\n}\n\nfunction query<T>(context: StoreRequestContext): Promise<T> {\n  const { store, data } = context.request;\n  let { options } = data as {\n    options: { _recordArray?: Collection; adapterOptions?: Record<string, unknown> };\n  };\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  const { type, query } = data as {\n    type: string;\n    query: Record<string, unknown>;\n    options: { _recordArray?: Collection; adapterOptions?: Record<string, unknown> };\n  };\n  const adapter = store.adapterFor(type);\n\n  assert(`You tried to make a query but you have no adapter (for ${type})`, adapter);\n  assert(`You tried to make a query but your adapter does not implement 'query'`, typeof adapter.query === 'function');\n\n  const recordArray =\n    options._recordArray ||\n    store.recordArrayManager.createArray({\n      type,\n      query,\n    });\n\n  if (DEBUG) {\n    options = Object.assign({}, options);\n    delete options._recordArray;\n  } else {\n    delete options._recordArray;\n  }\n  const schema = store.modelFor(type);\n  let promise = Promise.resolve().then(() => adapter.query(store, schema, query, recordArray, options));\n\n  return promise.then((adapterPayload) => {\n    const serializer = store.serializerFor(type);\n    const payload = normalizeResponseHelper(\n      serializer,\n      store,\n      schema,\n      adapterPayload as Record<string, unknown>,\n      null,\n      'query'\n    );\n    const identifiers = store._push(payload, true);\n\n    assert(\n      'The response to store.query is expected to be an array but it was a single record. Please wrap your response in an array or use `store.queryRecord` to query for a single record.',\n      Array.isArray(identifiers)\n    );\n\n    store.recordArrayManager.populateManagedArray(recordArray, identifiers, payload as CollectionResourceDocument);\n\n    return recordArray;\n  }) as Promise<T>;\n}\n\nfunction assertSingleResourceDocument(payload: JsonApiDocument): asserts payload is SingleResourceDocument {\n  assert(\n    `Expected the primary data returned by the serializer for a 'queryRecord' response to be a single object or null but instead it was an array.`,\n    !Array.isArray(payload.data)\n  );\n}\n\nfunction queryRecord<T>(context: StoreRequestContext): Promise<T> {\n  const { store, data } = context.request;\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  const { type, query, options } = data as { type: string; query: Record<string, unknown>; options: object };\n  const adapter = store.adapterFor(type);\n\n  assert(`You tried to make a query but you have no adapter (for ${type})`, adapter);\n  assert(\n    `You tried to make a query but your adapter does not implement 'queryRecord'`,\n    typeof adapter.queryRecord === 'function'\n  );\n\n  const schema = store.modelFor(type);\n  let promise = Promise.resolve().then(() => adapter.queryRecord(store, schema, query, options)) as Promise<T>;\n\n  return promise.then((adapterPayload: T) => {\n    const serializer = store.serializerFor(type);\n    const payload = normalizeResponseHelper(\n      serializer,\n      store,\n      schema,\n      adapterPayload as Record<string, unknown>,\n      null,\n      'queryRecord'\n    );\n\n    assertSingleResourceDocument(payload);\n\n    const identifier = store._push(payload, true) as StableRecordIdentifier;\n    return identifier ? store.peekRecord(identifier) : null;\n  }) as Promise<T>;\n}\n"],"names":["_findHasMany","adapter","store","identifier","link","relationship","options","promise","Promise","resolve","then","snapshot","_fetchManager","createSnapshot","useLink","relatedLink","href","findHasMany","adapterPayload","assert","type","key","payloadIsNotBlank","modelClass","modelFor","serializer","serializerFor","payload","normalizeResponseHelper","name","id","Array","isArray","data","syncRelationshipDataFromLink","_push","_findBelongsTo","adapterFor","findBelongsTo","links","meta","parentIdentifier","relationshipData","iterateData","index","ensureRelationshipIsSetToParent","relatedDataHash","parentPayload","relationships","included","push","parentRelationship","inverse","getInverse","inverseKey","kind","macroCondition","getOwnConfig","env","DEBUG","relationshipDataPointsToParent","inspect","thing","JSON","stringify","quotedType","quotedInverse","expected","expectedModel","got","prefix","path","other","relationshipFetched","includedRecord","message","join","fixRelationshipData","inverseForRelationship","definition","getSchemaDefinitionService","relationshipsDefinitionFor","length","lhs_relationshipName","parentType","i","entry","validateRelationshipEntry","relationshipKind","parentRelationshipData","found","find","v","Object","assign","parentModelID","toString","PotentialLegacyOperations","Set","LegacyNetworkHandler","request","context","next","url","op","has","FetchManager","findRecord","findAll","query","queryRecord","saveRecord","records","identifiers","record","field","pendingRequest","getPendingFetch","related","manager","assertIdentifierHasId","reload","scheduleFetch","fetchDataIfNeededForIdentifier","fetches","all","operation","saveOptions","SaveOp","fetchManagerPromise","scheduleSave","debug","LOG_PAYLOADS","payloadCopy","parse","console","log","e","result","_join","cache","didCommit","content","peekRecord","catch","err","Error","adapterDidInvalidate","error","isAdapterError","code","extractErrors","errorsHash","errors","errorsHashToArray","String","getErrors","jsonApiErrors","title","detail","source","pointer","commitWasRejected","makeArray","value","PRIMARY_ATTRIBUTE_KEY","out","keys","forEach","messages","_instanceCache","recordIsLoaded","shouldReloadRecord","backgroundReload","shouldBackgroundReloadRecord","maybeRecordArray","recordArrayManager","_live","get","snapshotArray","SnapshotRecordArray","shouldReload","shouldReloadAll","fetch","isUpdating","_findAll","peekAll","shouldBackgroundReloadAll","isAsyncFlush","schema","_recordArray","TESTING","disableTestWaiter","waitForPromise","importSync","recordArray","createArray","populateManagedArray","assertSingleResourceDocument"],"mappings":";;;;AAOO,SAASA,YAAYA,CAACC,OAAO,EAAEC,KAAK,EAAEC,UAAU,EAAEC,IAAI,EAAEC,YAAY,EAAEC,OAAO,EAAE;EACpF,IAAIC,OAAO,GAAGC,OAAO,CAACC,OAAO,EAAE,CAACC,IAAI,CAAC,MAAM;IACzC,MAAMC,QAAQ,GAAGT,KAAK,CAACU,aAAa,CAACC,cAAc,CAACV,UAAU,EAAEG,OAAO,CAAC,CAAA;IACxE,IAAIQ,OAAO,GAAG,CAACV,IAAI,IAAI,OAAOA,IAAI,KAAK,QAAQ,CAAA;IAC/C,IAAIW,WAAW,GAAGD,OAAO,GAAGV,IAAI,GAAGA,IAAI,CAACY,IAAI,CAAA;IAC5C,OAAOf,OAAO,CAACgB,WAAW,CAACf,KAAK,EAAES,QAAQ,EAAEI,WAAW,EAAEV,YAAY,CAAC,CAAA;AACxE,GAAC,CAAC,CAAA;AAEFE,EAAAA,OAAO,GAAGA,OAAO,CAACG,IAAI,CACnBQ,cAAc,IAAK;AAClBC,IAAAA,MAAM,CACH,CAAyChB,uCAAAA,EAAAA,UAAU,CAACiB,IAAK,OAAMf,YAAY,CAACgB,GAAI,CAAA,4BAAA,EAA8BjB,IAAK,CAAqD,oDAAA,CAAA,EACzKkB,iBAAiB,CAACJ,cAAc,CAClC,CAAC,CAAA;IACD,MAAMK,UAAU,GAAGrB,KAAK,CAACsB,QAAQ,CAACnB,YAAY,CAACe,IAAI,CAAC,CAAA;IAEpD,IAAIK,UAAU,GAAGvB,KAAK,CAACwB,aAAa,CAACrB,YAAY,CAACe,IAAI,CAAC,CAAA;AACvD,IAAA,IAAIO,OAAO,GAAGC,uBAAuB,CAACH,UAAU,EAAEvB,KAAK,EAAEqB,UAAU,EAAEL,cAAc,EAAE,IAAI,EAAE,aAAa,CAAC,CAAA;AAEzGC,IAAAA,MAAM,CACH,CAAA,kCAAA,EAAoCd,YAAY,CAACwB,IAAK,CAAA,MAAA,EAAQ1B,UAAU,CAACiB,IAAK,CAAA,CAAA,EAAGjB,UAAU,CAAC2B,EAAG,CAAA,YAAA,EAAc1B,IAAK,CAAA,yGAAA,CAA0G,EAC7N,MAAM,IAAIuB,OAAO,IAAII,KAAK,CAACC,OAAO,CAACL,OAAO,CAACM,IAAI,CACjD,CAAC,CAAA;IAEDN,OAAO,GAAGO,4BAA4B,CAAChC,KAAK,EAAEyB,OAAO,EAAExB,UAAU,EAAEE,YAAY,CAAC,CAAA;AAChF,IAAA,OAAOH,KAAK,CAACiC,KAAK,CAACR,OAAO,EAAE,IAAI,CAAC,CAAA;AACnC,GAAC,EACD,IAAI,EACH,CAAA,wBAAA,EAA0BxB,UAAU,CAACiB,IAAK,CAAA,aAAA,EAAef,YAAY,CAACe,IAAK,CAAA,CAAA,CAC9E,CAAC,CAAA;AAED,EAAA,OAAOb,OAAO,CAAA;AAChB,CAAA;AAEO,SAAS6B,cAAcA,CAAClC,KAAK,EAAEC,UAAU,EAAEC,IAAI,EAAEC,YAAY,EAAEC,OAAO,EAAE;EAC7E,IAAIC,OAAO,GAAGC,OAAO,CAACC,OAAO,EAAE,CAACC,IAAI,CAAC,MAAM;IACzC,IAAIT,OAAO,GAAGC,KAAK,CAACmC,UAAU,CAAClC,UAAU,CAACiB,IAAI,CAAC,CAAA;IAC/CD,MAAM,CAAE,2EAA0EhB,UAAU,CAACiB,IAAK,CAAE,CAAA,CAAA,EAAEnB,OAAO,CAAC,CAAA;IAC9GkB,MAAM,CACH,gJAA+I,EAChJ,OAAOlB,OAAO,CAACqC,aAAa,KAAK,UACnC,CAAC,CAAA;IACD,IAAI3B,QAAQ,GAAGT,KAAK,CAACU,aAAa,CAACC,cAAc,CAACV,UAAU,EAAEG,OAAO,CAAC,CAAA;IACtE,IAAIQ,OAAO,GAAG,CAACV,IAAI,IAAI,OAAOA,IAAI,KAAK,QAAQ,CAAA;IAC/C,IAAIW,WAAW,GAAGD,OAAO,GAAGV,IAAI,GAAGA,IAAI,CAACY,IAAI,CAAA;IAC5C,OAAOf,OAAO,CAACqC,aAAa,CAACpC,KAAK,EAAES,QAAQ,EAAEI,WAAW,EAAEV,YAAY,CAAC,CAAA;AAC1E,GAAC,CAAC,CAAA;AAEFE,EAAAA,OAAO,GAAGA,OAAO,CAACG,IAAI,CACnBQ,cAAc,IAAK;IAClB,IAAIK,UAAU,GAAGrB,KAAK,CAACsB,QAAQ,CAACnB,YAAY,CAACe,IAAI,CAAC,CAAA;IAClD,IAAIK,UAAU,GAAGvB,KAAK,CAACwB,aAAa,CAACrB,YAAY,CAACe,IAAI,CAAC,CAAA;AACvD,IAAA,IAAIO,OAAO,GAAGC,uBAAuB,CAACH,UAAU,EAAEvB,KAAK,EAAEqB,UAAU,EAAEL,cAAc,EAAE,IAAI,EAAE,eAAe,CAAC,CAAA;IAE3GC,MAAM,CACH,uCAAsCd,YAAY,CAACwB,IAAK,CAAQ1B,MAAAA,EAAAA,UAAU,CAACiB,IAAK,CAAA,CAAA,EAAGjB,UAAU,CAAC2B,EAAG,eAAc1B,IAAK,CAAA,2GAAA,CAA4G,EACjO,MAAM,IAAIuB,OAAO,KACdA,OAAO,CAACM,IAAI,KAAK,IAAI,IAAK,OAAON,OAAO,CAACM,IAAI,KAAK,QAAQ,IAAI,CAACF,KAAK,CAACC,OAAO,CAACL,OAAO,CAACM,IAAI,CAAE,CAChG,CAAC,CAAA;AAED,IAAA,IAAI,CAACN,OAAO,CAACM,IAAI,IAAI,CAACN,OAAO,CAACY,KAAK,IAAI,CAACZ,OAAO,CAACa,IAAI,EAAE;AACpD,MAAA,OAAO,IAAI,CAAA;AACb,KAAA;IAEAb,OAAO,GAAGO,4BAA4B,CAAChC,KAAK,EAAEyB,OAAO,EAAExB,UAAU,EAAEE,YAAY,CAAC,CAAA;AAEhF,IAAA,OAAOH,KAAK,CAACiC,KAAK,CAACR,OAAO,EAAE,IAAI,CAAC,CAAA;AACnC,GAAC,EACD,IAAI,EACH,CAAA,uBAAA,EAAyBxB,UAAU,CAACiB,IAAK,CAAA,GAAA,EAAKf,YAAY,CAACe,IAAK,CAAA,CACnE,CAAC,CAAA;AAED,EAAA,OAAOb,OAAO,CAAA;AAChB,CAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS2B,4BAA4BA,CAAChC,KAAK,EAAEyB,OAAO,EAAEc,gBAAgB,EAAEpC,YAAY,EAAE;AACpF;AACA;AACA,EAAA,IAAIqC,gBAAgB,GAAGf,OAAO,CAACM,IAAI,GAC/BU,WAAW,CAAChB,OAAO,CAACM,IAAI,EAAE,CAACA,IAAI,EAAEW,KAAK,KAAK;IACzC,MAAM;MAAEd,EAAE;AAAEV,MAAAA,IAAAA;AAAK,KAAC,GAAGa,IAAI,CAAA;IACzBY,+BAA+B,CAACZ,IAAI,EAAEQ,gBAAgB,EAAEvC,KAAK,EAAEG,YAAY,EAAEuC,KAAK,CAAC,CAAA;IACnF,OAAO;MAAEd,EAAE;AAAEV,MAAAA,IAAAA;KAAM,CAAA;GACpB,CAAC,GACF,IAAI,CAAA;EAER,MAAM0B,eAAe,GAAG,EAAE,CAAA;EAE1B,IAAI,MAAM,IAAInB,OAAO,EAAE;AACrBmB,IAAAA,eAAe,CAACN,IAAI,GAAGb,OAAO,CAACa,IAAI,CAAA;AACrC,GAAA;EACA,IAAI,OAAO,IAAIb,OAAO,EAAE;AACtBmB,IAAAA,eAAe,CAACP,KAAK,GAAGZ,OAAO,CAACY,KAAK,CAAA;AACvC,GAAA;EACA,IAAI,MAAM,IAAIZ,OAAO,EAAE;IACrBmB,eAAe,CAACb,IAAI,GAAGS,gBAAgB,CAAA;AACzC,GAAA;;AAEA;AACA;AACA,EAAA,MAAMK,aAAa,GAAG;IACpBjB,EAAE,EAAEW,gBAAgB,CAACX,EAAE;IACvBV,IAAI,EAAEqB,gBAAgB,CAACrB,IAAI;AAC3B4B,IAAAA,aAAa,EAAE;MACb,CAAC3C,YAAY,CAACgB,GAAG,GAAGyB,eAAAA;AACtB,KAAA;GACD,CAAA;EAED,IAAI,CAACf,KAAK,CAACC,OAAO,CAACL,OAAO,CAACsB,QAAQ,CAAC,EAAE;IACpCtB,OAAO,CAACsB,QAAQ,GAAG,EAAE,CAAA;AACvB,GAAA;AACAtB,EAAAA,OAAO,CAACsB,QAAQ,CAACC,IAAI,CAACH,aAAa,CAAC,CAAA;AAEpC,EAAA,OAAOpB,OAAO,CAAA;AAChB,CAAA;AAEA,SAASkB,+BAA+BA,CAAClB,OAAO,EAAEc,gBAAgB,EAAEvC,KAAK,EAAEiD,kBAAkB,EAAEP,KAAK,EAAE;EACpG,IAAI;IAAEd,EAAE;AAAEV,IAAAA,IAAAA;AAAK,GAAC,GAAGO,OAAO,CAAA;AAE1B,EAAA,IAAI,CAACA,OAAO,CAACqB,aAAa,EAAE;AAC1BrB,IAAAA,OAAO,CAACqB,aAAa,GAAG,EAAE,CAAA;AAC5B,GAAA;EACA,IAAI;AAAEA,IAAAA,aAAAA;AAAc,GAAC,GAAGrB,OAAO,CAAA;EAE/B,IAAIyB,OAAO,GAAGC,UAAU,CAACnD,KAAK,EAAEuC,gBAAgB,EAAEU,kBAAkB,EAAE/B,IAAI,CAAC,CAAA;AAC3E,EAAA,IAAIgC,OAAO,EAAE;IACX,IAAI;MAAEE,UAAU;AAAEC,MAAAA,IAAAA;AAAK,KAAC,GAAGH,OAAO,CAAA;AAElC,IAAA,IAAIV,gBAAgB,GAAGM,aAAa,CAACM,UAAU,CAAC,IAAIN,aAAa,CAACM,UAAU,CAAC,CAACrB,IAAI,CAAA;AAElF,IAAA,IAAAuB,cAAA,CAAAC,YAAA,GAAAC,GAAA,CAAAC,KAAA,CAAW,EAAA;AACT,MAAA,IACE,OAAOjB,gBAAgB,KAAK,WAAW,IACvC,CAACkB,8BAA8B,CAAClB,gBAAgB,EAAED,gBAAgB,CAAC,EACnE;AACA,QAAA,IAAIoB,OAAO,GAAG,SAASA,OAAOA,CAACC,KAAK,EAAE;AACpC,UAAA,OAAQ,IAAGC,IAAI,CAACC,SAAS,CAACF,KAAK,CAAE,CAAE,CAAA,CAAA,CAAA;SACpC,CAAA;AACD,QAAA,IAAIG,UAAU,GAAGJ,OAAO,CAACzC,IAAI,CAAC,CAAA;AAC9B,QAAA,IAAI8C,aAAa,GAAGL,OAAO,CAACP,UAAU,CAAC,CAAA;QACvC,IAAIa,QAAQ,GAAGN,OAAO,CAAC;UACrB/B,EAAE,EAAEW,gBAAgB,CAACX,EAAE;UACvBV,IAAI,EAAEqB,gBAAgB,CAACrB,IAAAA;AACzB,SAAC,CAAC,CAAA;QACF,IAAIgD,aAAa,GAAI,CAAA,EAAE3B,gBAAgB,CAACrB,IAAK,CAAGqB,CAAAA,EAAAA,gBAAgB,CAACX,EAAG,CAAC,CAAA,CAAA;AACrE,QAAA,IAAIuC,GAAG,GAAGR,OAAO,CAACnB,gBAAgB,CAAC,CAAA;QACnC,IAAI4B,MAAM,GAAG,OAAO1B,KAAK,KAAK,QAAQ,GAAI,CAAOA,KAAAA,EAAAA,KAAM,CAAE,CAAA,CAAA,GAAI,CAAK,IAAA,CAAA,CAAA;AAClE,QAAA,IAAI2B,IAAI,GAAI,CAAA,EAAED,MAAO,CAAA,eAAA,EAAiBhB,UAAW,CAAM,KAAA,CAAA,CAAA;AACvD,QAAA,IAAIkB,KAAK,GAAG9B,gBAAgB,GAAI,IAAGA,gBAAgB,CAACtB,IAAK,CAAA,CAAA,EAAGsB,gBAAgB,CAACZ,EAAG,CAAA,CAAA,CAAE,GAAG,IAAI,CAAA;AACzF,QAAA,IAAI2C,mBAAmB,GAAI,CAAEL,EAAAA,aAAc,CAAGjB,CAAAA,EAAAA,kBAAkB,CAACI,IAAK,CAAIJ,EAAAA,EAAAA,kBAAkB,CAACtB,IAAK,CAAG,EAAA,CAAA,CAAA;AACrG,QAAA,IAAI6C,cAAc,GAAI,CAAA,CAAA,EAAGtD,IAAK,CAAA,CAAA,EAAGU,EAAG,CAAE,CAAA,CAAA,CAAA;AACtC,QAAA,IAAI6C,OAAO,GAAG,CACX,CAAA,yDAAA,EAA2DJ,IAAK,CAAA,qBAAA,EAAuBE,mBAAoB,CAAA,YAAA,EAAcN,QAAS,CAAA,SAAA,EAAWE,GAAI,CAAA,WAAA,CAAY,EAC7J,CAAMK,IAAAA,EAAAA,cAAe,CAAoBJ,kBAAAA,EAAAA,MAAO,CAA4BE,0BAAAA,EAAAA,KAAM,CAAUN,QAAAA,EAAAA,aAAc,CAA8BE,4BAAAA,EAAAA,aAAc,CAA6DF,2DAAAA,EAAAA,aAAc,CAAU,SAAA,CAAA,EAC3O,CAAwCO,sCAAAA,EAAAA,mBAAoB,mCAAkCR,UAAW,CAAA,gCAAA,EAAkCG,aAAc,CAAA,qCAAA,EAAuC3B,gBAAgB,CAACrB,IAAK,CAAA,gBAAA,CAAiB,EACvO,CAAA,6BAAA,EAA+BsD,cAAe,CAAA,UAAA,EAAYR,aAAc,CAAA,iBAAA,EAAmBE,aAAc,CAAA,SAAA,EAAWK,mBAAoB,CAAgBC,cAAAA,EAAAA,cAAe,CAAE,CAAA,CAAA,EACzK,CAA4HT,0HAAAA,EAAAA,UAAW,CAAwBG,sBAAAA,EAAAA,aAAc,aAAYF,aAAc,CAAA,cAAA,EAAgBA,aAAc,CAAA,gCAAA,CAAiC,CACxQ,CAACU,IAAI,CAAC,IAAI,CAAC,CAAA;QAEZzD,MAAM,CAACwD,OAAO,CAAC,CAAA;AACjB,OAAA;AACF,KAAA;IAEA,IAAIpB,IAAI,KAAK,SAAS,IAAI,OAAOb,gBAAgB,KAAK,WAAW,EAAE;MACjEM,aAAa,CAACM,UAAU,CAAC,GAAGN,aAAa,CAACM,UAAU,CAAC,IAAI,EAAE,CAAA;AAC3DN,MAAAA,aAAa,CAACM,UAAU,CAAC,CAACrB,IAAI,GAAG4C,mBAAmB,CAACnC,gBAAgB,EAAEa,IAAI,EAAEd,gBAAgB,CAAC,CAAA;AAChG,KAAA;AACF,GAAA;AACF,CAAA;AAEA,SAASqC,sBAAsBA,CAAC5E,KAAK,EAAEC,UAAU,EAAEkB,GAAG,EAAE;AACtD,EAAA,MAAM0D,UAAU,GAAG7E,KAAK,CAAC8E,0BAA0B,EAAE,CAACC,0BAA0B,CAAC9E,UAAU,CAAC,CAACkB,GAAG,CAAC,CAAA;EACjG,IAAI,CAAC0D,UAAU,EAAE;AACf,IAAA,OAAO,IAAI,CAAA;AACb,GAAA;AAEA5D,EAAAA,MAAM,CACH,CAAA,wEAAA,CAAyE,EAC1E4D,UAAU,CAACzE,OAAO,EAAE8C,OAAO,KAAK,IAAI,IACjC,OAAO2B,UAAU,CAACzE,OAAO,EAAE8C,OAAO,KAAK,QAAQ,IAAI2B,UAAU,CAACzE,OAAO,CAAC8C,OAAO,CAAC8B,MAAM,GAAG,CAC5F,CAAC,CAAA;AACD,EAAA,OAAOH,UAAU,CAACzE,OAAO,CAAC8C,OAAO,CAAA;AACnC,CAAA;AAEA,SAASC,UAAUA,CAACnD,KAAK,EAAEuC,gBAAgB,EAAEU,kBAAkB,EAAE/B,IAAI,EAAE;EACrE,IAAI;AAAES,IAAAA,IAAI,EAAEsD,oBAAAA;AAAqB,GAAC,GAAGhC,kBAAkB,CAAA;EACvD,IAAI;AAAE/B,IAAAA,IAAI,EAAEgE,UAAAA;AAAW,GAAC,GAAG3C,gBAAgB,CAAA;AAC3C,EAAA,IAAIa,UAAU,GAAGwB,sBAAsB,CAAC5E,KAAK,EAAE;AAAEkB,IAAAA,IAAI,EAAEgE,UAAAA;GAAY,EAAED,oBAAoB,CAAC,CAAA;AAE1F,EAAA,IAAI7B,UAAU,EAAE;IACd,MAAMyB,UAAU,GAAG7E,KAAK,CAAC8E,0BAA0B,EAAE,CAACC,0BAA0B,CAAC;AAAE7D,MAAAA,IAAAA;AAAK,KAAC,CAAC,CAAA;IAC1F,IAAI;AAAEmC,MAAAA,IAAAA;AAAK,KAAC,GAAGwB,UAAU,CAACzB,UAAU,CAAC,CAAA;IACrC,OAAO;MACLA,UAAU;AACVC,MAAAA,IAAAA;KACD,CAAA;AACH,GAAA;AACF,CAAA;AAEA,SAASK,8BAA8BA,CAAClB,gBAAgB,EAAEvC,UAAU,EAAE;EACpE,IAAIuC,gBAAgB,KAAK,IAAI,EAAE;AAC7B,IAAA,OAAO,KAAK,CAAA;AACd,GAAA;AAEA,EAAA,IAAIX,KAAK,CAACC,OAAO,CAACU,gBAAgB,CAAC,EAAE;AACnC,IAAA,IAAIA,gBAAgB,CAACwC,MAAM,KAAK,CAAC,EAAE;AACjC,MAAA,OAAO,KAAK,CAAA;AACd,KAAA;AACA,IAAA,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG3C,gBAAgB,CAACwC,MAAM,EAAEG,CAAC,EAAE,EAAE;AAChD,MAAA,IAAIC,KAAK,GAAG5C,gBAAgB,CAAC2C,CAAC,CAAC,CAAA;AAC/B,MAAA,IAAIE,yBAAyB,CAACD,KAAK,EAAEnF,UAAU,CAAC,EAAE;AAChD,QAAA,OAAO,IAAI,CAAA;AACb,OAAA;AACF,KAAA;AACF,GAAC,MAAM;AACL,IAAA,OAAOoF,yBAAyB,CAAC7C,gBAAgB,EAAEvC,UAAU,CAAC,CAAA;AAChE,GAAA;AAEA,EAAA,OAAO,KAAK,CAAA;AACd,CAAA;AAEA,SAAS0E,mBAAmBA,CAACnC,gBAAgB,EAAE8C,gBAAgB,EAAE;EAAE1D,EAAE;AAAEV,EAAAA,IAAAA;AAAK,CAAC,EAAE;AAC7E,EAAA,IAAIqE,sBAAsB,GAAG;IAC3B3D,EAAE;AACFV,IAAAA,IAAAA;GACD,CAAA;AAED,EAAA,IAAIO,OAAO,CAAA;EAEX,IAAI6D,gBAAgB,KAAK,SAAS,EAAE;IAClC7D,OAAO,GAAGe,gBAAgB,IAAI,EAAE,CAAA;AAChC,IAAA,IAAIA,gBAAgB,EAAE;AACpB;AACA;AACA;AACA,MAAA,IAAIgD,KAAK,GAAGhD,gBAAgB,CAACiD,IAAI,CAAEC,CAAC,IAAK;AACvC,QAAA,OAAOA,CAAC,CAACxE,IAAI,KAAKqE,sBAAsB,CAACrE,IAAI,IAAIwE,CAAC,CAAC9D,EAAE,KAAK2D,sBAAsB,CAAC3D,EAAE,CAAA;AACrF,OAAC,CAAC,CAAA;MACF,IAAI,CAAC4D,KAAK,EAAE;AACV/D,QAAAA,OAAO,CAACuB,IAAI,CAACuC,sBAAsB,CAAC,CAAA;AACtC,OAAA;AACF,KAAC,MAAM;AACL9D,MAAAA,OAAO,CAACuB,IAAI,CAACuC,sBAAsB,CAAC,CAAA;AACtC,KAAA;AACF,GAAC,MAAM;AACL9D,IAAAA,OAAO,GAAGe,gBAAgB,IAAI,EAAE,CAAA;AAChCmD,IAAAA,MAAM,CAACC,MAAM,CAACnE,OAAO,EAAE8D,sBAAsB,CAAC,CAAA;AAChD,GAAA;AAEA,EAAA,OAAO9D,OAAO,CAAA;AAChB,CAAA;AAEA,SAAS4D,yBAAyBA,CAAC;AAAEzD,EAAAA,EAAAA;AAAG,CAAC,EAAE;AAAEA,EAAAA,EAAE,EAAEiE,aAAAA;AAAc,CAAC,EAAE;EAChE,OAAOjE,EAAE,IAAIA,EAAE,CAACkE,QAAQ,EAAE,KAAKD,aAAa,CAAA;AAC9C;;ACrOA,MAAME,yBAAyB,GAAG,IAAIC,GAAG,CAAC,CACxC,YAAY,EACZ,SAAS,EACT,OAAO,EACP,aAAa,EACb,eAAe,EACf,aAAa,EACb,cAAc,EACd,cAAc,EACd,cAAc,CACf,CAAC,CAAA;AAEK,MAAMC,oBAA6B,GAAG;AAC3CC,EAAAA,OAAOA,CAAIC,OAA4B,EAAEC,IAAe,EAAc;AACpE;IACA,IAAID,OAAO,CAACD,OAAO,CAACG,GAAG,IAAI,CAACF,OAAO,CAACD,OAAO,CAACI,EAAE,IAAI,CAACP,yBAAyB,CAACQ,GAAG,CAACJ,OAAO,CAACD,OAAO,CAACI,EAAE,CAAC,EAAE;AACpG,MAAA,OAAOF,IAAI,CAACD,OAAO,CAACD,OAAO,CAAC,CAAA;AAC9B,KAAA;IAEA,MAAM;AAAElG,MAAAA,KAAAA;KAAO,GAAGmG,OAAO,CAACD,OAAO,CAAA;AACjC,IAAA,IAAI,CAAClG,KAAK,CAACU,aAAa,EAAE;AACxBV,MAAAA,KAAK,CAACU,aAAa,GAAG,IAAI8F,YAAY,CAACxG,KAAK,CAAC,CAAA;AAC/C,KAAA;AAEA,IAAA,QAAQmG,OAAO,CAACD,OAAO,CAACI,EAAE;AACxB,MAAA,KAAK,YAAY;QACf,OAAOG,UAAU,CAACN,OAAO,CAAC,CAAA;AAC5B,MAAA,KAAK,SAAS;QACZ,OAAOO,OAAO,CAACP,OAAO,CAAC,CAAA;AACzB,MAAA,KAAK,OAAO;QACV,OAAOQ,KAAK,CAACR,OAAO,CAAC,CAAA;AACvB,MAAA,KAAK,aAAa;QAChB,OAAOS,WAAW,CAACT,OAAO,CAAC,CAAA;AAC7B,MAAA,KAAK,eAAe;QAClB,OAAO/D,aAAa,CAAC+D,OAAO,CAAC,CAAA;AAC/B,MAAA,KAAK,aAAa;QAChB,OAAOpF,WAAW,CAACoF,OAAO,CAAC,CAAA;AAC7B,MAAA,KAAK,cAAc;QACjB,OAAOU,UAAU,CAACV,OAAO,CAAC,CAAA;AAC5B,MAAA,KAAK,cAAc;QACjB,OAAOU,UAAU,CAACV,OAAO,CAAC,CAAA;AAC5B,MAAA,KAAK,cAAc;QACjB,OAAOU,UAAU,CAACV,OAAO,CAAC,CAAA;AAC5B,MAAA;AACE,QAAA,OAAOC,IAAI,CAACD,OAAO,CAACD,OAAO,CAAC,CAAA;AAChC,KAAA;AACF,GAAA;AACF,EAAC;AAED,SAAS9D,aAAaA,CAAI+D,OAA4B,EAAc;EAClE,MAAM;IAAEnG,KAAK;IAAE+B,IAAI;AAAE+E,IAAAA,OAAO,EAAEC,WAAAA;GAAa,GAAGZ,OAAO,CAACD,OAAO,CAAA;EAC7D,MAAM;IAAE9F,OAAO;IAAE4G,MAAM;IAAE3E,KAAK;IAAEzB,OAAO;AAAEqG,IAAAA,KAAAA;AAAM,GAAC,GAAGlF,IAMlD,CAAA;AACD,EAAA,MAAM9B,UAAU,GAAG8G,WAAW,GAAG,CAAC,CAAC,CAAA;;AAEnC;AACA,EAAA,IAAIG,cAAc,GAChBjH,UAAU,IAAID,KAAK,CAACU,aAAa,CAACyG,eAAe,CAAClH,UAAU,EAAoCG,OAAO,CAAC,CAAA;AAC1G,EAAA,IAAI8G,cAAc,EAAE;AAClB,IAAA,OAAOA,cAAc,CAAA;AACvB,GAAA;AAEA,EAAA,IAAItG,OAAO,EAAE;AACX,IAAA,OAAOsB,cAAc,CAAClC,KAAK,EAAEgH,MAAM,EAAE3E,KAAK,CAAE+E,OAAO,EAAEH,KAAK,EAAE7G,OAAO,CAAC,CAAA;AACtE,GAAA;AAEAa,EAAAA,MAAM,CAAE,CAAA,sBAAA,CAAuB,EAAEY,KAAK,CAACC,OAAO,CAACiF,WAAW,CAAC,IAAIA,WAAW,CAAC/B,MAAM,KAAK,CAAC,CAAC,CAAA;AAExF,EAAA,MAAMqC,OAAO,GAAGrH,KAAK,CAACU,aAAa,CAAA;EACnC4G,qBAAqB,CAACrH,UAAW,CAAC,CAAA;AAElC,EAAA,OAAOG,OAAO,CAACmH,MAAM,GAChBF,OAAO,CAACG,aAAa,CAACvH,UAAU,EAAEG,OAAO,EAAE+F,OAAO,CAACD,OAAO,CAAC,GAC3DmB,OAAO,CAACI,8BAA8B,CAACxH,UAAU,EAAEG,OAAO,EAAE+F,OAAO,CAACD,OAAO,CAAgB,CAAA;AAClG,CAAA;AAEA,SAASnF,WAAWA,CAAIoF,OAA4B,EAAc;EAChE,MAAM;IAAEnG,KAAK;IAAE+B,IAAI;AAAE+E,IAAAA,OAAO,EAAEC,WAAAA;GAAa,GAAGZ,OAAO,CAACD,OAAO,CAAA;EAC7D,MAAM;IAAE9F,OAAO;IAAE4G,MAAM;IAAE3E,KAAK;IAAEzB,OAAO;AAAEqG,IAAAA,KAAAA;AAAM,GAAC,GAAGlF,IAMlD,CAAA;;AAED;AACA,EAAA,IAAInB,OAAO,EAAE;IACX,MAAMb,OAAO,GAAGC,KAAK,CAACmC,UAAU,CAAC6E,MAAM,CAAC9F,IAAI,CAAC,CAAA;AAC7C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IAGID,MAAM,CAAE,yEAAwE+F,MAAM,CAAC9F,IAAK,CAAE,CAAA,CAAA,EAAEnB,OAAO,CAAC,CAAA;IACxGkB,MAAM,CACH,4IAA2I,EAC5I,OAAOlB,OAAO,CAACgB,WAAW,KAAK,UACjC,CAAC,CAAA;AAED,IAAA,OAAOjB,YAAY,CAACC,OAAO,EAAEC,KAAK,EAAEgH,MAAM,EAAE3E,KAAK,CAAE+E,OAAO,EAAEH,KAAK,EAAE7G,OAAO,CAAC,CAAA;AAC7E,GAAA;;AAEA;;EAEA,MAAMsH,OAAO,GAAG,IAAI7F,KAAK,CAA6CkF,WAAW,CAAE/B,MAAM,CAAC,CAAA;AAC1F,EAAA,MAAMqC,OAAO,GAAGrH,KAAK,CAACU,aAAa,CAAA;AAEnC,EAAA,KAAK,IAAIyE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4B,WAAW,CAAE/B,MAAM,EAAEG,CAAC,EAAE,EAAE;AAC5C,IAAA,IAAIlF,UAAU,GAAG8G,WAAW,CAAE5B,CAAC,CAAC,CAAA;AAChC;IACAmC,qBAAqB,CAACrH,UAAU,CAAC,CAAA;AACjCyH,IAAAA,OAAO,CAACvC,CAAC,CAAC,GAAG/E,OAAO,CAACmH,MAAM,GACvBF,OAAO,CAACG,aAAa,CAACvH,UAAU,EAAEG,OAAO,EAAE+F,OAAO,CAACD,OAAO,CAAC,GAC3DmB,OAAO,CAACI,8BAA8B,CAACxH,UAAU,EAAEG,OAAO,EAAE+F,OAAO,CAACD,OAAO,CAAC,CAAA;AAClF,GAAA;AAEA,EAAA,OAAO5F,OAAO,CAACqH,GAAG,CAACD,OAAO,CAAC,CAAA;AAC7B,CAAA;AAEA,SAASb,UAAUA,CAAIV,OAA4B,EAAc;EAC/D,MAAM;IAAEnG,KAAK;IAAE+B,IAAI;AAAEuE,IAAAA,EAAE,EAAEsB,SAAAA;GAAW,GAAGzB,OAAO,CAACD,OAAO,CAAA;EACtD,MAAM;IAAE9F,OAAO;AAAE4G,IAAAA,MAAM,EAAE/G,UAAAA;AAAW,GAAC,GAAG8B,IAA4E,CAAA;AAEpH,EAAA,MAAM8F,WAAW,GAAGlC,MAAM,CAACC,MAAM,CAC/B;AAAE,IAAA,CAACkC,MAAM,GAAGF,SAAAA;GAA+D,EAC3ExH,OACF,CAAC,CAAA;EACD,MAAM2H,mBAAmB,GAAG/H,KAAK,CAACU,aAAa,CAACsH,YAAY,CAAC/H,UAAU,EAAE4H,WAAW,CAAC,CAAA;AAErF,EAAA,OAAOE,mBAAmB,CACvBvH,IAAI,CAAEiB,OAAO,IAAK;AACjB,IAAA,IAAA6B,cAAA,CAAAC,YAAA,GAAA0E,KAAA,CAAAC,YAAA,CAAkB,EAAA;MAChB,IAAI;AACF,QAAA,IAAIC,WAAoB,GAAG1G,OAAO,GAAGoC,IAAI,CAACuE,KAAK,CAACvE,IAAI,CAACC,SAAS,CAACrC,OAAO,CAAC,CAAC,GAAGA,OAAO,CAAA;AAClF;QACA4G,OAAO,CAACC,GAAG,CAAE,CAAA,sBAAA,EAAwBV,SAAW,CAAC,CAAA,EAAEO,WAAW,CAAC,CAAA;OAChE,CAAC,OAAOI,CAAC,EAAE;AACV;QACAF,OAAO,CAACC,GAAG,CAAE,CAAA,sBAAA,EAAwBV,SAAW,CAAC,CAAA,EAAEnG,OAAO,CAAC,CAAA;AAC7D,OAAA;AACF,KAAA;AACA,IAAA,IAAI+G,MAAkC,CAAA;AACtC;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IAGMxI,KAAK,CAACyI,KAAK,CAAC,MAAM;MAChBD,MAAM,GAAGxI,KAAK,CAAC0I,KAAK,CAACC,SAAS,CAAC1I,UAAU,EAAE;QAAEiG,OAAO,EAAEC,OAAO,CAACD,OAAO;AAAE0C,QAAAA,OAAO,EAAEnH,OAAAA;AAAQ,OAAC,CAAC,CAAA;AAC5F,KAAC,CAAC,CAAA;AACF,IAAA,OAAOzB,KAAK,CAAC6I,UAAU,CAACL,MAAM,CAAEzG,IAAK,CAAC,CAAA;AACxC,GAAC,CAAC,CACD+G,KAAK,CAAEP,CAAU,IAAK;IACrB,IAAIQ,GAAG,GAAGR,CAAC,CAAA;IACX,IAAI,CAACA,CAAC,EAAE;AACNQ,MAAAA,GAAG,GAAG,IAAIC,KAAK,CAAE,uCAAsC,CAAC,CAAA;AAC1D,KAAC,MAAM,IAAI,OAAOT,CAAC,KAAK,QAAQ,EAAE;AAChCQ,MAAAA,GAAG,GAAG,IAAIC,KAAK,CAACT,CAAC,CAAC,CAAA;AACpB,KAAA;AACAU,IAAAA,oBAAoB,CAACjJ,KAAK,EAAEC,UAAU,EAAE8I,GAAY,CAAC,CAAA;AACrD,IAAA,MAAMA,GAAG,CAAA;AACX,GAAC,CAAC,CAAA;AACN,CAAA;AAEA,SAASE,oBAAoBA,CAC3BjJ,KAAY,EACZC,UAAkC,EAClCiJ,KAAgF,EAChF;AACA,EAAA,IAAIA,KAAK,IAAIA,KAAK,CAACC,cAAc,KAAK,IAAI,IAAID,KAAK,CAACE,IAAI,KAAK,cAAc,EAAE;IAC3E,IAAI7H,UAAU,GAAGvB,KAAK,CAACwB,aAAa,CAACvB,UAAU,CAACiB,IAAI,CAA8B,CAAA;;AAElF;AACA;IACA,IAAIK,UAAU,IAAI,OAAOA,UAAU,CAAC8H,aAAa,KAAK,UAAU,EAAE;MAChE,IAAIC,UAAU,GAAG/H,UAAU,CAAC8H,aAAa,CAACrJ,KAAK,EAAEA,KAAK,CAACsB,QAAQ,CAACrB,UAAU,CAACiB,IAAI,CAAC,EAAEgI,KAAK,EAAEjJ,UAAU,CAAC2B,EAAE,CAGrG,CAAA;AACDsH,MAAAA,KAAK,CAACK,MAAM,GAAGC,iBAAiB,CAACF,UAAU,CAAC,CAAA;AAC9C,KAAA;AACF,GAAA;AACA,EAAA,MAAMZ,KAAK,GAAG1I,KAAK,CAAC0I,KAAK,CAAA;EAEzB,IAAIQ,KAAK,CAACK,MAAM,EAAE;AAChBtI,IAAAA,MAAM,CACH,CAAA,sCAAA,EAAwCwI,MAAM,CAC7CxJ,UACF,CAAE,CAAA,8DAAA,CAA+D,EACjE,OAAOyI,KAAK,CAACgB,SAAS,KAAK,UAC7B,CAAC,CAAA;AAED,IAAA,IAAIC,aAA6B,GAAGT,KAAK,CAACK,MAAM,CAAA;AAChD,IAAA,IAAII,aAAa,CAAC3E,MAAM,KAAK,CAAC,EAAE;AAC9B2E,MAAAA,aAAa,GAAG,CAAC;AAAEC,QAAAA,KAAK,EAAE,eAAe;AAAEC,QAAAA,MAAM,EAAE,EAAE;AAAEC,QAAAA,MAAM,EAAE;AAAEC,UAAAA,OAAO,EAAE,OAAA;AAAQ,SAAA;AAAE,OAAC,CAAC,CAAA;AACxF,KAAA;AACArB,IAAAA,KAAK,CAACsB,iBAAiB,CAAC/J,UAAU,EAAE0J,aAAa,CAAC,CAAA;AACpD,GAAC,MAAM;AACLjB,IAAAA,KAAK,CAACsB,iBAAiB,CAAC/J,UAAU,CAAC,CAAA;AACrC,GAAA;AACF,CAAA;AAEA,SAASgK,SAASA,CAAIC,KAAc,EAAO;EACzC,OAAOrI,KAAK,CAACC,OAAO,CAACoI,KAAK,CAAC,GAAGA,KAAK,GAAG,CAACA,KAAK,CAAC,CAAA;AAC/C,CAAA;AAEA,MAAMC,qBAAqB,GAAG,MAAM,CAAA;AACpC,SAASX,iBAAiBA,CAACD,MAAyC,EAAkB;EACpF,MAAMa,GAAmB,GAAG,EAAE,CAAA;AAE9B,EAAA,IAAIb,MAAM,EAAE;IACV5D,MAAM,CAAC0E,IAAI,CAACd,MAAM,CAAC,CAACe,OAAO,CAAEnJ,GAAG,IAAK;MACnC,IAAIoJ,QAAQ,GAAGN,SAAS,CAACV,MAAM,CAACpI,GAAG,CAAC,CAAC,CAAA;AACrC,MAAA,KAAK,IAAIgE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoF,QAAQ,CAACvF,MAAM,EAAEG,CAAC,EAAE,EAAE;QACxC,IAAIyE,KAAK,GAAG,mBAAmB,CAAA;AAC/B,QAAA,IAAIG,OAAO,GAAI,CAAmB5I,iBAAAA,EAAAA,GAAI,CAAC,CAAA,CAAA;QACvC,IAAIA,GAAG,KAAKgJ,qBAAqB,EAAE;AACjCP,UAAAA,KAAK,GAAG,kBAAkB,CAAA;AAC1BG,UAAAA,OAAO,GAAI,CAAM,KAAA,CAAA,CAAA;AACnB,SAAA;QACAK,GAAG,CAACpH,IAAI,CAAC;AACP4G,UAAAA,KAAK,EAAEA,KAAK;AACZC,UAAAA,MAAM,EAAEU,QAAQ,CAACpF,CAAC,CAAC;AACnB2E,UAAAA,MAAM,EAAE;AACNC,YAAAA,OAAO,EAAEA,OAAAA;AACX,WAAA;AACF,SAAC,CAAC,CAAA;AACJ,OAAA;AACF,KAAC,CAAC,CAAA;AACJ,GAAA;AAEA,EAAA,OAAOK,GAAG,CAAA;AACZ,CAAA;AAEA,SAAS3D,UAAUA,CAAIN,OAA4B,EAAc;EAC/D,MAAM;IAAEnG,KAAK;AAAE+B,IAAAA,IAAAA;GAAM,GAAGoE,OAAO,CAACD,OAAO,CAAA;EACvC,MAAM;AAAEc,IAAAA,MAAM,EAAE/G,UAAU;AAAEG,IAAAA,OAAAA;AAAQ,GAAC,GAAG2B,IAGvC,CAAA;AACD,EAAA,IAAI1B,OAAwC,CAAA;;AAE5C;EACA,IAAI,CAACL,KAAK,CAACwK,cAAc,CAACC,cAAc,CAACxK,UAAU,CAAC,EAAE;AACpDI,IAAAA,OAAO,GAAGL,KAAK,CAACU,aAAa,CAAC+G,8BAA8B,CAACxH,UAAU,EAAEG,OAAO,EAAE+F,OAAO,CAACD,OAAO,CAAC,CAAA;;AAElG;AACF,GAAC,MAAM,IAAI9F,OAAO,CAACmH,MAAM,EAAE;IACzBD,qBAAqB,CAACrH,UAAU,CAAC,CAAA;AAEjCI,IAAAA,OAAO,GAAGL,KAAK,CAACU,aAAa,CAAC8G,aAAa,CAACvH,UAAU,EAAEG,OAAO,EAAE+F,OAAO,CAACD,OAAO,CAAC,CAAA;AACnF,GAAC,MAAM;IACL,IAAIzF,QAAyB,GAAG,IAAI,CAAA;IACpC,IAAIV,OAAO,GAAGC,KAAK,CAACmC,UAAU,CAAClC,UAAU,CAACiB,IAAI,CAAC,CAAA;;AAE/C;AACA,IAAA,IACE,OAAOd,OAAO,CAACmH,MAAM,KAAK,WAAW,IACrCxH,OAAO,CAAC2K,kBAAkB,IAC1B3K,OAAO,CAAC2K,kBAAkB,CAAC1K,KAAK,EAAGS,QAAQ,GAAGT,KAAK,CAACU,aAAa,CAACC,cAAc,CAACV,UAAU,EAAEG,OAAO,CAAE,CAAC,EACvG;MACAkH,qBAAqB,CAACrH,UAAU,CAAC,CAAA;AACjC,MAAA,IAAAqD,cAAA,CAAAC,YAAA,GAAAC,GAAA,CAAAC,KAAA,CAAW,EAAA;AACTpD,QAAAA,OAAO,GAAGL,KAAK,CAACU,aAAa,CAAC8G,aAAa,CACzCvH,UAAU,EACV0F,MAAM,CAACC,MAAM,CAAC,EAAE,EAAExF,OAAO,EAAE;AAAEmH,UAAAA,MAAM,EAAE,IAAA;AAAK,SAAC,CAAC,EAC5CpB,OAAO,CAACD,OACV,CAAC,CAAA;AACH,OAAC,MAAM;QACL9F,OAAO,CAACmH,MAAM,GAAG,IAAI,CAAA;AACrBlH,QAAAA,OAAO,GAAGL,KAAK,CAACU,aAAa,CAAC8G,aAAa,CAACvH,UAAU,EAAEG,OAAO,EAAE+F,OAAO,CAACD,OAAO,CAAC,CAAA;AACnF,OAAA;AACF,KAAC,MAAM;AACL;AACA,MAAA,IACE9F,OAAO,CAACuK,gBAAgB,KAAK,KAAK,KACjCvK,OAAO,CAACuK,gBAAgB,IACvB,CAAC5K,OAAO,CAAC6K,4BAA4B,IACrC7K,OAAO,CAAC6K,4BAA4B,CAClC5K,KAAK,EACJS,QAAQ,GAAGA,QAAQ,IAAIT,KAAK,CAACU,aAAa,CAACC,cAAc,CAACV,UAAU,EAAEG,OAAO,CAChF,CAAC,CAAC,EACJ;QACAkH,qBAAqB,CAACrH,UAAU,CAAC,CAAA;AAEjC,QAAA,IAAAqD,cAAA,CAAAC,YAAA,GAAAC,GAAA,CAAAC,KAAA,CAAW,EAAA;AACT,UAAA,KAAKzD,KAAK,CAACU,aAAa,CAAC8G,aAAa,CACpCvH,UAAU,EACV0F,MAAM,CAACC,MAAM,CAAC,EAAE,EAAExF,OAAO,EAAE;AAAEuK,YAAAA,gBAAgB,EAAE,IAAA;AAAK,WAAC,CAAC,EACtDxE,OAAO,CAACD,OACV,CAAC,CAAA;AACH,SAAC,MAAM;UACL9F,OAAO,CAACuK,gBAAgB,GAAG,IAAI,CAAA;AAC/B,UAAA,KAAK3K,KAAK,CAACU,aAAa,CAAC8G,aAAa,CAACvH,UAAU,EAAEG,OAAO,EAAE+F,OAAO,CAACD,OAAO,CAAC,CAAA;AAC9E,SAAA;AACF,OAAA;;AAEA;AACA7F,MAAAA,OAAO,GAAGC,OAAO,CAACC,OAAO,CAACN,UAAU,CAAoC,CAAA;AAC1E,KAAA;AACF,GAAA;AAEA,EAAA,OAAOI,OAAO,CAACG,IAAI,CAAE2E,CAAyB,IAAKnF,KAAK,CAAC6I,UAAU,CAAC1D,CAAC,CAAC,CAAC,CAAA;AACzE,CAAA;AAEA,SAASuB,OAAOA,CAAIP,OAA4B,EAAc;EAC5D,MAAM;IAAEnG,KAAK;AAAE+B,IAAAA,IAAAA;GAAM,GAAGoE,OAAO,CAACD,OAAO,CAAA;EACvC,MAAM;IAAEhF,IAAI;AAAEd,IAAAA,OAAAA;AAAQ,GAAC,GAAG2B,IAGzB,CAAA;AACD,EAAA,MAAMhC,OAAO,GAAGC,KAAK,CAACmC,UAAU,CAACjB,IAAI,CAAC,CAAA;AAEtCD,EAAAA,MAAM,CAAE,CAA6DC,2DAAAA,EAAAA,IAAK,CAAE,CAAA,CAAA,EAAEnB,OAAO,CAAC,CAAA;EACtFkB,MAAM,CACH,6EAA4E,EAC7E,OAAOlB,OAAO,CAAC2G,OAAO,KAAK,UAC7B,CAAC,CAAA;;AAED;EACA,MAAMmE,gBAAgB,GAAG7K,KAAK,CAAC8K,kBAAkB,CAACC,KAAK,CAACC,GAAG,CAAC9J,IAAI,CAAC,CAAA;EACjE,MAAM+J,aAAa,GAAG,IAAIC,mBAAmB,CAAClL,KAAK,EAAEkB,IAAI,EAAEd,OAAO,CAAC,CAAA;AAEnE,EAAA,MAAM+K,YAAY,GAChB/K,OAAO,CAACmH,MAAM,IACbnH,OAAO,CAACmH,MAAM,KAAK,KAAK,KACrBxH,OAAO,CAACqL,eAAe,IAAIrL,OAAO,CAACqL,eAAe,CAACpL,KAAK,EAAEiL,aAAa,CAAC,IACvE,CAAClL,OAAO,CAACqL,eAAe,IAAIH,aAAa,CAACjG,MAAM,KAAK,CAAE,CAAE,CAAA;AAEhE,EAAA,IAAIqG,KAA6B,CAAA;AACjC,EAAA,IAAIF,YAAY,EAAE;AAChBN,IAAAA,gBAAgB,KAAKA,gBAAgB,CAACS,UAAU,GAAG,IAAI,CAAC,CAAA;AACxDD,IAAAA,KAAK,GAAGE,QAAQ,CAACxL,OAAO,EAAEC,KAAK,EAAEkB,IAAI,EAAE+J,aAAa,EAAE9E,OAAO,CAACD,OAAO,EAAE,IAAI,CAAC,CAAA;AAC9E,GAAC,MAAM;IACLmF,KAAK,GAAG/K,OAAO,CAACC,OAAO,CAACP,KAAK,CAACwL,OAAO,CAACtK,IAAI,CAAC,CAAe,CAAA;IAE1D,IACEd,OAAO,CAACuK,gBAAgB,IACvBvK,OAAO,CAACuK,gBAAgB,KAAK,KAAK,KAChC,CAAC5K,OAAO,CAAC0L,yBAAyB,IAAI1L,OAAO,CAAC0L,yBAAyB,CAACzL,KAAK,EAAEiL,aAAa,CAAC,CAAE,EAClG;AACAJ,MAAAA,gBAAgB,KAAKA,gBAAgB,CAACS,UAAU,GAAG,IAAI,CAAC,CAAA;AACxD,MAAA,KAAKC,QAAQ,CAACxL,OAAO,EAAEC,KAAK,EAAEkB,IAAI,EAAE+J,aAAa,EAAE9E,OAAO,CAACD,OAAO,EAAE,KAAK,CAAC,CAAA;AAC5E,KAAA;AACF,GAAA;AAEA,EAAA,OAAOmF,KAAK,CAAA;AACd,CAAA;AAEA,SAASE,QAAQA,CACfxL,OAAgC,EAChCC,KAAY,EACZkB,IAAY,EACZ+J,aAAkC,EAClC/E,OAAyB,EACzBwF,YAAqB,EACT;AACZ,EAAA,MAAMC,MAAM,GAAG3L,KAAK,CAACsB,QAAQ,CAACJ,IAAI,CAAC,CAAA;EACnC,IAAIb,OAAmB,GAAGC,OAAO,CAACC,OAAO,EAAE,CAACC,IAAI,CAAC,MAC/CT,OAAO,CAAC2G,OAAO,CAAC1G,KAAK,EAAE2L,MAAM,EAAE,IAAI,EAAEV,aAAa,CACpD,CAAe,CAAA;AAEf5K,EAAAA,OAAO,GAAGA,OAAO,CAACG,IAAI,CAAEQ,cAAiB,IAAK;IAC5CC,MAAM,CACH,qCAAoCC,IAAK,CAAA,2DAAA,CAA4D,EACtGE,iBAAiB,CAACJ,cAAc,CAClC,CAAC,CAAA;AACD,IAAA,MAAMO,UAAU,GAAGvB,KAAK,CAACwB,aAAa,CAACN,IAAI,CAAC,CAAA;AAC5C,IAAA,MAAMO,OAAO,GAAGC,uBAAuB,CAACH,UAAU,EAAEvB,KAAK,EAAE2L,MAAM,EAAE3K,cAAc,EAAE,IAAI,EAAE,SAAS,CAAC,CAAA;AAEnGhB,IAAAA,KAAK,CAACiC,KAAK,CAACR,OAAO,EAAEiK,YAAY,CAAC,CAAA;AAClCT,IAAAA,aAAa,CAACW,YAAY,CAACN,UAAU,GAAG,KAAK,CAAA;AAE7C,IAAA,IAAAhI,cAAA,CAAAC,YAAA,GAAA0E,KAAA,CAAAC,YAAA,CAAkB,EAAA;AAChB;AACAG,MAAAA,OAAO,CAACC,GAAG,CAAE,CAAmBpH,iBAAAA,EAAAA,IAAK,8BAA6B,CAAC,CAAA;AACrE,KAAA;IACA,OAAO+J,aAAa,CAACW,YAAY,CAAA;AACnC,GAAC,CAAe,CAAA;AAEhB,EAAA,IAAAtI,cAAA,CAAAC,YAAA,GAAAC,GAAA,CAAAqI,OAAA,CAAa,EAAA;AACX,IAAA,IAAI,CAAC3F,OAAO,CAAC4F,iBAAiB,EAAE;MAC9B,MAAM;AAAEC,QAAAA,cAAAA;AAAe,OAAC,GAAGC,UAAU,CAAC,qBAAqB,CAE1D,CAAA;AACD3L,MAAAA,OAAO,GAAG0L,cAAc,CAAC1L,OAAO,CAAC,CAAA;AACnC,KAAA;AACF,GAAA;AAEA,EAAA,OAAOA,OAAO,CAAA;AAChB,CAAA;AAEA,SAASsG,KAAKA,CAAIR,OAA4B,EAAc;EAC1D,MAAM;IAAEnG,KAAK;AAAE+B,IAAAA,IAAAA;GAAM,GAAGoE,OAAO,CAACD,OAAO,CAAA;EACvC,IAAI;AAAE9F,IAAAA,OAAAA;AAAQ,GAAC,GAAG2B,IAEjB,CAAA;AACD;EACA,MAAM;IAAEb,IAAI;AAAEyF,IAAAA,KAAAA;AAAM,GAAC,GAAG5E,IAIvB,CAAA;AACD,EAAA,MAAMhC,OAAO,GAAGC,KAAK,CAACmC,UAAU,CAACjB,IAAI,CAAC,CAAA;AAEtCD,EAAAA,MAAM,CAAE,CAAyDC,uDAAAA,EAAAA,IAAK,CAAE,CAAA,CAAA,EAAEnB,OAAO,CAAC,CAAA;EAClFkB,MAAM,CAAE,uEAAsE,EAAE,OAAOlB,OAAO,CAAC4G,KAAK,KAAK,UAAU,CAAC,CAAA;EAEpH,MAAMsF,WAAW,GACf7L,OAAO,CAACwL,YAAY,IACpB5L,KAAK,CAAC8K,kBAAkB,CAACoB,WAAW,CAAC;IACnChL,IAAI;AACJyF,IAAAA,KAAAA;AACF,GAAC,CAAC,CAAA;AAEJ,EAAA,IAAArD,cAAA,CAAAC,YAAA,GAAAC,GAAA,CAAAC,KAAA,CAAW,EAAA;IACTrD,OAAO,GAAGuF,MAAM,CAACC,MAAM,CAAC,EAAE,EAAExF,OAAO,CAAC,CAAA;IACpC,OAAOA,OAAO,CAACwL,YAAY,CAAA;AAC7B,GAAC,MAAM;IACL,OAAOxL,OAAO,CAACwL,YAAY,CAAA;AAC7B,GAAA;AACA,EAAA,MAAMD,MAAM,GAAG3L,KAAK,CAACsB,QAAQ,CAACJ,IAAI,CAAC,CAAA;EACnC,IAAIb,OAAO,GAAGC,OAAO,CAACC,OAAO,EAAE,CAACC,IAAI,CAAC,MAAMT,OAAO,CAAC4G,KAAK,CAAC3G,KAAK,EAAE2L,MAAM,EAAEhF,KAAK,EAAEsF,WAAW,EAAE7L,OAAO,CAAC,CAAC,CAAA;AAErG,EAAA,OAAOC,OAAO,CAACG,IAAI,CAAEQ,cAAc,IAAK;AACtC,IAAA,MAAMO,UAAU,GAAGvB,KAAK,CAACwB,aAAa,CAACN,IAAI,CAAC,CAAA;AAC5C,IAAA,MAAMO,OAAO,GAAGC,uBAAuB,CACrCH,UAAU,EACVvB,KAAK,EACL2L,MAAM,EACN3K,cAAc,EACd,IAAI,EACJ,OACF,CAAC,CAAA;IACD,MAAM+F,WAAW,GAAG/G,KAAK,CAACiC,KAAK,CAACR,OAAO,EAAE,IAAI,CAAC,CAAA;IAE9CR,MAAM,CACJ,mLAAmL,EACnLY,KAAK,CAACC,OAAO,CAACiF,WAAW,CAC3B,CAAC,CAAA;IAED/G,KAAK,CAAC8K,kBAAkB,CAACqB,oBAAoB,CAACF,WAAW,EAAElF,WAAW,EAAEtF,OAAqC,CAAC,CAAA;AAE9G,IAAA,OAAOwK,WAAW,CAAA;AACpB,GAAC,CAAC,CAAA;AACJ,CAAA;AAEA,SAASG,4BAA4BA,CAAC3K,OAAwB,EAA6C;AACzGR,EAAAA,MAAM,CACH,CAAA,4IAAA,CAA6I,EAC9I,CAACY,KAAK,CAACC,OAAO,CAACL,OAAO,CAACM,IAAI,CAC7B,CAAC,CAAA;AACH,CAAA;AAEA,SAAS6E,WAAWA,CAAIT,OAA4B,EAAc;EAChE,MAAM;IAAEnG,KAAK;AAAE+B,IAAAA,IAAAA;GAAM,GAAGoE,OAAO,CAACD,OAAO,CAAA;AACvC;EACA,MAAM;IAAEhF,IAAI;IAAEyF,KAAK;AAAEvG,IAAAA,OAAAA;AAAQ,GAAC,GAAG2B,IAAyE,CAAA;AAC1G,EAAA,MAAMhC,OAAO,GAAGC,KAAK,CAACmC,UAAU,CAACjB,IAAI,CAAC,CAAA;AAEtCD,EAAAA,MAAM,CAAE,CAAyDC,uDAAAA,EAAAA,IAAK,CAAE,CAAA,CAAA,EAAEnB,OAAO,CAAC,CAAA;EAClFkB,MAAM,CACH,6EAA4E,EAC7E,OAAOlB,OAAO,CAAC6G,WAAW,KAAK,UACjC,CAAC,CAAA;AAED,EAAA,MAAM+E,MAAM,GAAG3L,KAAK,CAACsB,QAAQ,CAACJ,IAAI,CAAC,CAAA;EACnC,IAAIb,OAAO,GAAGC,OAAO,CAACC,OAAO,EAAE,CAACC,IAAI,CAAC,MAAMT,OAAO,CAAC6G,WAAW,CAAC5G,KAAK,EAAE2L,MAAM,EAAEhF,KAAK,EAAEvG,OAAO,CAAC,CAAe,CAAA;AAE5G,EAAA,OAAOC,OAAO,CAACG,IAAI,CAAEQ,cAAiB,IAAK;AACzC,IAAA,MAAMO,UAAU,GAAGvB,KAAK,CAACwB,aAAa,CAACN,IAAI,CAAC,CAAA;AAC5C,IAAA,MAAMO,OAAO,GAAGC,uBAAuB,CACrCH,UAAU,EACVvB,KAAK,EACL2L,MAAM,EACN3K,cAAc,EACd,IAAI,EACJ,aACF,CAAC,CAAA;IAEDoL,4BAA4B,CAAC3K,OAAO,CAAC,CAAA;IAErC,MAAMxB,UAAU,GAAGD,KAAK,CAACiC,KAAK,CAACR,OAAO,EAAE,IAAI,CAA2B,CAAA;IACvE,OAAOxB,UAAU,GAAGD,KAAK,CAAC6I,UAAU,CAAC5I,UAAU,CAAC,GAAG,IAAI,CAAA;AACzD,GAAC,CAAC,CAAA;AACJ;;;;"}