import { a as assertValidRequest, C as ContextOwner, b as Context, d as createFuture, i as isFuture, _ as _classPrivateFieldBase, u as upgradePromise, e as _classPrivateFieldKey } from "./context-49bbb842";
export { f as createDeferred } from "./context-49bbb842";
import { macroCondition, getOwnConfig, importSync } from '@embroider/macros';
const STRUCTURED = Symbol('DOC');
function curryFuture(owner, inbound, outbound) {
  owner.setStream(inbound.getStream());
  inbound.then(doc => {
    const document = {
      [STRUCTURED]: true,
      request: owner.request,
      response: doc.response,
      content: doc.content
    };
    outbound.resolve(document);
  }, error => {
    if (isDoc(error)) {
      owner.setStream(owner.god.stream);
    }
    if (!error || !(error instanceof Error)) {
      try {
        throw new Error(error ? error : `Request Rejected with an Unknown Error`);
      } catch (e) {
        if (error && typeof error === 'object') {
          Object.assign(e, error);
          e.message = error.message || `Request Rejected with an Unknown Error`;
        }
        error = e;
      }
    }
    error[STRUCTURED] = true;
    error.request = owner.request;
    error.response = owner.getResponse();
    error.error = error.error || error.message;
    outbound.reject(error);
  });
  return outbound.promise;
}
function isDoc(doc) {
  return doc && doc[STRUCTURED] === true;
}
function handleOutcome(owner, inbound, outbound) {
  inbound.then(content => {
    if (owner.controller.signal.aborted) {
      // the next function did not respect the signal, we handle it here
      outbound.reject(new DOMException(owner.controller.signal.reason || 'The user aborted a request.', 'AbortError'));
      return;
    }
    if (isDoc(content)) {
      owner.setStream(owner.god.stream);
      content = content.content;
    }
    const document = {
      [STRUCTURED]: true,
      request: owner.request,
      response: owner.getResponse(),
      content
    };
    outbound.resolve(document);
  }, error => {
    if (isDoc(error)) {
      owner.setStream(owner.god.stream);
    }
    if (!error) {
      try {
        throw new Error(`Request Rejected with an Unknown Error`);
      } catch (e) {
        error = e;
      }
    }
    error[STRUCTURED] = true;
    error.request = owner.request;
    error.response = owner.getResponse();
    error.error = error.error || error.message;
    outbound.reject(error);
  });
  return outbound.promise;
}
function executeNextHandler(wares, request, i, god) {
  if (macroCondition(getOwnConfig().env.DEBUG)) {
    if (i === wares.length) {
      throw new Error(`No handler was able to handle this request.`);
    }
    assertValidRequest(request, false);
  }
  const owner = new ContextOwner(request, god);
  function next(r) {
    owner.nextCalled++;
    return executeNextHandler(wares, r, i + 1, god);
  }
  const context = new Context(owner);
  let outcome;
  try {
    outcome = wares[i].request(context, next);
    if (macroCondition(getOwnConfig().env.DEBUG)) {
      // eslint-disable-next-line @typescript-eslint/no-misused-promises
      if (!outcome || !(outcome instanceof Promise) && !(typeof outcome === 'object' && 'then' in outcome)) {
        // eslint-disable-next-line no-console
        console.log({
          request,
          handler: wares[i],
          outcome
        });
        if (outcome === undefined) {
          throw new Error(`Expected handler.request to return a promise, instead received undefined.`);
        }
        throw new Error(`Expected handler.request to return a promise, instead received a synchronous value.`);
      }
    }
  } catch (e) {
    outcome = Promise.reject(e);
  }
  const future = createFuture(owner);
  if (isFuture(outcome)) {
    return curryFuture(owner, outcome, future);
  }
  return handleOutcome(owner, outcome, future);
}
let REQ_ID = 0;
/**
 * ```js
 * import RequestManager from '@ember-data/request';
 * ```
 *
 * A RequestManager provides a request/response flow in which configured
 * handlers are successively given the opportunity to handle, modify, or
 * pass-along a request.
 *
 * ```ts
 * interface RequestManager {
 *   request<T>(req: RequestInfo): Future<T>;
 * }
 * ```
 *
 * For example:
 *
 * ```ts
 * import RequestManager from '@ember-data/request';
 * import Fetch from '@ember-data/request/fetch';
 * import Auth from 'ember-simple-auth/ember-data-handler';
 * import Config from './config';
 *
 * const { apiUrl } = Config;
 *
 * // ... create manager
 * const manager = new RequestManager();
 * manager.use([Auth, Fetch]);
 *
 * // ... execute a request
 * const response = await manager.request({
 *   url: `${apiUrl}/users`
 * });
 * ```
 *
 * ### Futures
 *
 * The return value of `manager.request` is a `Future`, which allows
 * access to limited information about the request while it is still
 * pending and fulfills with the final state when the request completes.
 *
 * A `Future` is cancellable via `abort`.
 *
 * Handlers may optionally expose a `ReadableStream` to the `Future` for
 * streaming data; however, when doing so the future should not resolve
 * until the response stream is fully read.
 *
 * ```ts
 * interface Future<T> extends Promise<StructuredDocument<T>> {
 *   abort(): void;
 *
 *   async getStream(): ReadableStream | null;
 * }
 * ```
 *
 * ### StructuredDocuments
 *
 * A Future resolves with a `StructuredDataDocument` or rejects with a `StructuredErrorDocument`.
 *
 * ```ts
 * interface StructuredDataDocument<T> {
 *   request: ImmutableRequestInfo;
 *   response: ImmutableResponseInfo;
 *   content: T;
 * }
 * interface StructuredErrorDocument extends Error {
 *   request: ImmutableRequestInfo;
 *   response: ImmutableResponseInfo;
 *   error: string | object;
 * }
 * type StructuredDocument<T> = StructuredDataDocument<T> | StructuredErrorDocument;
 * ```
 *
 * @class RequestManager
 * @public
 */
var _handlers = /*#__PURE__*/_classPrivateFieldKey("handlers");
class RequestManager {
  constructor(options) {
    Object.defineProperty(this, _handlers, {
      writable: true,
      value: []
    });
    Object.assign(this, options);
    this._pending = new Map();
  }

  /**
   * Register a handler to use for primary cache intercept.
   *
   * Only one such handler may exist. If using the same
   * RequestManager as the Store instance the Store
   * registers itself as a Cache handler.
   *
   * @method useCache
   * @public
   * @param {Handler[]} cacheHandler
   * @returns {void}
   */
  useCache(cacheHandler) {
    if (macroCondition(getOwnConfig().env.DEBUG)) {
      if (this._hasCacheHandler) {
        throw new Error(`\`RequestManager.useCache(<handler>)\` May only be invoked once.`);
      }
      if (Object.isFrozen(_classPrivateFieldBase(this, _handlers)[_handlers])) {
        throw new Error(`\`RequestManager.useCache(<handler>)\` May only be invoked prior to any request having been made.`);
      }
      this._hasCacheHandler = true;
    }
    _classPrivateFieldBase(this, _handlers)[_handlers].unshift(cacheHandler);
  }

  /**
   * Register handler(s) to use when a request is issued.
   *
   * Handlers will be invoked in the order they are registered.
   * Each Handler is given the opportunity to handle the request,
   * curry the request, or pass along a modified request.
   *
   * @method use
   * @public
   * @param {Handler[]} newHandlers
   * @returns {void}
   */
  use(newHandlers) {
    const handlers = _classPrivateFieldBase(this, _handlers)[_handlers];
    if (macroCondition(getOwnConfig().env.DEBUG)) {
      if (Object.isFrozen(handlers)) {
        throw new Error(`Cannot add a Handler to a RequestManager after a request has been made`);
      }
      if (!Array.isArray(newHandlers)) {
        throw new Error(`\`RequestManager.use(<Handler[]>)\` expects an array of handlers, but was called with \`${typeof newHandlers}\``);
      }
      newHandlers.forEach((handler, index) => {
        if (!handler || typeof handler !== 'object' || typeof handler.request !== 'function') {
          throw new Error(`\`RequestManager.use(<Handler[]>)\` expected to receive an array of handler objects with request methods, by the handler at index ${index} does not conform.`);
        }
      });
    }
    handlers.push(...newHandlers);
  }

  /**
   * Issue a Request.
   *
   * Returns a Future that fulfills with a StructuredDocument
   *
   * @method request
   * @public
   * @param {RequestInfo} request
   * @returns {Future}
   */
  request(request) {
    const handlers = _classPrivateFieldBase(this, _handlers)[_handlers];
    if (macroCondition(getOwnConfig().env.DEBUG)) {
      if (!Object.isFrozen(handlers)) {
        Object.freeze(handlers);
      }
      assertValidRequest(request, true);
    }
    const controller = request.controller || new AbortController();
    if (request.controller) {
      delete request.controller;
    }
    let promise = executeNextHandler(handlers, request, 0, {
      controller,
      response: null,
      stream: null,
      id: REQ_ID++
    });
    if (macroCondition(getOwnConfig().env.TESTING)) {
      if (!request.disableTestWaiter) {
        const {
          waitForPromise
        } = importSync('@ember/test-waiters');
        const newPromise = waitForPromise(promise);
        return upgradePromise(newPromise, promise);
      }
    }
    return promise;
  }
  static create(options) {
    return new this(options);
  }
}
export { RequestManager as default };